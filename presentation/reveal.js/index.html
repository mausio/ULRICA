<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>ULRICA - Programmentwurf Protokoll</title>

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/white.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/lightfair.css">
</head>
<style>
	code:not(.hljs) {
		font-size: 1.25rem;
	}

	pre {
		border-radius: 5px;
	}

	code {
		border-radius: 5px;
		font-size: 0.9rem !important;
	}


	/* Syntax highlighting styles similar to the screenshot */
	.hljs-keyword {
		color: blue;
		/* softer green */
		font-weight: 500;
	}

	.hljs-built_in {
		color: darkblue;
		font-weight: normal;
	}

	.hljs-string {
		color: rgb(0, 167, 206);
		/* softer yellow/orange */
		font-weight: normal;
	}

	.hljs {
		font-size: 1.25rem;
		background: transparent;
		display: inline;
	}

	h1 {
		font-size: 4rem;
	}

	h2 {
		font-size: 3rem;
	}

	h3 {
		font-size: 2.5rem;
	}

	h4 {
		font-size: 2.25rem;
		font-weight: semibold;
	}

	h5 {
		font-size: 2rem;
		font-weight: semibold;
	}

	h6 {
		font-size: 1.75rem;
		font-weight: semibold;
	}

	p {
		font-size: 1.75rem;
	}

	li {
		font-size: 1.75rem;
		margin: 5px 0;
	}

	ul {
		text-align: start;
		align-self: start;
	}

	ol {
		text-align: start;
		align-self: start;
	}

	thead {
		font-size: 1.4rem;
	}

	tr {
		font-size: 1.3rem;
	}

	th {
		font-size: 1.4rem;
	}




	.primary-color {
		color: rgb(0, 167, 206) !important;
	}


	.horizontal-container {
		display: flex;
		gap: 2rem;
		justify-content: center;
	}

	.horizontal-spaced-container {
		display: flex;
		gap: 2rem;
		justify-content: space-evenly;
	}

	.gray {
		color: #808080;
	}

	.slide-number {
		font-size: 16px !important;
		color: #333 !important;
		background-color: rgba(255, 255, 255, 0.7);
		padding: 3px 8px !important;
		border-radius: 10px;
	}

	.chapter-title {
		font-size: 3.5rem;
		margin-bottom: 2rem;
		color: #333;
		text-align: center;
	}

	.uml-image {
		max-width: 90%;
		max-height: 70vh;
		margin: 0 auto;
	}

	.center {
		text-align: center;
	}

	.acronym-letter {
		font-weight: 900;
		font-size: 120%;
	}

	.name-explanation {
		font-size: 2.5rem;
		text-align: center;
		margin: 2rem 0;
	}

	.subchapter {
		color: rgb(179, 177, 195);
		font-size: 1.8rem;
		margin-top: 1rem;
		font-style: italic;
	}
</style>

<body>
	<div class="reveal">
		<div class="slides">

			<section alt="Anfang/Einleitung">
				<h3>Programmentwurf - Protokoll</h3>
				<p class="gray center">zu</p>
				<img style="margin: 50px 0;" src="./assets/imgs/ulrica-blue.png" alt="ULRICA Logo" class="logo">
				<div class="horizontal-container gray">
					<p>Robin Schwenzfeier</p>
					<p>-</p>
					<p>4868455</p>
					<p>-</p>
					<p>TINF22B5</p>
				</div>
			</section>
			<!-- Kapitel 1-->
			<section alt="Kapitel 1">
				<section>
					<h2 class="chapter-title">Kapitel 1:<br /> Einleitung (4P)</h2>
				</section>

				<section>
					<h3 class="subchapter">Inhalt des Kapitels</h3>
					<div class="horizontal-spaced-container"
						style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
						<div>
							<h6>1. Übersicht über die Applikation (1P)</h6>
							<ul>
								<li>Name und Bedeutung</li>
								<li>Features und Funktionen</li>
								<li>Probleme, die sie löst</li>
							</ul>
						</div>
						<div>
							<h6>2. Starten der Applikation (1P)</h6>
							<ul>
								<li>Voraussetzungen</li>
								<li>Schritte zum Starten</li>
								<li>Alternative zum Starten</li>
							</ul>
						</div>
						<div>
							<h6>3. Technischer Überblick (2P)</h6>
							<ul>
								<li>Java (JDK 17)</li>
								<li>Maven</li>
								<li>JSON & GSON</li>
								<li>JUnit & JaCoCo</li>
								<li>Clean Architecture</li>
							</ul>
						</div>
						<div>
						</div>
					</div>
				</section>

				<section>
					<h3>Übersicht über die Applikation (1P)</h3>
					<p class="subchapter">Was macht die Applikation? Wie funktioniert sie? Welches Problem löst
						sie/welchen Zweck hat sie?</p>
				</section>

				<section>
					<h3><strong>ULRICA</strong>: Name erklärt</h3>
					<p class="subchapter">Ein Acronym.</p>
					<p class="name-explanation">
						<span class="acronym-letter primary-color">U</span>niversa<span
							class="acronym-letter primary-color">L</span>
						<span class="acronym-letter primary-color">R</span>ange and dest<span
							class="acronym-letter primary-color">I</span>nation
						<span class="acronym-letter primary-color">CA</span>lculator
					</p>
				</section>

				<section>
					<h3>Features der Applikation</h3>
					<p class="subchapter">Probleme, die sie löst.</p>
					<ul>
						<li><span class="primary-color">1.</span> Erstellt und verwaltet Fahrzeugprofile für
							Elektrofahrzeuge</li>
						<li><span class="primary-color">2.</span> Berechnet verbleibende Reichweite von
							Elektrofahrzeugen</li>
						<li><span class="primary-color">3. + 4.</span> Berechnet Ladezeiten an DC- und AC-Ladestationen
						</li>
						<li><s><span class="primary-color">5.</span> Berechnet und simmuliert eine Route</s></li>
					</ul>
				</section>

				<section>
					<h3>Features der Applikation</h3>
					<div class="horizontal-spaced-container">
						<div>
							<h5><span class="primary-color">1.</span> Fahrzeugprofil-Management</h5>
							<ul>
								<li>Erstellung, Anzeige und Löschung von Fahrzeugprofilen</li>
								<li>Konfiguration von Batteriedaten (Typ, Kapazität, Degradation, etc.)</li>
								<li>Definition von Verbrauchsprofilen (bei 50km/h, 100km/h, 130km/h)</li>
							</ul>
						</div>
						<div>
							<h5><span class="primary-color">2.</span> Reichweitenberechnung</h5>
							<ul>
								<li>Strategie-Pattern für verschiedene Berechnungsmethoden</li>
								<li>WLTP-basierte Berechnung mit "echten" Bedingungen</li>
								<li>Temperatureinflüsse</li>
								<li>Geländebedingungen</li>
								<li>etc.</li>
							</ul>
						</div>
					</div>
				</section>

				<section>
					<h3>Features der Applikation</h3>
					<div class="horizontal-spaced-container">
						<div>
							<h5><span class="primary-color">3.</span> DC (Schnelles) Laden</h5>
							<ul>
								<li>SoC-basierte Berechnungen</li>
								<li>Temperatureinflüsse beim Laden</li>
								<li>Leistungsreduktion basierend auf Batteriezustand</li>
								<li>Detaillierte Ladezeitschätzungen</li>
								<li>Berücksichtigung von Batterie-Typ</li>
							</ul>
						</div>
						<div>
							<h5><span class="primary-color">4.</span> AC (Langsames) Laden</h5>
							<ul>
								<li>Verschiedene Anschlusstypen (Haushalt, Camping, Wallbox)</li>
								<li>Berechnung von Effizienzverlusten</li>
								<li>Temperatur-Effizenzfaktoren</li>
								<li>Ladezeitprognosen</li>
							</ul>
						</div>
					</div>
				</section>


				<section>
					<h3>Starten der Applikation (1P)</h3>
					<p class="subchapter">Wie startet man die Applikation? Was für Voraussetzungen werden benötigt?
						Schritt-für-Schritt-Anleitung</p>
				</section>
				<section>
					<h3>Voraussetzungen:</h3>
					<ul>
						<li>Java 17 oder höher</li>
						<li>Maven</li>
						<li>Git</li>
					</ul>
				</section>
				<section>
					<h3>Schritte zum Starten:</h3>
					<ol>
						<li>
							Repository klonen: <span
								style="background-color: whitesmoke; padding: 2px; border-radius: 5px;"><span
									class="hljs-keyword">git</span> <span class="hljs-built_in">clone</span>
								https://github.com/mausio/ULRICA</span>
						</li>
						<li style="text-align: start;">In Projektverzeichnis wechseln: <span
								style="background-color: whitesmoke; padding: 2px; border-radius: 5px;"><span
									class="hljs-keyword">cd </span>/path/to/ULRICA</span></li>
						<li>Projekt kompilieren: <span
								style="background-color: whitesmoke; padding: 2px; border-radius: 5px;"><span
									class="hljs-keyword">mvn</span> <span class="hljs-built_in">clean</span> <span
									class="hljs-built_in">compile</span></span>
						</li>
						<li>ULRICA starten: <span
								style="background-color: whitesmoke; padding: 2px; border-radius: 5px;"><span
									class="hljs-keyword">mvn</span> <span class="hljs-built_in">exec:java</span>
								-Dexec.mainClass="org.ulrica.App"</span>
						</li>
					</ol>
				</section>
				<section>
					<h3>Alternative zum Starten:</h3>
					<ol>
						<li>JAR-Datei erstellen: <span
								style="background-color: whitesmoke; padding: 2px; border-radius: 5px;"><span
									class="hljs-keyword">mvn</span> <span class="hljs-built_in">clean</span> <span
									class="hljs-built_in">package</span></span>
							<ul>
								<li>Dieser Befehl kompiliert den Code und erstellt eine ausführbare JAR-Datei im
									Verzeichnis <span>target/</span></li>
								<li>Die JAR-Datei wird als <span
										style="background-color: whitesmoke; padding: 2px; border-radius: 5px;"
										class="primary-color">ULRICA-1.0-SNAPSHOT.jar</span> gespeichert</li>
							</ul>
						</li>
						<li>JAR-Datei ausführen: <span
								style="background-color: whitesmoke; padding: 2px; border-radius: 5px;"><span
									class="hljs-keyword">java</span> <span class="hljs-built_in">-jar</span>
								target/ULRICA-1.0-SNAPSHOT.jar</span>
							<ul>
								<li>Stellt sicher, dass Java 17 oder höher installiert ist</li>
								<li>Die JAR-Datei enthält alle notwendigen Abhängigkeiten</li>
								<li>Kann auf jedem System mit Java 17+ ausgeführt werden</li>
							</ul>
						</li>
					</ol>
				</section>

				<section>
					<h3>Technischer Überblick (2P)</h3>
					<p class="subchapter">Nennung und Erläuterung der Technologien (z.B. Java, MySQL, …), jeweils
						Begründung für den Einsatz der Technologien</p>
				</section>
				<section>
					<h3>Technologien: Überblick</h3>
					<ul>
						<li><strong>Java (JDK 17):</strong> Objektorientierte Programmiersprache</li>
						<li><strong>Maven:</strong> Build-Management-Tool</li>
						<li><strong>JSON/GSON:</strong> Datenaustauschformat und Java-Bibliothek für Persistenz</li>
						<li><strong>JUnit 4:</strong> Test-Framework für automatisierten Tests</li>
						<li><strong>JaCoCo:</strong> Code-Coverage-Tool</li>
						<li><strong>Github Workflow:</strong>CI/CD Pipeline-Tool mit Maven Build</li>
					</ul>
				</section>

				<section>
					<h3>Java (JDK 17)</h3>
					<div class="horizontal-spaced-container">
						<div>
							<h5>Vorteile:</h5>
							<ul>
								<li>Plattformunabhängigkeit durch Java Virtual Machine</li>
								<li>Starke objektorientierte Programmierung</li>
								<li>Typ-Sicherheit bei Laufzeit</li>
								<li>LongTermSupport</li>
								<li>Umfangreiche Bibliotheken verfügbar -> GSON</li>
								<li>Ideale Grundlage für Clean Architecture und Implementierung von Prinzipien</li>
							</ul>
						</div>
						<div>
							<h5>Alternativen:</h5>
							<ul>
								<li><strong>Kotlin</strong>:<br>Eleganter, aber weniger etabliert (auch nicht erlaubt)
								</li>
								<li><strong>Python</strong>: <br>Einfacher, aber weniger performant und relativ
									unbekannt für mich</li>
								<li><strong>JavaScript</strong>:<br>Mir sehr bekannt, aber schwierig
									Architekturprinzipien zu implementieren (auch nicht erlaubt)</li>
							</ul>
						</div>
					</div>
				</section>

				<section>
					<h3>Maven</h3>
					<div class="horizontal-spaced-container">
						<div>
							<h5>Vorteile</h5>
							<ul>
								<li>"Plug&Play" für Nutzer:innen</li>
								<li>Konsistente Projektstruktur</li>
								<li>Automatisiertes Abhängigkeitsmanagement</li>
								<li>Standardisierte Build-Lebenszyklen</li>
								<li>Integration mit JUnit und JaCoCo</li>
								<li>Plugin-Ökosystem für erweiterte Funktionen</li>
							</ul>
						</div>
						<div>
							<h5>Konfiguration in ULRICA</h5>
							<pre><code class="xml">&lt;dependencies&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;junit&lt;/groupId&gt;
		&lt;artifactId&gt;junit&lt;/artifactId&gt;
		&lt;version&gt;4.13.2&lt;/version&gt;
		&lt;scope&gt;test&lt;/scope&gt;
	&lt;/dependency&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;
		&lt;artifactId&gt;gson&lt;/artifactId&gt;
		&lt;version&gt;2.10.1&lt;/version&gt;  
	&lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
						</div>
					</div>
				</section>

				<section>
					<h3>JSON & GSON</h3>
					<div class="horizontal-spaced-container">
						<div>
							<h5>Vorteile</h5>
							<ul>
								<li>Leichtgewichtiges Datenformat</li>
								<li>Für Menschen lesbar und einfach zu bearbeiten</li>
								<li>Ideal für Konfigurationsdaten, e.g. Fahrzeugprofile</li>
								<li>Weit verbreitet und unterstützt</li>
								<li>GSON bietet einfache Java-Integration</li>
								<li>TypeAdapter für komplexe Datentypen</li>
							</ul>
						</div>
						<div>
							<h5>Implementierung</h5>
							<pre style="width: 500px"><code class="java">public class JsonCarProfileRepository 

implements CarProfilePersistencePortInterface { // Implementierung des Persistenz-Ports für Fahrzeugprofile
	private final Gson gson; // Gson-Instanz für JSON-Serialisierung/Deserialisierung
	private final Path filePath; // Pfad zur JSON-Datei

	public JsonCarProfileRepository() {
		this.gson = new GsonBuilder() 
			.setPrettyPrinting() // Formatiert die JSON-Ausgabe lesbar
			.registerTypeAdapterFactory( // Ermöglicht die Serialisierung von Optional-Werten
				new OptionalTypeAdapterFactory())  // Registriert eine Factory zur Unterstützung von "Optional<T>"-Typen
			.create(); // Factory: Entwurfsmuster (Design Pattern) für die Erstellung von bestimmten Objekten
		this.filePath = Paths.get(
			STORAGE_DIR, FILE_NAME); // Definiert den Speicherort der JSON-Datei
	}
	// ...
}</code></pre>
						</div>
					</div>
				</section>

				<section>
					<h3>Test-Framework: JUnit</h3>
					<div class="horizontal-spaced-container">
						<div>
							<h5>Vorteile</h5>
							<ul>
								<li>De-facto Standard für Java-Tests</li>
								<li>Umfangreiche Assertions-Bibliothek</li>
								<li>Integration mit Build-Tools und JaCoCo</li>
								<li>Test-getriebene Entwicklung (TDD) wird unterstützt</li>
							</ul>
						</div>
						<div>
						</div>
					</div>
				</section>

				<section>
					<h3>Code-Coverage: JaCoCo</h3>
					<p class="subchapter">Fokus auf qualitative Tests u. kritische Komponenten, statt bloßer Maximierung
					</p>
					<div class="horizontal-spaced-container">
						<div>
							<h5>Vorteile</h5>
							<ul>
								<li>Detaillierte Abdeckungsmetriken</li>
								<li>Integration mit Maven und CI/CD</li>
								<li>Identifikation von ungetesteten Codebereichen</li>
								<li>Visualisierung der Testabdeckung</li>
								<li>Qualitätssicherung während der Entwicklung</li>
								<li>Motivation zur Erhöhung der Testabdeckung</li>
							</ul>
						</div>
						<div>
							<h5>Ergebnisse</h5>
							<ul>
								<li>Gesamtabdeckung: 47%</li>
								<li>Domain Layer: 68%</li>
								<li>Application Layer: 53%</li>
								<li>Presentation Layer: 42%</li>
								<li>Infrastructure Layer: 36%</li>
								<li>Core-Komponenten: 75%</li>
							</ul>

						</div>
					</div>
				</section>

				<section>
					<h3>Github Workflow</h3>
					<p class="subchapter">Kontinuierliche Integration und automatische Qualitätssicherung</p>
					<div class="horizontal-spaced-container">
						<div>
							<h5>Vorteile</h5>
							<ul>
								<li>Automatisierte Builds bei jedem Commit</li>
								<li>Kontinuierliche Ausführung der Tests</li>
								<li>Automatische Code-Coverage-Analyse</li>
								<li>Codequalitätsmessung mit CLOC</li>
								<li>E-Mail-Benachrichtigungen über Build-Status</li>
								<li>Früherkennung von Fehlern und Qualitätsproblemen</li>
							</ul>
						</div>
						<div>
							<h5>Implementierung</h5>
							<pre style="width: 400px"><code class="yaml">name: Java CI with Maven

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3
    
    - name: Set up JDK 17
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'temurin'
    
    - name: Build, test and check coverage
      run: mvn -B verify
    
    - name: Install CLOC
      run: sudo apt-get install -y cloc

    - name: Count Java lines of code
      run: cloc --include-lang=Java ./src/main/java/org/ulrica

    # E-Mail-Benachrichtigung über Ergebnisse
    - name: Send Email with Results
      uses: dawidd6/action-send-mail@v3
      # ...</code></pre>
						</div>
					</div>
				</section>

				<section>
					<h3>Kleines Add-On: Mails</h3>
					<div style="display: flex; flex-direction: row; justify-content: space-evenly;">
						<img src="./assets/imgs/Screenshot 2025-04-27 at 12.41.23.jpeg"
							style="height: 580px; margin: 0; border-radius: 20px;" />
						<div style="display: flex; flex-direction: column; justify-content: space-between;">
							<img src="./assets/imgs/IMG_1931.PNG"
								style="height: 280px; margin: 0; border-radius: 20px;" />
							<img src="./assets/imgs/IMG_1932.PNG"
								style="height: 280px; margin: 0; border-radius: 20px;" />
						</div>
					</div>
				</section>

				<!-- <section>
					<h3>Clean Architecture</h3>
					<div class="horizontal-spaced-container">
						<div>
							<h5>Vorteile für ULRICA</h5>
							<ul>
								<li>Separation of Concerns</li>
								<li>Unabhängige Domänenlogik</li>
								<li>Dependency Inversion Principle</li>
								<li>Testbarkeit durch lose Kopplung</li>
								<li>Austauschbarkeit von Infrastruktur</li>
								<li>Strukturierte Codebasis</li>
							</ul>
						</div>
						<div>
							<h5>Schichten in ULRICA</h5>
							<ul>
								<li><strong>Domain:</strong> 3 Packages, 23 Klassen</li>
								<li><strong>Application:</strong> 3 Packages, 26 Klassen</li>
								<li><strong>Infrastructure:</strong> 3 Packages, 7 Klassen</li>
								<li><strong>Presentation:</strong> 3 Packages, 16 Klassen</li>
							</ul>
							<p>Details in Kapitel 2: Softwarearchitektur</p>
						</div>
					</div>
				</section>

				<section>
					<h3>Architekturübersicht</h3>
					<img src="./assets/architecture.png" alt="ULRICA Architecture" style="max-height: 500px;">
					<p>Clean Architecture mit klarer Trennung der Schichten</p>
				</section> -->
			</section>
			<!-- Kapitel 2 -->
			<section alt="Kapitel 2">
				<section>
					<h2 class="chapter-title">Kapitel 2: <br /> Softwarearchitektur (8P)</h2>
				</section>

				<section>
					<h3 class="subchapter">Inhalt des Kapitels</h3>
					<div class="horizontal-spaced-container"
						style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
						<div>
							<h6>1. Gewählte Architektur (4P)</h6>
							<ul>
								<li>Clean Architecture</li>
								<li>Architekturschichten</li>
								<li>Analyse und Begründung</li>
								<li>UML der wichtigsten Klassen</li>
							</ul>
						</div>
						<div>
							<h6>2. Domain Code (1P)</h6>
							<ul>
								<li>Definition von Domain Code</li>
								<li>Code-Beispiel aus ULRICA</li>
								<li>Analyse der Domain-Schicht</li>
							</ul>
						</div>
						<div>
							<h6>3. Analyse der Dependency Rule (3P)</h6>
							<ul>
								<li>Positives Beispiel</li>
								<li>Negatives Beispiel</li>
								<li>UML der Abhängigkeiten</li>
								<li>Lösungsansätze</li>
							</ul>
						</div>
						<div>
						</div>
					</div>
				</section>


				<section>
					<h3>Gewählte Architektur (4P)</h3>
					<p class="subchapter">In der Vorlesung wurden Softwarearchitekturen vorgestellt. Welche Architektur
						wurde davon umgesetzt? Analyse und Begründung inkl. UML der wichtigsten Klassen, sowie
						Einordnung dieser Klassen in die gewählte Architektur</p>
				</section>

				<section>
					<h3>Clean Architecture</h3>
					<div class="horizontal-spaced-container">
						<ul>
							<li><b>Application Layer:</b> <br /> Implementiert Use Cases (Interfaces) über Interaktoren
								und Ports für Kommunikation</li>
							<li><b>Domain Layer:</b> <br /> Enthält die Entität, Value Objects, Services (z.B.
								Kalkulation) und Application State</li>
							<li><b>Infrastructure Layer:</b> <br /> Konkrete Implementierungen von Repositories und
								Adaptern und Utils
							</li>
							<li><b>Presentation Layer:</b> <br /> Steuert die Benutzerinteraktion über Controller und
								Views und Utils</li>
						</ul>
						<pre
							style="overflow: hidden; height: 580px; width: 700px; position: relative; margin-left: 50px; bottom: 20px; right: 20px;"><code class="">➜  ulrica git:(main) ✗ tree -d
			.
			├── application
			│   ├── port
			│   │   ├── in
			│   │   └── out
			│   ├── service
			│   └── usecase
			├── domain
			│   ├── entity
			│   ├── service
			│   └── valueobject
			├── infrastructure
			│   ├── adapter
			│   ├── persistence
			│   └── util
			└── presentation
				├── controller
				├── util
				└── view

			19 directories
	</code></pre>
					</div>
				</section>

				<section>
					<h3>Clean Architecture: UML</h3>
					<div style="display: flex; flex-direction: column;" class="horizontal-spaced-container">
						<div>
							<ul>
								<li>Domänenlogik ist unabhängig von externen Frameworks/Bibliotheken</li>
								<li>Application Layer enthält anwendungsspezifische Regeln</li>
								<li>Ports definieren Schnittstellen zwischen Schichten</li>
								<li>Adapters verbinden externe Systeme mit inneren Schichten</li>
								<li>Abhängigkeiten zeigen immer nach innen</li>
							</ul>
						</div>
						<img style="overflow: scroll; scale: 1.1; justify-self: center; align-self: center;"
							src="./assets/UMLs-imgs/clean_arch.svg" alt="ULRICA Clean Architecture" class="uml-image">
					</div>
				</section>

				<section>
					<div style="display: flex; flex-direction: column; justify-content: space-around; gap: 0;">
						<img style="margin: 0; padding: 0;" src="assets/UMLs-imgs/2-1-1.png">
						<img style="margin: 0; padding: 0;" src="assets/UMLs-imgs/2-1-2.png">
						<img style="margin: 0; padding: 0;" src="assets/UMLs-imgs/2-1-3.png">
					</div>
				</section>

				<section>
					<h3>
						Clean Architecture: <br /> Analyse u. Begründung
					</h3>
				</section>

				<section>
					<h3>Domain Layer</h3>
					<p class="subchapter">Der Domain Layer ist das <strong>Herzstück der Clean Architecture</strong> und
						enthält die gesamte Geschäftslogik ohne externe Abhängigkeiten</p>
					<ul>
						<li><strong>CarProfile</strong> (Entity): Kernentität, die ein Car mit seinen Eigenschaften
							repräsentiert</li>
						<li><strong>BatteryProfile</strong> (Value Object): Immutable Objekt, das die
							Batterieeigenschaften eines Fahrzeugs beschreibt</li>
						<li><strong>ConsumptionProfile</strong> (Value Object): Kapselt Verbrauchsdaten und
							Verbrauchfaktoren des Fahrzeugs ab</li>
						<li><strong>RangeCalculatorService</strong> (Service): Berechnet die Reichweite basierend auf
							verschiedenen Strategien</li>
						<li><strong>RangeCalculationStrategyInterface</strong>: Definiert die Schnittstelle für
							verschiedene Berechnungsalgorithmen</li>
					</ul>
				</section>

				<section>
					<h3>Application Layer</h3>
					<p class="subchapter">Der Application Layer implementiert <strong>Use Cases</strong> und definiert
						<strong>Ports</strong>. Die Klassen orchestrieren Domänenobjekte, ohne direkten Zugriff auf die
						Infrastruktur, was dadurch die <strong>Dependency Rule</strong> einhäl
					</p>
					<ul>
						<li><strong>CalculateRangeUseCaseInterface</strong> (Port): Definiert die Schnittstelle für den
							Anwendungsfall der Reichweitenberechnung</li>
						<li><strong>CalculateRangeInteractor</strong> (Use Case): Implementiert die Geschäftslogik für
							die Reichweitenberechnung</li>
						<li><strong>CarProfilePersistencePortInterface</strong> (Port): Abstrahiert die Datenpersistenz
							für Fahrzeugprofile</li>
						<li><strong>NavigationUseCase</strong> (Use Case): Steuert die Navigationslogik und
							Routenplanung</li>
					</ul>
				</section>

				<section>
					<h3>Infrastructure Layer</h3>
					<p class="subchapter">Der Infrastructure Layer implementiert <strong>konkrete Adapter</strong> für
						externe Systeme. Diese Klassen sind austauschbar ohne Änderungen an inneren Schichten, was
						wichtig für e.g. <strong>OCP</strong> wichtig ist.</p>
					<ul>
						<li><strong>JsonCarProfileRepository</strong>: Implementiert die Persistenz von Fahrzeugprofilen
							als JSON-Dateien</li>
						<li><strong>ConsoleUserInputAdapter</strong>: Verarbeitet Benutzereingaben über die Konsole</li>
						<li><strong>ConsoleUserOutputAdapter</strong>: Zeigt Ausgaben und Ergebnisse in der Konsole an
						</li>
						<li><strong>ValidationUtils</strong>: Hilfsmethoden zur Validierung von Eingabedaten</li>
					</ul>
				</section>

				<section>
					<h3>Presentation Layer</h3>
					<p class="subchapter">Der Presentation Layer kapselt die Benutzerinteraktion. Diese Klassen
						kommunizieren nur über definierte Schnittstellen mit inneren Schichten, was eine <strong>klare
							Trennung von UI und Geschäftslogik</strong> gewährleistet</p>
					<ul>
						<li><strong>ApplicationControllerWithActionMenu</strong>: Hauptcontroller, der die verschiedenen
							Aktionen der Anwendung steuert</li>
						<li><strong>RangeCalculationController</strong>: Spezialisierter Controller für die
							Reichweitenberechnung</li>
						<li><strong>ActionMenuView</strong>: Stellt das Hauptmenü der Anwendung dar</li>
						<li><strong>CarProfileView</strong>: Visualisiert die Fahrzeugprofile und deren Details</li>
					</ul>
				</section>

				<section>
					<h3>Domain Code (1P)</h3>
					<p class="subchapter">Kurze Erläuterung in eigenen Worten, was Domain Code ist – 1 Beispiel im Code
						zeigen, das bisher noch nicht gezeigt wurde.</p>
					<ul>
						<li>Bildet die Fachlogik der Domäne (Geschäftsregeln) ab</li>
						<li>Modelliert Prozesse, Regeln und Datenstrukturen</li>
						<li>Unabhängig von externen Systemen (Datenbank, UI, Frameworks,...)</li>
						<li>Bleibt Stabil bei Änderung (an Technologien)</li>
						<li>Domäne orientiert (Entity, Valueobject, Aggregate)</li>
						<li>Bleibt fachlich und ist frei von Presentation- und Persistenzlogik (siehe Domainlayer)</li>
					</ul>
				</section>

				<section>
					<h3>Beispiel Domain Code: RangeCalculatorService</h3>
					<pre><code class="java" >public class RangeCalculatorService { // Reichweitenberechnung innerhalb der Domäne
	private final List<RangeCalculationStrategyInterface> strategies; // Hält verschiedene fachliche Berechnungsstrategien
	private RangeCalculationStrategyInterface defaultStrategy; // Definiert, welche Strategie standardmäßig verwendet wird

	public RangeCalculatorService() { // wird direkt mit zwei vordefinierten Strategien gestartet
		this.strategies = new ArrayList<>();
		
		WltpBasedRangeCalculationStrategy wltpStrategy = new WltpBasedRangeCalculationStrategy(); // Strategie basierend auf WLTP-Standard
		ConsumptionBasedRangeCalculationStrategy consumptionStrategy = new ConsumptionBasedRangeCalculationStrategy(); // Strategie basierend auf realem Verbrauch

		this.strategies.add(wltpStrategy); // Beide Strategien werden in die Domain-intern verfügbare Liste aufgenommen
		this.strategies.add(consumptionStrategy);

		this.defaultStrategy = consumptionStrategy; // Standardmäßig wird die Verbrauchsstrategie für Berechnungen genutzt
	}
	
	public void addStrategy(RangeCalculationStrategyInterface strategy) { // neue Strategien werden fachlich verfügbar gemacht
		Objects.requireNonNull(strategy, "Strategy cannot be null"); // Eine Strategie muss immer gültig sein
		strategies.add(strategy); // Neue Strategie wird der Liste hinzugefügt
	}
	
	public void setDefaultStrategy(RangeCalculationStrategyInterface strategy) { // Hier kann eine andere Standardstrategie gesetzt werden
		Objects.requireNonNull(strategy, "Strategy cannot be null"); // Die Strategie darf nicht null sein
		if (!strategies.contains(strategy)) { // Falls sie noch nicht bekannt ist, wird sie aufgenommen
			strategies.add(strategy);
		}
		this.defaultStrategy = strategy; // Danach wird sie als neue Standardstrategie gespeichert
	}
	
	public List<RangeCalculationStrategyInterface> getAvailableStrategies() { // Gibt alle aktuell verfügbaren Strategien der Domäne zurück
		return new ArrayList<>(strategies); // Liefert eine Kopie, damit die interne Liste geschützt bleibt
	}
	
	public RangeCalculationStrategyInterface getDefaultStrategy() { // Gibt die aktuelle Standardstrategie zurück
		return defaultStrategy;
	}
	
	public RangeResult calculateRange(CarProfile carProfile, RangeParameters parameters) { // Berechnet die Reichweite basierend auf dem Fahrzeugprofil und Standardstrategie
		Objects.requireNonNull(carProfile, "Car profile cannot be null"); // Ein Fahrzeugprofil ist zwingend notwendig
		Objects.requireNonNull(parameters, "Range parameters cannot be null"); // Auch die Parameter müssen angegeben sein
		
		return defaultStrategy.calculateRange(carProfile, parameters); // Übergibt die Berechnung an die Standardstrategie
	}
	
	public RangeResult calculateRangeWithStrategy(CarProfile carProfile, RangeParameters parameters, RangeCalculationStrategyInterface strategy) { // Alternativ kann eine konkrete Strategie verwendet werden
		Objects.requireNonNull(carProfile, "Car profile cannot be null"); // Fahrzeugprofil darf nicht fehlen
		Objects.requireNonNull(parameters, "Range parameters cannot be null"); // Parameter dürfen nicht fehlen
		Objects.requireNonNull(strategy, "Strategy cannot be null"); // Auch die Strategie muss vorhanden sein
		
		return strategy.calculateRange(carProfile, parameters); // Übergibt die Berechnung an die angegebene Strategie
	}
}</code></pre>
				</section>

				<section>
					<h3>Analyse des Domain Codes</h3>
					<ul>
						<li>Service kapselt reine Fachlogik zur Reichweitenberechnung</li>
						<li>Strategien sind fachliche Varianten zur Reichweitenermittlung</li>
						<li>Keine technische Infrastruktur wie DB, API oder UI enthalten</li>
						<li>Arbeitet nur mit Domain-spezifischen Typen (CarProfile, RangeParameters)</li>
						<li>Erweiterbarkeit durch neue Strategien innerhalb der Domäne möglich</li>
						<li>Berechnungen (calculateRange) folgen direkt fachlichen Regeln</li>
					</ul>
				</section>

				<section>
					<h3>Analyse der Dependency Rule (3P)</h3>
					<p class="subchapter">In der Vorlesung wurde im Rahmen der 'Clean Architecture' die s.g. Dependency
						Rule vorgestellt. Je 1 Klasse zeigen, die die Dependency Rule einhält und 1 Klasse, die die
						Dependency Rule verletzt; jeweils UML (mind. die betreffende Klasse inkl. der Klassen, die von
						ihr abhängen bzw. von der sie abhängt) und Analyse der Abhängigkeiten in beide Richtungen (d.h.,
						von wem hängt die Klasse ab und wer hängt von der Klasse ab) in Bezug auf die Dependency Rule
					</p>
				</section>



				<section>
					<h3>Analyse der Dependency Rule </h3>
					<ul>
						<li>Die Abhängigkeiten zeigen nur zum Zentrum der Architektur (größtenteils)</li>
						<li>Innere Schichten (Domain) dürfen nichts über äußere Schichten wissen</li>
						<li>Äußere Schichten (Infrastruktur) dürfen von inneren abhängen</li>
						<li>Die Abstraktionen (Interfaces) gehören zur inneren Schicht</li>
						<li>Die Implementierungen gehören zur äußeren Schicht</li>
					</ul>
					<img src="assets/UMLs-imgs/Kapitel_2-Aufgabe_3.png" alt="Dependency Rule UML" class="uml-image">
				</section>

				<section>
					<h3>Positives Beispiel: CalculateRangeInteractor</h3>
					<pre><code class="java">public class CalculateRangeInteractor implements CalculateRangeUseCaseInterface {
					
					private final RangeCalculatorService rangeCalculatorService;
					private final RangeCalculationOutputPortInterface outputPort;
					private final ProfileSelectionService profileSelectionService;
					
					public CalculateRangeInteractor(
							RangeCalculatorService rangeCalculatorService,
							RangeCalculationOutputPortInterface outputPort,
							ProfileSelectionService profileSelectionService) {
						this.rangeCalculatorService = Objects.requireNonNull(rangeCalculatorService);
						this.outputPort = Objects.requireNonNull(outputPort);
						this.profileSelectionService = Objects.requireNonNull(profileSelectionService);
					}
					
					@Override
					public void calculateRange(CalculateRangeCommand command) {
						CarProfile profile = profileSelectionService.getSelectedProfile();
						// Weitere Implementierung...
						
						RangeResult result = rangeCalculatorService.calculateRange(profile, parameters);
						outputPort.displayRangeResult(result);
					}
				}</code></pre>
				</section>

				<section>
					<h3>UML: Positives Beispiel</h3>
					<img src="assets/UMLs-imgs/Kapitel_2-Aufgabe_3-Dependency_Rule_Positiv.png"
						alt="Positive Dependency Rule Example UML" class="uml-image">
				</section>

				<section>
					<h3>Analyse des positiven Beispiels</h3>
					<ul>
						<li>Implementiert ein Interface aus der Application-Schicht</li>
						<li>Abhängigkeiten werden über Konstruktor-Injection bereitgestellt</li>
						<li>Abhängigkeiten sind alle Interfaces oder Domain-Services</li>
						<li>Keine Abhängigkeit zu konkreten Implementierungen der äußeren Schichten</li>
						<li>Ausgabe erfolgt über ein Port-Interface (RangeCalculationOutputPortInterface)</li>
						<li>Strikte Validierung mit Objects.requireNonNull()</li>
					</ul>
				</section>

				<section>
					<h3>Negatives Beispiel: JsonCarProfileRepository</h3>
					<pre><code class="java">public class JsonCarProfileRepository implements CarProfilePersistencePortInterface {
					private static final String STORAGE_DIR = "data";
					private static final String FILE_NAME = "car_profiles.json";
					private final Gson gson;
					private final Path filePath;
				
					public JsonCarProfileRepository() {
						this.gson = new GsonBuilder()
								.setPrettyPrinting()
								.registerTypeAdapterFactory(new OptionalTypeAdapterFactory())
								.create();
						this.filePath = Paths.get(STORAGE_DIR, FILE_NAME);
						ensureStorageDirectoryExists();
					}
					
					@Override
					public List<CarProfile> findAll() {
						try (FileReader reader = new FileReader(filePath.toFile())) {
							Type listType = new TypeToken<List<CarProfile>>() {}.getType();
							List<CarProfile> profiles = gson.fromJson(reader, listType);
							return profiles != null ? profiles : new ArrayList<>();
						} catch (IOException e) {
							throw new RuntimeException("Failed to read car profiles", e);
						}
					}
				}</code></pre>
				</section>

				<section>
					<h3>UML: Negatives Beispiel</h3>
					<img src="assets/UMLs-imgs/Kapitel_2-Aufgabe_3-Dependency_Rule_Negative.png"
						alt="Negative Dependency Rule Example UML" class="uml-image">
				</section>

				<section>
					<h3>Analyse des negativen Beispiels</h3>
					<div class="horizontal-spaced-container">
						<div>
							<p>Verstöße gegen die Dependency Rule:</p>
							<ul>
								<li>Direkte Abhängigkeit zu externen Bibliotheken (Gson)</li>
								<li>Direkter Zugriff auf das Dateisystem (java.io, java.nio)</li>
								<li>Hartcodierte Pfade (STORAGE_DIR, FILE_NAME)</li>
								<li>Ausnahmebehandlung mit generischen Exceptions</li>
								<li>Direkte Implementierung der Dateioperationen</li>
							</ul>
						</div>
						<div>
							<p>Verbesserungsvorschlag:</p>
							<ul>
								<li>Einführung eines FileStoragePortInterface</li>
								<li>Auslagerung der JSON-Serialisierung</li>
								<li>Konfigurierbare Pfade (z.B. über Umgebungsvariablen)</li>
								<li>Fachliche Exceptions wie ProfileNotFoundException</li>
								<li>Strikte Trennung von Persistenz und Domänenmodell</li>
							</ul>
						</div>
					</div>
				</section>
			</section>


			<!-- <section data-include="slides/kapitel-3.html"></section>
			<section data-include="slides/kapitel-4.html"></section>
			<section data-include="slides/kapitel-5.html"></section> -->

			<!-- Kapitel 5 -->
			<section alt="Kapitel 5">
				<section>
					<h2 class="chapter-title">Kapitel 5: Unit Tests (8P)</h2>
				</section>

				<section>
					<h3>10 Unit Tests (2p)</h3>
					<p class="subchapter">Zeigen und Beschreiben von 10 Unit-Tests und Beschreibung, was getestet wird</p>
				</section>
				
				<section>
					<h3>Unit Tests</h3>
					<div class="horizontal-spaced-container">
						<div>
							<h5>Test-Strategie</h5>
							<ul>
								<li>Fokus auf Domain-Logik als kritischen Kern</li>
								<li>106 automatisierte Tests (JUnit)</li>
								<li>47% Gesamtabdeckung (JaCoCo)</li>
								<li>Spezielle Tests für Randfälle und Fehlerbedingungen</li>
								<li>Mocks für externe Abhängigkeiten</li>
							</ul>
						</div>
						<div>
							<h5>Testarten in ULRICA</h5>
							<ul>
								<li>Unit-Tests für isolierte Klassen</li>
								<li>Integrationstests für Komponenteninteraktion</li>
								<li>Parametrisierte Tests für Datenvalidierung</li>
								<li>Exception-Tests für Fehlerszenarien</li>
								<li>Stresstest für Berechnung mit großen Datenmengen</li>
							</ul>
						</div>
					</div>
				</section>
				
				<section>
					<h3>Test #1: DC Charging Calculator</h3>
					<pre><code class="java">@Test
				public void testCalculateChargingTime_WithChargingCurve() {
					// Testwerte definieren
					double startingSoc = 20.0;
					double targetSoc = 80.0;
					double maxStationPower = 250.0;
					double ambientTemperature = 25.0;
					
					// Ladekurve erstellen
					Map<Double, Double> curvePoints = new HashMap<>();
					curvePoints.put(0.0, 150.0);   // 0% SOC -> 150 kW
					curvePoints.put(20.0, 180.0);  // 20% SOC -> 180 kW
					curvePoints.put(50.0, 100.0);  // 50% SOC -> 100 kW
					curvePoints.put(80.0, 50.0);   // 80% SOC -> 50 kW
					curvePoints.put(100.0, 10.0);  // 100% SOC -> 10 kW
					ChargingCurve chargingCurve = new ChargingCurve(curvePoints);
					
					// Car mit Ladekurve erstellen
					CarProfile carWithCurve = new CarProfile.Builder()
						.id("test-id-curve")
						.name("Test EV with Curve")
						.manufacturer("Test Manufacturer")
						.model("Test Model")
						.year(2023)
						.hasHeatPump(true)
						.wltpRangeKm(500)
						.maxDcPowerKw(250.0)
						.maxAcPowerKw(11.0)
						.batteryProfile(batteryProfile)
						.consumptionProfile(consumptionProfile)
						.chargingCurve(chargingCurve)
						.build();
					
					// Service-Methode aufrufen
					DcChargingResult result = calculator.calculateChargingTime(
						carWithCurve, 
						startingSoc, 
						targetSoc, 
						maxStationPower, 
						ambientTemperature
					);
					
					// Validierung der berechneten Werte
					double expectedEnergyToAdd = batteryProfile.getRemainingCapacityKwh() * 0.6;
					assertEquals(expectedEnergyToAdd, result.getEnergyToAddKwh(), 0.01);
					assertTrue(result.getChargingTimeHours() > 0);
					assertTrue(result.getEffectivePowerKw() > 0);
				}</code></pre>
					<p>Testet komplexe Ladeberechnungen mit dynamischer Ladekurve und verschiedenen SOC-Bereichen</p>
				</section>
				
				<section>
					<h3>Test #2: Range Calculator Service - Strategy Pattern</h3>
					<pre><code class="java">@Test
				public void testAddStrategy() {
					// Ausgangssituation dokumentieren
					int initialCount = rangeCalculatorService.getAvailableStrategies().size();
					
					// Mock-Strategie erstellen 
					RangeCalculationStrategyInterface mockStrategy = new RangeCalculationStrategyInterface() {
						@Override
						public RangeResult calculateRange(CarProfile carProfile, RangeParameters params) {
							return new RangeResult(
								300.0, 
								20.0,  
								"No weather impact",
								"No terrain impact",
								"No environment impact",
								"Battery in good condition"
							);
						}
						
						@Override
						public String getName() {
							return "MockStrategy";
						}
						
						@Override
						public String getDescription() {
							return "A mock strategy for testing";
						}
					};
					
					// Strategie hinzufügen
					rangeCalculatorService.addStrategy(mockStrategy);
					
					// Validierung: Strategien-Anzahl ist um 1 erhöht
					assertEquals(initialCount + 1, rangeCalculatorService.getAvailableStrategies().size());
				}</code></pre>
					<p>Testet die dynamische Erweiterbarkeit durch das Strategy-Pattern im RangeCalculatorService</p>
				</section>
				
				<section>
					<h3>Test #3: ChargingCurve Interpolation</h3>
					<pre><code class="java">@Test
				public void testGetChargingPowerAt_Interpolation() {
					// Testdaten mit drei Kurven-Punkten erstellen
					Map<Double, Double> curvePoints = new HashMap<>();
					curvePoints.put(0.0, 150.0);    // 0% -> 150 kW
					curvePoints.put(50.0, 100.0);   // 50% -> 100 kW
					curvePoints.put(100.0, 10.0);   // 100% -> 10 kW
					ChargingCurve chargingCurve = new ChargingCurve(curvePoints);
					
					// Test der linearen Interpolation zwischen Punkten
					
					// Test Punkt zwischen 0% und 50%
					assertEquals(125.0, chargingCurve.getChargingPowerAt(25.0), 0.001);
					
					// Test Punkt zwischen 50% und 100%
					assertEquals(55.0, chargingCurve.getChargingPowerAt(75.0), 0.001);
				}</code></pre>
					<p>Testet die korrekte lineare Interpolation bei der Ladekurve zwischen definierten Punkten</p>
				</section>
				
				<section>
					<h3>Test #4: ExecuteAction - Komplexe UI-Interaktion</h3>
					<pre><code class="java">@Test
				public void testExecuteAction_NoProfileSelected() {
					// Profil-Auswahl leeren
					profileSelectionService.clearSelection();
					
					// Action ausführen (DC-Ladung starten)
					boolean result = executeActionInteractor.executeAction(1);
					
					// Validieren des erwarteten Verhaltens
					assertFalse(result);
					assertEquals(1, actionResultView.getErrorCount());
					assertEquals(0, actionResultView.getSuccessCount());
					assertEquals(0, dcChargingController.getProcessCallCount());
					assertEquals(0, acChargingController.getProcessCallCount());
					assertEquals(0, rangeCalculationController.getProcessCallCount());
					assertTrue(actionResultView.lastErrorContains("No car profile selected"));
				}</code></pre>
					<p>Testet das komplexe Zusammenspiel zwischen UI-Controller, Views und Geschäftslogik mit Mock-Objekten</p>
				</section>
				
				<section>
					<h3>Test #5: DC Charging - Temperatureinfluss</h3>
					<pre><code class="java">@Test
				public void testCalculateChargingTime_LowTemperature() {
					// Kalte Umgebungstemperatur als Testbedingung
					double startingSoc = 20.0;
					double targetSoc = 60.0;
					double maxStationPower = 250.0;
					double ambientTemperature = -10.0; // Sehr kalter Tag
					
					// Service-Methode mit Testwerten aufrufen
					DcChargingResult result = calculator.calculateChargingTime(
						mockCarProfile, 
						startingSoc, 
						targetSoc, 
						maxStationPower, 
						ambientTemperature
					);
					
					// Temperatureinfluss auf Batterie validieren
					double expectedBatteryTemp = ambientTemperature + 5.9;
					assertEquals(expectedBatteryTemp, result.getEndTemperatureCelsius(), 0.01);
					
					// Leistungsreduktion aufgrund der Temperatur validieren
					assertTrue("Bei kalter Temperatur sollte Ladeleistung reduziert sein", 
						result.getEffectivePowerKw() < maxStationPower);
					assertTrue("Bei kalten Temperaturen sollte Ladezeit länger sein", 
						result.getChargingTimeHours() > 0.5);
				}</code></pre>
					<p>Testet die realistische Simulation von Temperatureinflüssen auf das Ladeverhalten</p>
				</section>
				
				<section>
					<h3>Test #6: Validierung der Eingabeparameter</h3>
					<pre><code class="java">@Test
				public void testValidateInputParameters_InvalidTargetSoc() {
					// Ungültiger SOC-Wert (über 100%)
					double startingSoc = 20.0;
					double invalidTargetSoc = 110.0;
					
					// Service-Methode aufrufen mit Erwartung auf Exception
					assertThrows(IllegalArgumentException.class, () -> {
						calculator.calculateChargingTime(
							mockCarProfile, 
							startingSoc, 
							invalidTargetSoc, 
							250.0, 
							25.0
						);
					});
				}
				
				@Test
				public void testValidateInputParameters_TargetLessThanStarting() {
					// Fehlerhafter Case: Ziel-SOC niedriger als Start-SOC
					double startingSoc = 80.0;
					double targetSoc = 70.0; 
					
					// Validierung dass die API korrekterweise eine Exception wirft
					assertThrows(IllegalArgumentException.class, () -> {
						calculator.calculateChargingTime(
							mockCarProfile, 
							startingSoc, 
							targetSoc, 
							250.0, 
							25.0
						);
					});
				}</code></pre>
					<p>Testet die robuste Validierung von Eingabeparametern in der Domain-Logik</p>
				</section>
				
				<section>
					<h3>Test #7: DI mit Mock-Objekten</h3>
					<pre><code class="java">@Test
				public void testExecuteAction_DcCharging() {
					// Setup mit Mock-Objekten und Dependency Injection
					profileSelectionService.selectProfile(testProfile);
					dcChargingController.setProcessDcChargingResult(true);
					
					// Aktion ausführen
					boolean result = executeActionInteractor.executeAction(1);
					
					// Validieren des Verhaltens und der Interaktionen
					assertTrue(result);
					assertEquals(0, actionResultView.getErrorCount());
					assertEquals(1, dcChargingController.getProcessCallCount());
					assertEquals(0, acChargingController.getProcessCallCount());
					assertEquals(0, rangeCalculationController.getProcessCallCount());
				}</code></pre>
					<p>Testet die korrekte Implementierung von Dependency Injection und das Zusammenspiel von Komponenten</p>
				</section>
				
				<section>
					<h3>Test #8: ChargingCurve - Robustheit</h3>
					<pre><code class="java">@Test
				public void testInvalidConstructorArguments() {
					// Test mit null-Wert
					assertThrows(IllegalArgumentException.class, () -> {
						new ChargingCurve(null);
					});
					
					// Test mit leerer Map
					assertThrows(IllegalArgumentException.class, () -> {
						new ChargingCurve(new HashMap<>());
					});
					
					// Test mit fehlenden Schlüsselpunkten
					Map<Double, Double> incompletePoints = new HashMap<>();
					incompletePoints.put(50.0, 100.0);
					assertThrows(IllegalArgumentException.class, () -> {
						new ChargingCurve(incompletePoints);
					});
				}</code></pre>
					<p>Testet die Robustheit und Fehlerbehandlung bei ungültigen Eingabedaten</p>
				</section>
				
				<section>
					<h3>Test #9: ProfileSelectionService - Statusverwaltung</h3>
					<pre><code class="java">@Test
				public void testProfileSelection() {
					// Initial kein Profil ausgewählt
					assertFalse(profileSelectionService.hasSelectedProfile());
					
					// Profil auswählen
					CarProfile testProfile = new CarProfile.Builder()
						.id("test-id")
						.name("Test Car")
						.build();
					profileSelectionService.selectProfile(testProfile);
					
					// Status und ausgewähltes Profil validieren
					assertTrue(profileSelectionService.hasSelectedProfile());
					assertEquals(testProfile, profileSelectionService.getSelectedProfile());
					
					// Auswahl zurücksetzen
					profileSelectionService.clearSelection();
					
					// Validieren dass kein Profil mehr ausgewählt ist
					assertFalse(profileSelectionService.hasSelectedProfile());
					assertThrows(IllegalStateException.class, () -> {
						profileSelectionService.getSelectedProfile();
					});
				}</code></pre>
					<p>Testet die korrekte Statusverwaltung und Fehlerfälle im ProfileSelectionService</p>
				</section>
				
				<section>
					<h3>Test #10: Validierung von Value Objects</h3>
					<pre><code class="java">@Test
				public void testValueObjectValidation() {
					// Gültige Werte
					BatteryProfile validProfile = new BatteryProfile(
						BatteryType.LFP, 
						80.0,         // Kapazität in kWh
						5.0,          // Degradation in Prozent
						150.0,        // Max DC Ladeleistung
						11.0          // Max AC Ladeleistung
					);
					
					// Eigenschaften validieren
					assertEquals(BatteryType.LFP, validProfile.getType());
					assertEquals(80.0, validProfile.getCapacityKwh(), 0.001);
					assertEquals(5.0, validProfile.getDegradationPercent(), 0.001);
					assertEquals(76.0, validProfile.getRemainingCapacityKwh(), 0.001); // 80 - 5%
					
					// Ungültige Werte
					assertThrows(IllegalArgumentException.class, () -> {
						new BatteryProfile(
							BatteryType.LFP, 
							-10.0,      // Negative Kapazität
							5.0, 
							150.0, 
							11.0
						);
					});
					
					assertThrows(IllegalArgumentException.class, () -> {
						new BatteryProfile(
							BatteryType.LFP, 
							80.0, 
							110.0,      // Degradation > 100%
							150.0, 
							11.0
						);
					});
				}</code></pre>
					<p>Testet die Validierung und Fehlerbehandlung bei der Erstellung von Value Objects</p>
				</section>
				
				<section>
					<h3>Mock-Objekte in Tests (3P)</h3>
					<div class="horizontal-spaced-container">
						<div>
							<h5>Warum Mocks in ULRICA?</h5>
							<ul>
								<li>Isolierung der Testbedingungen</li>
								<li>Simulation von schwer erzeugbaren Zuständen</li>
								<li>Schnellere Testausführung ohne externe Abhängigkeiten</li>
								<li>Vermeidung von Seiteneffekten</li>
								<li>Validierung von Interaktionen zwischen Komponenten</li>
							</ul>
						</div>
						<div>
							<h5>Mock-Implementierungen</h5>
							<ul>
								<li>Handgeschriebene Mocks für einfache Fälle</li>
								<li>Interface-basierte Mocks für Ports und Adapters</li>
								<li>Simulierte externe Services</li>
								<li>Mock-Repositories für In-Memory-Testing</li>
								<li>Test-spezifische OutputPorts für Validierung</li>
							</ul>
						</div>
					</div>
				</section>
				
				<section>
					<h3>Einsatz von Mock-Objekten</h3>
					<img src="assets/UMLs-imgs/Kapitel_5-Aufgabe_3.png" alt="Mock Objects UML Diagram" class="uml-image">
				</section>
				
				<section>
					<h3>2 Test mit Mock-Objekten (3P)</h3>
					<pre><code class="java">@Test
				public void testDcChargingControllerWithMocks() {
					// Mock-Objekte erstellen
					UserInputPortInterface mockInputPort = new MockUserInputPort();
					UserOutputPortInterface mockOutputPort = new MockUserOutputPort();
					CalculateDcChargingUseCaseInterface mockUseCase = new MockDcChargingUseCase();
					DcChargingOutputPortInterface mockResultPort = new MockDcChargingOutputPort();
					
					// Controller mit Mock-Objekten initialisieren
					DcChargingController controller = new DcChargingController(
						mockInputPort, mockOutputPort, mockUseCase, mockResultPort);
					
					// Controller-Methode ausführen
					boolean result = controller.processDcCharging();
					
					// Überprüfung der Interaktionen mit den Mocks
					assertTrue(result);
					MockUserOutputPort outputMock = (MockUserOutputPort) mockOutputPort;
					assertTrue(outputMock.displayCalled);
					assertTrue(outputMock.displayedMessages.size() > 0);
					
					MockDcChargingUseCase useCaseMock = (MockDcChargingUseCase) mockUseCase;
					assertTrue(useCaseMock.calculateCalled);
					assertNotNull(useCaseMock.lastCommand);
				}
				
				// Mock-Implementierungen
				class MockUserInputPort implements UserInputPortInterface {
					public boolean readDoubleCalled = false;
					public double valueToReturn = 50.0;
					
					@Override
					public double readDouble() {
						readDoubleCalled = true;
						return valueToReturn;
					}
					
					// Weitere Mock-Methoden...
				}
				
				class MockUserOutputPort implements UserOutputPortInterface {
					public boolean displayCalled = false;
					public List<String> displayedMessages = new ArrayList<>();
					
					@Override
					public void display(String message) {
						displayCalled = true;
						displayedMessages.add(message);
					}
					
					// Weitere Mock-Methoden...
				}</code></pre>
				</section>
				
				<section>
					<h3>Test mit komplexerem Mock-Objekt</h3>
					<pre><code class="java">@Test
				public void testExecuteActionInteractorWithMocks() {
					// Komplexeres Setup mit mehreren zusammenarbeitenden Mocks
					MockProfileSelectionService mockProfileService = new MockProfileSelectionService();
					MockActionMenuView mockActionView = new MockActionMenuView();
					MockDcChargingController mockDcController = new MockDcChargingController();
					MockAcChargingController mockAcController = new MockAcChargingController();
					MockRangeCalculationController mockRangeController = new MockRangeCalculationController();
					
					// Testprofile vorbereiten
					CarProfile testProfile = new CarProfile.Builder()
							.id("test-id")
							.name("Test Car")
							.manufacturer("Test Manufacturer")
							.build();
					mockProfileService.selectProfile(testProfile);
					
					// Interactor mit Mocks initialisieren
					ExecuteActionInteractor interactor = new ExecuteActionInteractor(
							mockProfileService,
							mockActionView,
							mockDcController,
							mockAcController,
							mockRangeController);
					
					// Verschiedene Aktionen testen
					
					// DC-Ladung (Aktion 1)
					mockDcController.setReturnValue(true);
					boolean dcResult = interactor.executeAction(1);
					assertTrue(dcResult);
					assertEquals(1, mockDcController.callCount);
					assertEquals(0, mockAcController.callCount);
					assertEquals(0, mockRangeController.callCount);
					
					// AC-Ladung (Aktion 2)
					mockAcController.setReturnValue(true);
					boolean acResult = interactor.executeAction(2);
					assertTrue(acResult);
					assertEquals(1, mockDcController.callCount);
					assertEquals(1, mockAcController.callCount);
					assertEquals(0, mockRangeController.callCount);
					
					// Ungültige Aktion
					boolean invalidResult = interactor.executeAction(99);
					assertFalse(invalidResult);
					assertEquals(1, mockActionView.errorCount);
				}</code></pre>
				</section>
			</section>


			<!-- Kapitel 6 -->
			<section alt="Kapitel 6">
				<section>
					<h2 class="chapter-title">Kapitel 6: <br /> Domain Driven Design (DDD) (8P)</h2>
				</section>

				<section>
					<h3 style="margin-bottom: 20px;" class="subchapter">Inhalt des Kapitels</h3>
					<div class="horizontal-spaced-container"
						style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
						<div>
							<h6>1. Ubiquitous Language (2P)</h6>
							<ul>
								<li>4 Beispiele für die Ubiquitous Language</li>
								<li>Bezeichnung und Bedeutung</li>
								<li>Begründung der Zugehörigkeit</li>
							</ul>
						</div>
						<div>
							<h6>2. Repositories (1.5P)</h6>
							<ul>
								<li>Beschreibung des Repositories</li>
								<li>Code</li>
								<li>UML-Diagramm</li>
								<li>Begründung & Vorteile des Einsatzes</li>
							</ul>
						</div>
						<div>
							<h6>3. Aggregates (1.5P)</h6>
							<ul>
								<li>Beschreibung des Aggregates</li>
								<li>Code</li>
								<li>UML-Diagramm</li>
								<li>Begründung & Vorteile des Einsatzes</li>
							</ul>
						</div>
						<div>
							<h6>4. Entities & Value Objects (1.5p + 1.5p)</h6>
							<ul>
								<li>Beschreibung der Komponenten</li>
								<li>Code</li>
								<li>UML-Diagramme</li>
								<li>Begründung & Vorteile des Einsatzes</li>
							</ul>
						</div>
					</div>
				</section>


				<section>
					<h3>Ubiquitous Language (2p)</h3>
					<p class="subchapter">Vier Beispiele für die Ubiquitous Language; jeweils Bezeichnung, Bedeutung und
						kurze Begründung, warum es zur Ubiquitous Language gehört</p>
				</section>

				<section>
					<h3>Ubiquitous Language</h3>
					<table>
						<thead>
							<tr>
								<th>Begriff</th>
								<th>Bedeutung</th>
								<th>Verwendung</th>
								<th>Ubiquitous Language</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td><b>SoC (State of Charge)</b></td>
								<td>Prozentualer Ladezustand der Batterie (0-100%)</td>
								<td>Parameter für Reichweitenberechnung und Ladezeit</td>
								<td>Fachbegriff aus dem E-Mobility-Bereich, der die gemeinsame Sprache zwischen
									Technikern und Anwendern bildet</td>
							</tr>
							<tr>
								<td><b>WLTP-Range</b></td>
								<td>Standardisierte Reichweite nach <span
										style="font-style: italic; background-color: whitesmoke; border-radius: 5px; padding: 1px 2px;">Worldwide
										Harmonized Light Vehicles Test Procedure</span></td>
								<td>Basis für realistische Reichweitenberechnung</td>
								<td>Regulatorischer Begriff, der eine einheitliche Verständnisgrundlage für
									Fahrzeugleistung bietet</td>
							</tr>
						</tbody>
					</table>
				</section>

				<section>
					<h3>Ubiquitous Language (Fortsetzung)</h3>
					<table>
						<thead>
							<tr>
								<th>Begriff</th>
								<th>Bedeutung</th>
								<th>Verwendung</th>
								<th>Ubiquitous Language</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td><b>Charging Curve</b></td>
								<td>Verlauf der Ladeleistung in Abhängig vom SoC</td>
								<td>Berechnung von Ladezeiten an DC-Ladestationen</td>
								<td>Technisches Konzept, das sowohl für Entwickler als auch Benutzer die
									Ladeeigenschaften beschreibt</td>
							</tr>
							<tr>
								<td><b>Battery Type (LFP, NMC, NCA)</b></td>
								<td>Chemische Zusammensetzung der Batterie (Lithium-Eisenphosphat, Nickel-Mangan-Cobalt,
									Nickel-Cobalt-Aluminium)</td>
								<td>Berechnung von Degradation und Ladegeschwindigkeit</td>
								<td>Chemische Klassifikation, die technische Eigenschaften für das gesamte Team
									eindeutig kommunizierbar macht</td>
							</tr>
						</tbody>
					</table>
				</section>

				<section>
					<h3>Repositories (1.5P)</h3>
					<p class="subchapter">UML, Beschreibung und Begründung des Einsatzes eines Repositories; falls kein
						Repository vorhanden: ausführliche Begründung, warum es keines geben kann/hier nicht sinnvoll
						ist – NICHT, warum es nicht implementiert wurde</p>
				</section>

				<section>
					<h3>Repository: <br /> CarProfileRepository</h3>
					<div class="horizontal-spaced-container">
						<div>
							<ul>
								<li>Persistenz von Fahrzeugprofilen ohne Offenlegung der Speichermechanismen</li>
								<li>Domain Entities können unabhängig von der Persistenz modelliert werden</li>
								<li>Unterstützt die "Illusion" einer <span
										style="font-style: italic;">In-Memory-Sammlung</span></li>
								<li>Ermöglicht einfachen Austausch der Persistenztechnologie im Falle von Refactoring
								</li>
							</ul>
						</div>
					</div>
				</section>

				<section>
					<h3>Repository: Code</h3>
					<div>
						<pre style="width: 900px; height: 500px; overflow: hidden;"><code class="java"> //CarProfileInterface
public interface CarProfilePersistencePortInterface {
    Optional<CarProfile> findById(String id);
    List<CarProfile> findAll();
    CarProfile save(CarProfile carProfile);
    void delete(String id);
} 
	
// Implementation
public class JsonCarProfileRepository implements CarProfilePersistencePortInterface {
    private static final String STORAGE_DIR = "data";
    private static final String FILE_NAME = "car_profiles.json";
    private final Gson gson;
    private final Path filePath;

    public JsonCarProfileRepository() {
        this(STORAGE_DIR, FILE_NAME);
    }
    
    protected JsonCarProfileRepository(String storageDir, String fileName) {
        this.gson = new GsonBuilder()
                .setPrettyPrinting()
                .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())
                .create();
        this.filePath = Paths.get(storageDir, fileName);
        ensureStorageDirectoryExists();
    }

    private void ensureStorageDirectoryExists() {
        try {
            Files.createDirectories(filePath.getParent());
            if (!Files.exists(filePath)) {
                Files.createFile(filePath);
                saveProfiles(new ArrayList<>());
            }
        } catch (IOException e) {
            throw new RuntimeException("Failed to initialize storage", e);
        }
    }

    @Override
    public Optional<CarProfile> findById(String id) {
        return findAll().stream()
                .filter(profile -> profile.getId().equals(id))
                .findFirst();
    }

    @Override
    public List<CarProfile> findAll() {
        try (FileReader reader = new FileReader(filePath.toFile())) {
            Type listType = new TypeToken<List<CarProfile>>() {}.getType();
            List<CarProfile> profiles = gson.fromJson(reader, listType);
            return profiles != null ? profiles : new ArrayList<>();
        } catch (IOException e) {
            throw new RuntimeException("Failed to read car profiles", e);
        }
    }

    @Override
    public CarProfile save(CarProfile carProfile) {
        List<CarProfile> profiles = findAll();
        
        
        boolean found = false;
        for (int i = 0; i < profiles.size(); i++) {
            if (profiles.get(i).getId().equals(carProfile.getId())) {
                profiles.set(i, carProfile);
                found = true;
                break;
            }
        }
        
        if (!found) {
            profiles.add(carProfile);
        }
        
        saveProfiles(profiles);
        return carProfile;
    }

    @Override
    public void delete(String id) {
        List<CarProfile> profiles = findAll();
        profiles.removeIf(profile -> profile.getId().equals(id));
        saveProfiles(profiles);
    }

    private void saveProfiles(List<CarProfile> profiles) {
        try (FileWriter writer = new FileWriter(filePath.toFile())) {
            gson.toJson(profiles, writer);
        } catch (IOException e) {
            throw new RuntimeException("Failed to save car profiles", e);
        }
    }
}</code></pre>
					</div>
				</section>

				<section>
					<h3>Repository: UML</h3>
					<div>
						<img src="assets/UMLs-imgs/Kapitel_6-Aufgabe_2.png" alt="Repository Pattern UML Diagram"
							class="uml-image">
					</div>
				</section>

				<section>
					<h3>Repository: <br /> Begründung & Vorteile</h3>
					<ul>
						<li>Klare Trennung zwischen Domänenlogik und Persistenzmechanismus</li>
						<li>Vereinfachung des Domain Model durch Abstraktion der Persistenz</li>
						<li>Ermöglicht die Anwendung von Clean Architecture Prinzipien</li>
						<li>Erleichtert das Testen durch Mocking der Repository-Implementierung</li>
						<li>Entscheidung für Datenspeicherung in JSON-Dateien bleibt flexibel änderbar</li>
					</ul>
				</section>

				<section>
					<h3>Aggregates (1.5p)</h3>
					<p class="subchapter">UML, Beschreibung und Begründung des Einsatzes eines Aggregates; falls kein
						Aggregate vorhanden: ausführliche Begründung, warum es keines geben kann/hier nicht sinnvoll ist
						– NICHT, warum es nicht implementiert wurde</p>
				</section>

				<section>
					<h3>Aggregates: <br /> CarProfile Aggregate Root</h3>
					<ul>
						<li>Koordiniert mehrere Value Objects (BatteryProfile, ConsumptionProfile,
							ChargingCurve)</li>
						<li>Stellt die Konsistenz zwischen den Value Objects sicher</li>
						<li>Bildet eine sogenannte "transaktionale Einheit" für Änderungen</li>
						<li>Einziger Zugriffspunkt für enthaltene Value Objects</li>
						<li>Hat eine eigene Identität (ID) (-> Aggregate Root)</li>
					</ul>
				</section>

				<section>
					<h3>Aggregates: Code</h3>
					<pre style="width: 900px; height: 500px; overflow: hidden;"><code class="java">public class CarProfile {
	private final String id;
	private final String name;
	private final String manufacturer;
	private final String model;
	private final int year;
	private final boolean hasHeatPump;
	private final double wltpRangeKm;
	private final double maxDcPowerKw;
	private final double maxAcPowerKw;
	private final BatteryProfile batteryProfile;
	private final ConsumptionProfile consumptionProfile;
	private final Optional<ChargingCurve> chargingCurve;

	private CarProfile(Builder builder) {
		this.id = builder.id;
		this.name = Objects.requireNonNull(builder.name, "Name cannot be null");
		this.manufacturer = Objects.requireNonNull(builder.manufacturer, "Manufacturer cannot be null");
		this.model = Objects.requireNonNull(builder.model, "Model cannot be null");
		this.year = builder.year;
		this.hasHeatPump = builder.hasHeatPump;
		this.wltpRangeKm = builder.wltpRangeKm;
		this.maxDcPowerKw = builder.maxDcPowerKw;
		this.maxAcPowerKw = builder.maxAcPowerKw;
		this.batteryProfile = Objects.requireNonNull(builder.batteryProfile, "Battery profile cannot be null");
		this.consumptionProfile = Objects.requireNonNull(builder.consumptionProfile, "Consumption profile cannot be null");
		this.chargingCurve = Optional.ofNullable(builder.chargingCurve);
	}


	@Override
	public boolean equals(Object o) {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;
		CarProfile that = (CarProfile) o;
		return year == that.year &&
				hasHeatPump == that.hasHeatPump &&
				Double.compare(that.wltpRangeKm, wltpRangeKm) == 0 &&
				Double.compare(that.maxDcPowerKw, maxDcPowerKw) == 0 &&
				Double.compare(that.maxAcPowerKw, maxAcPowerKw) == 0 &&
				Objects.equals(id, that.id) &&
				Objects.equals(name, that.name) &&
				Objects.equals(manufacturer, that.manufacturer) &&
				Objects.equals(model, that.model) &&
				Objects.equals(batteryProfile, that.batteryProfile) &&
				Objects.equals(consumptionProfile, that.consumptionProfile) &&
				Objects.equals(chargingCurve, that.chargingCurve);
	}

	@Override
	public int hashCode() {
		return Objects.hash(id, name, manufacturer, model, year, hasHeatPump, wltpRangeKm, maxDcPowerKw, maxAcPowerKw, batteryProfile, consumptionProfile, chargingCurve);
	}

	@Override
	public String toString() {
		return "Car Profile: Test EV, Manufacturer: Test Manufacturer, " +
				"Model: Test Model, Year: 2023, Heat Pump: Yes, " +
				"WLTP Range: 500.0 km, Max DC Power: 250.0 kW, Max AC Power: 11.0 kW";
	}

	public static class Builder {
		private String id;
		private String name;
		private String manufacturer;
		private String model;
		private int year;
		private boolean hasHeatPump;
		private double wltpRangeKm;
		private double maxDcPowerKw;
		private double maxAcPowerKw;
		private BatteryProfile batteryProfile;
		private ConsumptionProfile consumptionProfile;
		private ChargingCurve chargingCurve;

		public Builder id(String id) {
			this.id = id;
			return this;
		}

		public Builder name(String name) {
			this.name = name;
			return this;
		}

		public Builder manufacturer(String manufacturer) {
			this.manufacturer = manufacturer;
			return this;
		}

		public Builder model(String model) {
			this.model = model;
			return this;
		}

		public Builder year(int year) {
			this.year = year;
			return this;
		}

		public Builder hasHeatPump(boolean hasHeatPump) {
			this.hasHeatPump = hasHeatPump;
			return this;
		}

		public Builder wltpRangeKm(double wltpRangeKm) {
			this.wltpRangeKm = wltpRangeKm;
			return this;
		}

		public Builder maxDcPowerKw(double maxDcPowerKw) {
			this.maxDcPowerKw = maxDcPowerKw;
			return this;
		}

		public Builder maxAcPowerKw(double maxAcPowerKw) {
			this.maxAcPowerKw = maxAcPowerKw;
			return this;
		}

		public Builder batteryProfile(BatteryProfile batteryProfile) {
			this.batteryProfile = batteryProfile;
			return this;
		}

		public Builder consumptionProfile(ConsumptionProfile consumptionProfile) {
			this.consumptionProfile = consumptionProfile;
			return this;
		}

		public Builder chargingCurve(ChargingCurve chargingCurve) {
			this.chargingCurve = chargingCurve;
			return this;
		}

		public CarProfile build() {
			if (this.id == null) {
				this.id = generateUniqueId();
			}
			return new CarProfile(this);
		}
		
		private String generateUniqueId() {
			return java.util.UUID.randomUUID().toString();
		}

		
	}

	public String getId() {
		return id;
	}

	public String getName() {
		return name;
	}

	public String getManufacturer() {
		return manufacturer;
	}

	public String getModel() {
		return model;
	}

	public int getYear() {
		return year;
	}

	public boolean hasHeatPump() {
		return hasHeatPump;
	}

	public double getWltpRangeKm() {
		return wltpRangeKm;
	}

	public double getMaxDcPowerKw() {
		return maxDcPowerKw;
	}

	public double getMaxAcPowerKw() {
		return maxAcPowerKw;
	}

	public BatteryProfile getBatteryProfile() {
		return batteryProfile;
	}

	public ConsumptionProfile getConsumptionProfile() {
		return consumptionProfile;
	}

	public Optional<ChargingCurve> getChargingCurve() {
		return chargingCurve;
	}
} 

</code></pre>
				</section>

				<section>
					<h3>Aggregate: UML</h3>
					<div class="horizontal-spaced-container">
						<div>
							<img src="assets/UMLs-imgs/Kapitel_6-Aufgabe_3.png" alt="Aggregate Pattern UML Diagram"
								class="uml-image">
						</div>
				</section>

				<section>
					<h3>Aggregates: Vorteile & Begründung</h3>
					<ul>
						<li>CarProfile als Aggregate Root koordiniert die Konsistenz seiner Value Objects</li>
						<li>Stellt sicher, dass BatteryProfile, ConsumptionProfile und ChargingCurve immer konsistent
							sind</li>
						<li>Vereinfacht die Persistenz, da nur der Aggregate Root direkt gespeichert werden muss</li>
						<li>Schützt die Value Objects vor unerlaubten Änderungen von außen</li>
						<li>Modelliert die natürliche Gruppierung von Fahrzeugdaten und deren Komponenten</li>
					</ul>
				</section>


				<section>
					<h3>Entities (1.5P)</h3>
					<p class="subchapter">UML, Beschreibung und Begründung des Einsatzes einer Entity; falls keine
						Entity vorhanden: ausführliche Begründung, warum es keine geben kann/hier nicht sinnvoll ist –
						NICHT, warum es nicht implementiert wurde</p>
				</section>


				<section>
					<h3>Entities:<br /> CarProfile als Entity</h3>
					<ul>
						<li>Besitzt eine eindeutige Identität (UUID)</li>
						<li>Identität bleibt über den gesamten Lebenszyklus erhalten</li>
						<li>Kann verändert und weiterentwickelt werden (auch wenn in ULRICA immutable)</li>
						<li>Wird über die Identität verglichen, nicht über Attributwerte</li>
						<li>Repräsentiert ein reales Objekt (Elektrofahrzeug) mit eigenem Lebenszyklus</li>
					</ul>
				</section>

				<section>
					<h3 style="margin-bottom: 0; padding-bottom: 0;">Entity: UML</h3>
					<img style="scale: 0.9; position: relative; bottom: 50px;"
						src="assets/UMLs-imgs/Kapitel_6-Aufgabe_4.png" alt="Entity Pattern UML Diagram"
						class="uml-image">
				</section>

				<section>
					<h3>Entity: Begründung & Vorteile</h3>
					<ul>
						<li>Eindeutige Identifikation von Objekten unabhängig von ihren Attributen</li>
						<li>Möglichkeit, Entitäten über ihren Lebenszyklus hinweg zu verfolgen</li>
						<li>Konsistente Identifikation in verschiedenen Kontexten des Systems</li>
						<li>Klare Unterscheidung zwischen Identität und Attributen</li>
						<li>Natürliche Abbildung von realen Objekten mit eigener Identität</li>
					</ul>
				</section>

				<section>
					<h3>Value Objects (1.5P)</h3>
					<p class="subchapter">UML, Beschreibung und Begründung des Einsatzes eines Value Objects; falls kein
						Value Object vorhanden: ausführliche Begründung, warum es keines geben kann/hier nicht sinnvoll
						ist – NICHT, warum es nicht implementiert wurde</p>
				</section>

				<section>
					<h3>Value Objects: BatteryProfile als ValueObject</h3>
					<ul>
						<li>Keine eigene Identität</li>
						<li>Immutable (unveränderlich) nach Erstellung</li>
						<li>Vergleich basiert auf allen Attributwerten</li>
						<li>Beschreibt eine Messung oder ein Konzept</li>
						<li>Kann problemlos ersetzt werden</li>
						<li>Validiert sich selbst bei der Erstellung</li>
					</ul>
				</section>

				<section>
					<h3>Value Object: Code</h3>
					<pre><code class="java">public final class BatteryProfile {
	private final BatteryType type;
	private final double capacityKwh;
	private final double degradationPercent;
	private final double maxDcPowerKw;
	private final double maxAcPowerKw;

	public BatteryProfile(BatteryType type, double capacityKwh, double degradationPercent, double maxDcPowerKw, double maxAcPowerKw) {
		if (capacityKwh <= 0) {
			throw new IllegalArgumentException("Battery capacity must be positive");
		}
		if (degradationPercent < 0 || degradationPercent > 100) {
			throw new IllegalArgumentException("Degradation must be between 0 and 100 percent");
		}
		if (maxDcPowerKw <= 0) {
			throw new IllegalArgumentException("Max DC power must be positive");
		}
		if (maxAcPowerKw <= 0) {
			throw new IllegalArgumentException("Max AC power must be positive");
		}
		this.type = Objects.requireNonNull(type, "Battery type cannot be null");
		this.capacityKwh = capacityKwh;
		this.degradationPercent = degradationPercent;
		this.maxDcPowerKw = maxDcPowerKw;
		this.maxAcPowerKw = maxAcPowerKw;
	}

	public BatteryType getType() {
		return type;
	}

	public double getCapacityKwh() {
		return capacityKwh;
	}

	public double getDegradationPercent() {
		return degradationPercent;
	}

	public double getRemainingCapacityKwh() {
		return capacityKwh * (1 - degradationPercent / 100);
	}

	public double getMaxDcPowerKw() {
		return maxDcPowerKw;
	}

	public double getMaxAcPowerKw() {
		return maxAcPowerKw;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;
		BatteryProfile that = (BatteryProfile) o;
		return Double.compare(that.capacityKwh, capacityKwh) == 0 &&
				Double.compare(that.degradationPercent, degradationPercent) == 0 &&
				Double.compare(that.maxDcPowerKw, maxDcPowerKw) == 0 &&
				Double.compare(that.maxAcPowerKw, maxAcPowerKw) == 0 &&
				type == that.type;
	}

	@Override
	public int hashCode() {
		return Objects.hash(type, capacityKwh, degradationPercent, maxDcPowerKw, maxAcPowerKw);
	}

	@Override
	public String toString() {
		return String.format(
			"Type: %s (%s)%n" +
			"Capacity: %.1f kWh%n" +
			"Degradation: %.1f%%%n" +
			"Remaining Capacity: %.1f kWh%n" +
			"Max DC Power: %.1f kW%n" +
			"Max AC Power: %.1f kW",
			type.name(), type.getDescription(),
			capacityKwh, degradationPercent,
			getRemainingCapacityKwh(),
			maxDcPowerKw, maxAcPowerKw
		);
	}
} </code></pre>
				</section>

				<section>
					<h3>Value Objects: UML</h3>
					<img style="scale: 1.1" src="assets/UMLs-imgs/Kapitel_6-Aufgabe_5.png"
						alt="Value Objects UML Diagram" class="uml-image">
				</section>

				<section>
					<h3>Value Objects: Begründung & Vorteile</h3>
					<ul>
						<li>Batteryprofile und ConsumptionProfile sind immutable und damit thread-safe</li>
						<li>Vereinfachte Validierung durch Konstruktor basierte Erstellung</li>
						<li>Natürliche Modellierung von Messwerten und Konzepten ohne Identität</li>
						<li>Einfache Vergleichbarkeit durch attribut-basierte equals-Implementierung</li>
						<li>Können problemlos ausgetauscht werden, da sie keine Identität haben</li>
					</ul>
				</section>

			</section>

			<!-- Kapitel 7 -->
			<section alt="Kapitel 7">
				<section>
					<h2 class="chapter-title">Kapitel 7:<br />Refactoring (8P)</h2>
				</section>

				<section>
					<h3 class="subchapter">Inhalt des Kapitels</h3>
					<div class="horizontal-spaced-container"
						style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin-top: 50px;">
						<div>
							<h4>1. Code Smells (2P)</h4>
							<ul>
								<li>Lange Methode in "RangeCalculationController"</li>
								<li>Duplizierter Code in "Charging Calculators"</li>
							</ul>
						</div>
						<div>
							<h4>2. Refactorings (6P)</h4>
							<ul>
								<li>"Extract Method"</li>
								<li>Ersetzen von Conditionals mit Polymorphism</li>
							</ul>
						</div>
					</div>
				</section>

				<section>
					<h3>Code Smells (2p)</h3>
					<p class="subchapter">Jeweils 1 Code-Beispiel zu 2 unterschiedlichen Code Smells (die benannt werden
						müssen) aus der
						Vorlesung; jeweils Code-Beispiel und einen möglichen Lösungsweg bzw. den genommen Lösungsweg
						beschreiben (inkl.
						(Pseudo-)Code)</p>
				</section>

				<section>
					<h4>Code Smell 1: Lange Methode</h4>
					<pre style="width: 1000px; height: 500px; overflow: hidden;"><code class="java">/* public class RangeCalculationController {
			private final CalculateRangeUseCaseInterface calculateRangeUseCase;
			private final UserInputPortInterface userInputPort;
			private final RangeCalculationOutputPortInterface outputPort;
			
			public RangeCalculationController(
					CalculateRangeUseCaseInterface calculateRangeUseCase,
					UserInputPortInterface userInputPort,
					RangeCalculationOutputPortInterface outputPort) {
				this.calculateRangeUseCase = Objects.requireNonNull(calculateRangeUseCase, "Calculate range use case cannot be null");
				this.userInputPort = Objects.requireNonNull(userInputPort, "User input port cannot be null");
				this.outputPort = Objects.requireNonNull(outputPort, "Output port cannot be null");
			} */
			
			public boolean processRangeCalculation() {
				try {
					outputPort.showRangeCalculationHeader();
					
					TerrainType terrain = getTerrainType();
					WeatherType weather = getWeatherType();
					double temperature = getTemperature();
					DrivingEnvironment environment = getDrivingEnvironment();
					double stateOfCharge = getStateOfCharge();
					EfficiencyMode efficiencyMode = getEfficiencyMode();
					
					return calculateRangeUseCase.calculateRange(
							terrain,
							weather,
							temperature,
							environment,
							efficiencyMode,
							stateOfCharge
					);
				} catch (Exception e) {
					outputPort.showError("An error occurred: " + e.getMessage());
					return false;
				}
	}
/*...</code></pre>
				</section>

				<section>
					<h3>Code Smell 1: Analyse</h3>
					<ul>
						<li>Die Methode ist zu lang und komplex -> Unübersichtlich</li>
						<li>Viele verschiedene Verantwortlichkeiten in einer Methode</li>
						<li>Schlechte Lesbarkeit und Wartbarkeit</li>
						<li>Schwer zu testen</li>
						<li>Verletzt das Single Responsibility Principle</li>
					</ul>
				</section>

				<section>
					<h3>Code Smell 1: Lösungsvorschlag</h3>
					<pre style="width: 1000px; height: 500px; overflow: hidden;"><code class="java">public boolean processRangeCalculation() {
	try {
		outputPort.showRangeCalculationHeader(); // Ausgabe eines Headers vor der Berechnung

		RangeParameters parameters = collectRangeParameters(); // Sammeln aller Eingabewerte in ein Objekt
		return calculateRangeUseCase.calculateRange(parameters); // Aufruf der Reichweitenberechnung mit Parametern

	} catch (InvalidInputException e) {
		outputPort.showError("Invalid input: " + e.getMessage()); // Ausgabe eines Fehlers bei ungültiger Eingabe
		return false;
	} catch (Exception e) {
		outputPort.showError("Unexpected error: " + e.getMessage()); // Allgemeine Fehlerbehandlung
		return false;
	}
}

private RangeParameters collectRangeParameters() {
	return new RangeParameters(
		getTerrainType(),          // Ermittlung des Geländetyps
		getWeatherType(),          // Ermittlung der Wetterbedingungen
		getTemperature(),          // Abfrage der aktuellen Temperatur
		getDrivingEnvironment(),   // Ermittlung der Fahrumgebung
		getEfficiencyMode(),       // Auswahl des Effizienzmodus
		getStateOfCharge()         // Abfrage des aktuellen Ladezustands
	);
}
</code></pre>
				</section>


				<section>
					<h3>Code Smell 2: Duplicate Code</h3>
					<div class="horizontal-spaced-container">
						<div>
							<pre style="width: 1000px; height: 500px; overflow: hidden;"><code class="java">// DcChargingCalculator
private double calculateTemperatureEfficiencyFactor(double batteryTemperatureCelsius) {
	if (batteryTemperatureCelsius < MIN_BATTERY_TEMPERATURE || 
		batteryTemperatureCelsius > MAX_BATTERY_TEMPERATURE) {
		return 0.0;
	}
	
	if (batteryTemperatureCelsius >= OPTIMAL_TEMPERATURE_MIN && 
		batteryTemperatureCelsius <= OPTIMAL_TEMPERATURE_MAX) {
		return 1.0;
	}
	
	if (batteryTemperatureCelsius < OPTIMAL_TEMPERATURE_MIN) {
		return 0.5 + 0.5 * (batteryTemperatureCelsius - MIN_BATTERY_TEMPERATURE) / 
			(OPTIMAL_TEMPERATURE_MIN - MIN_BATTERY_TEMPERATURE);
	} else {
		return 0.5 + 0.5 * (MAX_BATTERY_TEMPERATURE - batteryTemperatureCelsius) / 
			(MAX_BATTERY_TEMPERATURE - OPTIMAL_TEMPERATURE_MAX);
	}
}

// AcChargingCalculator
private double calculateTemperatureEfficiency(double ambientTemperatureCelsius) {
	if (ambientTemperatureCelsius < MIN_BATTERY_TEMPERATURE || 
		ambientTemperatureCelsius > MAX_BATTERY_TEMPERATURE) {
		return 0.0;
	}
	
	if (ambientTemperatureCelsius >= OPTIMAL_TEMPERATURE_MIN && 
		ambientTemperatureCelsius <= OPTIMAL_TEMPERATURE_MAX) {
		return 1.0;
	}
	
	if (ambientTemperatureCelsius < OPTIMAL_TEMPERATURE_MIN) {
		return 0.7 + 0.3 * (ambientTemperatureCelsius - MIN_BATTERY_TEMPERATURE) / 
			(OPTIMAL_TEMPERATURE_MIN - MIN_BATTERY_TEMPERATURE);
	} else {
		return 0.7 + 0.3 * (MAX_BATTERY_TEMPERATURE - ambientTemperatureCelsius) / 
			(MAX_BATTERY_TEMPERATURE - OPTIMAL_TEMPERATURE_MAX);
	}
}</code></pre>
						</div>
					</div>
				</section>

				<section>
					<h3>Code Smell 2: Analyse</h3>
					<ul>
						<li>Fast identischer Code in beiden Klassen (DC & AC Charging Calculators)</li>
						<li>Nur minimale Unterschiede in den Konstanten (0.5 vs 0.7)</li>
						<li>Verletzt das DRY-Prinzip (Don't Repeat Yourself)</li>
						<li>Schwer zu warten bei Änderungen</li>
						<li>Fehleranfällig bei Updates</li>
					</ul>
				</section>

				<section>
					<h3>Code Smell 2: Lösungsvorschlag</h3>
					<p class="subchapter">Logik kombinieren durch Berechnung</p>
					<pre><code class="java">public class TemperatureEfficiencyCalculator {
	private final double minEfficiency;
	private final double maxEfficiency;
	
	public TemperatureEfficiencyCalculator(double minEfficiency, double maxEfficiency) {
		this.minEfficiency = minEfficiency;
		this.maxEfficiency = maxEfficiency;
	}
	
	public double calculateEfficiency(double temperature) {
		if (temperature < MIN_BATTERY_TEMPERATURE || 
			temperature > MAX_BATTERY_TEMPERATURE) {
			return 0.0;
		}
		
		if (temperature >= OPTIMAL_TEMPERATURE_MIN && 
			temperature <= OPTIMAL_TEMPERATURE_MAX) {
			return 1.0;
		}
		
		if (temperature < OPTIMAL_TEMPERATURE_MIN) {
			return minEfficiency + (maxEfficiency - minEfficiency) * 
				(temperature - MIN_BATTERY_TEMPERATURE) / 
				(OPTIMAL_TEMPERATURE_MIN - MIN_BATTERY_TEMPERATURE);
		} else {
			return minEfficiency + (maxEfficiency - minEfficiency) * 
				(MAX_BATTERY_TEMPERATURE - temperature) / 
				(MAX_BATTERY_TEMPERATURE - OPTIMAL_TEMPERATURE_MAX);
		}
	}
}</code></pre>
				</section>


				<section>
					<h3>Refactorings (2p)</h3>
					<p class="subchapter">2 unterschiedliche Refactorings aus der Vorlesung jeweils benennen, anwenden,
						begründen, sowie UML vorher/nachher liefern; jeweils auf die Commits verweisen – die
						Refactorings dürfen sich nicht mit den Beispielen der Code Smells überschneiden</p>
				</section>


				<section>
					<h3>Refactoring 1: Code</h3>
					<p class="subchapter">Extrahieren der Parameter-Erfassung in eine separate Methode (commit a5638e0)
					</p>
					<div class="horizontal-spaced-container" style="gap: 20px;">
						<div style="width: 50%;">
							<h5>Vorher</h5>
							<pre
								style="width: 550px; height: 450px; overflow: hidden; position: relative; right: 80px;"><code class="java">public boolean processRangeCalculation() {
					try {
						outputPort.showRangeCalculationHeader();
						
						TerrainType terrain = getTerrainType();
						WeatherType weather = getWeatherType();
						double temperature = getTemperature();
						DrivingEnvironment environment = getDrivingEnvironment();
						double stateOfCharge = getStateOfCharge();
						EfficiencyMode efficiencyMode = getEfficiencyMode();
						
						return calculateRangeUseCase.calculateRange(
								terrain,
								weather,
								temperature,
								environment,
								efficiencyMode,
								stateOfCharge
						);
					} catch (Exception e) {
						outputPort.showError("An error occurred: " + e.getMessage());
						return false;
					}
				}</code></pre>
						</div>
						<div style="width: 50%;">
							<h5>Nachher</h5>
							<pre style="width: 550px; height: 450px; overflow: hidden;"><code class="java">public boolean processRangeCalculation() {
					try {
						outputPort.showRangeCalculationHeader();
						RangeParameters parameters = collectRangeParameters();
						return calculateRangeUseCase.calculateRange(parameters);
					} catch (Exception e) {
						outputPort.showError("An error occurred: " + e.getMessage());
						return false;
					}
				}
				
				private RangeParameters collectRangeParameters() {
					TerrainType terrain = getTerrainType();
					WeatherType weather = getWeatherType();
					double temperature = getTemperature();
					DrivingEnvironment environment = getDrivingEnvironment();
					double stateOfCharge = getStateOfCharge();
					EfficiencyMode efficiencyMode = getEfficiencyMode();
					
					return new RangeParameters(
						terrain,
						weather,
						temperature,
						environment,
						efficiencyMode,
						stateOfCharge
					);
				}</code></pre>
						</div>
					</div>
				</section>


				<section>
					<h3>Refactoring 1: Erklärung</h3>
					<div class="horizontal-spaced-container">
						<div style="width: 50%;">
							<h4>Vorteile</h4>
							<ul>
								<li>Bessere Wartbarkeit durch modularen Code</li>
								<li>Einfachere Testbarkeit durch isolierte Funktionalität</li>
								<li>Reduzierte Komplexität in der Hauptmethode</li>
								<li>Einhaltung des <strong>Single Responsibility Principle (SRP)</strong> durch klare
									Trennung
									der Verantwortlichkeiten</li>
								<li>Einhaltung des <strong>Don't Repeat Yourself (DRY)</strong> Prinzips durch
									Vermeidung von
									Code-Duplikation</li>
							</ul>
						</div>
						<div style="width: 50%;">
							<h4>Änderungen</h4>
							<ul>
								<li>Extraktion der Parameter-Erfassung in separate Methode
									<code>collectRangeParameters()</code>
								</li>
								<li>Einführung einer neuen Klasse <code>RangeParameters</code> zur Kapselung der
									Parameter</li>
								<li>Vereinfachung der Hauptmethode <code>processRangeCalculation()</code></li>
								<li>Reduzierung der Parameteranzahl im Use Case Interface</li>
								<li>Verbesserte Lesbarkeit durch klare Trennung von Parameter-Erfassung und
									Geschäftslogik</li>
							</ul>
						</div>
					</div>
				</section>

				<section>
					<h3>Refactoring 1: UML-Diagramme</h3>
					<div class="horizontal-spaced-container">
						<div>
							<h5>Vorher</h5>
							<img style="scale: 1.35; position:  relative; right: 55px;"
								src="assets/UMLs-imgs/refactoring1_before.puml.png" alt="Extract Method UML Before"
								class="uml-image">
						</div>
						<div>
							<h5>Nachher</h5>
							<img style="scale: 1.35; position:  relative; left: 50px;"
								src="assets/UMLs-imgs/refactoring1_after.puml.png" alt="Extract Method UML After"
								class="uml-image">
						</div>
					</div>
				</section>


				<section>
					<h3>Refactoring 2: Code</h3>
					<p class="subchapter">Ersetzen der Logik in den ChargingCalculators durch Polymorphie
						(943b4c7)</p>
					<div class="horizontal-spaced-container">
						<div style="width: 50%;">
							<h5>Vorher</h5>
							<pre
								style="width: 550px; height: 450px; overflow: hidden; position: relative; right: 80px;"><code class="java">public class DcChargingCalculator {
					private double calculatePowerReductionPercent(double startingSocPercent, double targetSocPercent) {
						if (targetSocPercent > 80) {
							return 60.0;
						} else if (targetSocPercent > 60) {
							return 30.0;
						} else {
							return 5.0;
						}
					}
				}
				
				public class AcChargingCalculator {
					private double calculateEfficiencyLoss(int connectorType) {
						switch (connectorType) {
							case HOUSEHOLD_SOCKET:
								return 0.1;
							case CAMPING_SOCKET:
								return 0.07;
							case WALLBOX:
								return 0.05;
							default:
								throw new IllegalArgumentException("Invalid connector type: " + connectorType);
						}
					}
				}</code></pre>
						</div>
						<div style="width: 50%;">
							<h5>Nachher</h5>
							<pre style="width: 550px; height: 450px; overflow: hidden;"><code class="java">public interface ChargingStrategy {
					double calculateEfficiency();
				}
				
				public class HouseholdSocketStrategy implements ChargingStrategy {
					@Override
					public double calculateEfficiency() {
						return 0.1;
					}
				}
				
				public class CampingSocketStrategy implements ChargingStrategy {
					@Override
					public double calculateEfficiency() {
						return 0.07;
					}
				}
				
				public class WallboxStrategy implements ChargingStrategy {
					@Override
					public double calculateEfficiency() {
						return 0.05;
					}
				}
				
				public class DcChargingStrategy implements ChargingStrategy {
					private final double targetSocPercent;
					
					public DcChargingStrategy(double targetSocPercent) {
						this.targetSocPercent = targetSocPercent;
					}
					
					@Override
					public double calculateEfficiency() {
						if (targetSocPercent > 80) {
							return 0.4; // 60% reduction
						} else if (targetSocPercent > 60) {
							return 0.7; // 30% reduction
						} else {
							return 0.95; // 5% reduction
						}
					}
				}</code></pre>
						</div>
					</div>
				</section>

				<section>
					<h3>Refactoring 2: Erklärung</h3>
					<div class="horizontal-spaced-container">
						<div style="width: 50%;">
							<h4>Vorteile</h4>
							<ul>
								<li>Bessere Wartbarkeit durch klare Trennung der Verantwortlichkeiten</li>
								<li>Einfache Erweiterbarkeit durch neue Strategien</li>
								<li>Bessere Testbarkeit durch isolierte Komponenten</li>
								<li>Einhaltung des <strong>Open/Closed Principle</strong></li>
								<li>Reduzierte Komplexität in den Charging Calculators</li>
							</ul>
						</div>
						<div style="width: 50%;">
							<h4>Änderungen</h4>
							<ul>
								<li>Einführung des <code>ChargingStrategy</code> Interfaces</li>
								<li>Implementierung konkreter Strategien: <code>HouseholdSocketStrategy</code>,
									<code>CampingSocketStrategy</code>, <code>WallboxStrategy</code>,
									<code>DcChargingStrategy</code>
								</li>
								<li>Ersetzung der Logik durch polymorphe Methodenaufrufe</li>
								<li>Kapselung der Effizienzberechnung in den jeweiligen Strategieklassen</li>
								<li>Einführung von Konstruktoren für kontextabhängige Strategien</li>
							</ul>
						</div>
					</div>
				</section>



				<section>
					<h3>Refactoring 2: UML-Diagramme</h3>
					<div class="horizontal-spaced-container">
						<div>
							<h5>Vorher</h5>
							<img style="scale: 1.3; position: relative; right: 60px;"
								src="assets/UMLs-imgs/refactoring2_before.puml.png"
								alt="Replace Conditional with Polymorphism UML Before" class="uml-image">
						</div>
						<div>
							<h5>Nachher</h5>
							<img style="scale: 1.3;  position: relative; left: 50px;"
								src="assets/UMLs-imgs/refactoring2_after.puml.png"
								alt="Replace Conditional with Polymorphism UML After" class="uml-image">
						</div>
					</div>
				</section>

			</section>

			<!-- Kapitel 8 -->
			<section alt="Kapitel 8">
				<section>
					<h2 class="chapter-title">Kapitel 8: <br /> Entwurfsmuster (8P)</h2>
					<p class="subchapter">Zwei unterschiedliche Entwurfsmuster aus der Vorlesung (oder nach Absprache
						auch andere) jeweils benennen, sinnvoll einsetzen, begründen und UML-Diagramm</p>
				</section>

				<section>
					<h3>Entwurfsmuster 1: <br /> Strategy Pattern (4P)</h3>
					<div class="horizontal-spaced-container">
						<div style="width: 50%;">
							<h4>Überblick</h4>
							<ul>
								<li><b>Kategorie/Art:</b> Behavioral Pattern</li>
								<li><b>Zweck:</b> Definiert eine Familie von Algorithmen, kapselt sie ab und macht sie
									austauschbar (Laufzeit u. Compilezeit)</li>
								<li><b>Verwendung:</b> Implementierung verschiedener Berechnungsstrategien für die
									Reichweite von Elektrofahrzeugen</li>
							</ul>
						</div>
						<div style="width: 50%;">
							<h4>Vorteile</h4>
							<ul>
								<li>Kapselung von unterschiedlichen Algorithmen in getrennten Klassen</li>
								<li>Laufzeitentscheidung über zu verwendende Strategie</li>
								<li>Leichte Erweiterbarkeit um neue Strategien (Auch gut für OCP)</li>
								<li>Einhaltung des <strong>Open/Closed Principles</strong></li>
								<li>Vermeidung von bedingten Verzweigungen durch Polymorphie</li>
							</ul>
						</div>
					</div>
				</section>


				<section>
					<h3 style="padding: 0; margin-top: 0;">Entwurfsmuster 1: <br /> Strategy Pattern (Forsetzung)</h3>
					<div style="width: 100%;">
						<h4 style="margin-top: 50px; padding: 0; margin-bottom: 0;">Nachteile</h4>
						<ul>
							<li>Erhöhte Komplexität durch viele kleine Klassen</li>
							<li>Client/Klasse muss die verschiedenen Strategien kennen</li>
							<li>Möglicher Overhead durch zusätzliche Erstellung von Objekten</li>
							<li>Strategie-Auswahl kann komplex werden</li>
							<li>Schwieriger zu debuggen durch verteilte Logik</li>
						</ul>
					</div>
				</section>


				<section>
					<h3>Strategy Pattern: Interface</h3>
					<div class="horizontal-spaced-container">
						<div>
							<pre style="width: 1000px; height: 500px; overflow: hidden;"><code class="java">// Das Strategy Interface
public interface RangeCalculationStrategyInterface {
	RangeResult calculateRange(CarProfile carProfile, RangeParameters parameters);
	
	String getName();
	
	String getDescription();
}

</code></pre>
						</div>
					</div>
				</section>

				<section>
					<h3>Strategy Pattern: Erste Implementierung</h3>
					<div class="horizontal-spaced-container">
						<div>
							<pre style="width: 1000px; height: 500px; overflow: hidden;"><code class="java">// Erste Strategie-Implementierung
public class WltpBasedRangeCalculationStrategy implements RangeCalculationStrategyInterface {

	@Override
	public RangeResult calculateRange(CarProfile carProfile, RangeParameters parameters) {
		Objects.requireNonNull(carProfile, "Car profile cannot be null!!!");
		Objects.requireNonNull(parameters, "Range parameters cannot be null");
		
		double baseWltpRange = carProfile.getWltpRangeKm();
		double batteryCapacity = carProfile.getBatteryProfile().getRemainingCapacityKwh();
		double currentSoC = parameters.getStateOfChargePercent();
		
		double baseConsumption = (batteryCapacity * 100.0) / baseWltpRange;
		
		double modeConsumption = baseConsumption * parameters.getEfficiencyMode().getConsumptionFactor();
		
		double terrainFactor = calculateTerrainFactor(parameters.getTerrain());
		double terrainConsumption = modeConsumption * terrainFactor;
		
		double weatherFactor = calculateWeatherFactor(parameters.getWeather(), parameters.getTemperatureCelsius());
		double weatherConsumption = terrainConsumption * weatherFactor;
		
		double environmentFactor = calculateEnvironmentFactor(parameters.getEnvironment());
		double finalConsumption = weatherConsumption * environmentFactor;
		
		double availableEnergy = batteryCapacity * (currentSoC / 100.0);
		double estimatedRange = (availableEnergy * 100.0) / finalConsumption;
		
		String weatherImpact = generateWeatherImpactDescription(parameters.getWeather(), parameters.getTemperatureCelsius());
		String terrainImpact = generateTerrainImpactDescription(parameters.getTerrain());
		String environmentImpact = generateEnvironmentImpactDescription(parameters.getEnvironment());
		String batteryCondition = generateBatteryConditionDescription(parameters.getStateOfChargePercent(), parameters.getTemperatureCelsius());
		
		return new RangeResult(
				estimatedRange,
				finalConsumption,
				weatherImpact,
				terrainImpact,
				environmentImpact,
				batteryCondition
		);
	}
	
	private double calculateTerrainFactor(TerrainType terrain) {
		return switch(terrain) {
			case FLAT -> 1.0;
			case HILLY -> 1.15;
			case MOUNTAINOUS -> 1.35;
		};
	}
	
	private double calculateWeatherFactor(WeatherType weather, double temperature) {
		double weatherMultiplier = switch(weather) {
			case SUNNY -> 0.9;
			case CLOUDY -> 0.95;
			case RAIN -> 1.1;
			case SNOW -> 1.3;
			case STRONG_WIND -> 1.2;
		};
		
		double tempFactor;
		if (temperature < -10) {
			tempFactor = 1.4;
		} else if (temperature < 0) {
			tempFactor = 1.2;
		} else if (temperature < 10) {
			tempFactor = 1.0;
		} else if (temperature <= 25) {
			tempFactor = 0.9;
		} else if (temperature <= 35) {
			tempFactor = 0.95;
		} else {
			tempFactor = 1.1;
		}
		
		return weatherMultiplier * tempFactor;
	}
	
	private double calculateEnvironmentFactor(DrivingEnvironment environment) {
		return switch(environment) {
			case CITY -> 0.8;     
			case RURAL -> 1.0;    
			case HIGHWAY -> 1.1; 
		};
	}
	
	private String generateWeatherImpactDescription(WeatherType weather, double temperature) {
		StringBuilder impact = new StringBuilder();
		
		switch(weather) {
			case SUNNY:
				impact.append("Minimal impact - Ideal weather conditions");
				break;
			case CLOUDY:
				impact.append("Slight impact - Cloud cover has minimal effect on efficiency");
				break;
			case RAIN:
				impact.append("Moderate impact - Rain increases rolling resistance");
				break;
			case SNOW:
				impact.append("Severe impact - Snow conditions significantly reduce range");
				break;
			case STRONG_WIND:
				impact.append("Significant impact - Strong winds increase air resistance");
				break;
		}
		
		if (temperature < 0) {
			impact.append(", Cold temperature reduces battery efficiency");
		} else if (temperature > 30) {
			impact.append(", High temperature requires additional cooling");
		}
		
		return impact.toString();
	}
	
	private String generateTerrainImpactDescription(TerrainType terrain) {
		return switch(terrain) {
			case FLAT -> "Minimal impact - Flat terrain optimal for efficiency";
			case HILLY -> "Moderate impact - Hills affect energy consumption";
			case MOUNTAINOUS -> "Significant impact - Mountainous terrain substantially increases consumption";
		};
	}
	
	private String generateEnvironmentImpactDescription(DrivingEnvironment environment) {
		return switch(environment) {
			case CITY -> "Stop-and-go traffic at " + environment.getAvgSpeedKmh() + " km/h - Benefits from regenerative braking";
			case RURAL -> "Medium speed driving at " + environment.getAvgSpeedKmh() + " km/h - Moderate air resistance";
			case HIGHWAY -> "Constant high speed at " + environment.getAvgSpeedKmh() + " km/h - Increased air resistance";
		};
	}
	
	private String generateBatteryConditionDescription(double soc, double temperature) {
		StringBuilder condition = new StringBuilder();
		
		if (soc > 80) {
			condition.append("High SoC (").append(soc).append("%) - Optimal operating range");
		} else if (soc > 40) {
			condition.append("Medium SoC (").append(soc).append("%) - Good operating range");
		} else if (soc > 20) {
			condition.append("Low SoC (").append(soc).append("%) - Consider charging soon");
		} else {
			condition.append("Very low SoC (").append(soc).append("%) - Critical level, charge immediately");
		}
		
		condition.append(", ");
		
		if (temperature < -10) {
			condition.append("Battery temperature very cold (").append(temperature).append("°C) - Severely reduced efficiency");
		} else if (temperature < 0) {
			condition.append("Battery temperature cold (").append(temperature).append("°C) - Reduced efficiency");
		} else if (temperature < 10) {
			condition.append("Battery temperature cool (").append(temperature).append("°C) - Slightly reduced efficiency");
		} else if (temperature <= 30) {
			condition.append("Battery temperature optimal (").append(temperature).append("°C) - Maximum efficiency");
		} else if (temperature <= 40) {
			condition.append("Battery temperature warm (").append(temperature).append("°C) - Slightly reduced efficiency");
		} else {
			condition.append("Battery temperature hot (").append(temperature).append("°C) - Reduced efficiency, potential for degradation");
		}
		
		return condition.toString();
	}

	@Override
	public String getName() {
		return "WLTP-based Range Calculation";
	}

	@Override
	public String getDescription() {
		return "Calculates range based on the car's WLTP rating adjusted for external conditions";
	}
} 
</code></pre>
						</div>
					</div>
				</section>

				<section>
					<h3>Strategy Pattern: Zweite Implementierung</h3>
					<div class="horizontal-spaced-container">
						<div>
							<pre style="width: 1000px; height: 500px; overflow: hidden;"><code class="java">// Zweite Strategie-Implementierung

public class ConsumptionBasedRangeCalculationStrategy implements RangeCalculationStrategyInterface {

    @Override
    public RangeResult calculateRange(CarProfile carProfile, RangeParameters parameters) {
        Objects.requireNonNull(carProfile, "Car profile cannot be null");
        Objects.requireNonNull(parameters, "Range parameters cannot be null");
        
        ConsumptionProfile consumptionProfile = carProfile.getConsumptionProfile();
        double baseConsumption = getBaseConsumption(consumptionProfile, parameters.getEnvironment());
        
        double modeConsumption = baseConsumption * parameters.getEfficiencyMode().getConsumptionFactor();
        
        double terrainFactor = calculateTerrainFactor(parameters.getTerrain());
        double terrainConsumption = modeConsumption * terrainFactor;
        
        double weatherFactor = calculateWeatherFactor(parameters.getWeather(), parameters.getTemperatureCelsius());
        double finalConsumption = terrainConsumption * weatherFactor;
        
        double availableEnergy = carProfile.getBatteryProfile().getRemainingCapacityKwh() *
                (parameters.getStateOfChargePercent() / 100.0);
        double estimatedRange = (availableEnergy * 100.0) / finalConsumption;
        
        String weatherImpact = generateWeatherImpactDescription(parameters.getWeather(), parameters.getTemperatureCelsius());
        String terrainImpact = generateTerrainImpactDescription(parameters.getTerrain());
        String environmentImpact = generateEnvironmentImpactDescription(parameters.getEnvironment());
        String batteryCondition = generateBatteryConditionDescription(parameters.getStateOfChargePercent(), parameters.getTemperatureCelsius());
        
        return new RangeResult(
                estimatedRange,
                finalConsumption,
                weatherImpact,
                terrainImpact,
                environmentImpact,
                batteryCondition
        );
    }
    
    private double getBaseConsumption(ConsumptionProfile profile, DrivingEnvironment environment) {
        return switch(environment) {
            case CITY -> profile.getConsumptionAt50Kmh();
            case RURAL -> profile.getConsumptionAt100Kmh();
            case HIGHWAY -> profile.getConsumptionAt130Kmh();
        };
    }
    
    private double calculateTerrainFactor(TerrainType terrain) {
        return switch(terrain) {
            case FLAT -> 1.0;
            case HILLY -> 1.05;
            case MOUNTAINOUS -> 1.1;
        };
    }
    
    private double calculateWeatherFactor(WeatherType weather, double temperature) {
        double weatherMultiplier = switch(weather) {
            case SUNNY -> 0.9;
            case CLOUDY -> 1.0;
            case RAIN -> 1.2;
            case SNOW -> 1.3;
            case STRONG_WIND -> 1.1;
        };
        
        double tempFactor;
        if (temperature < -10) {
            tempFactor = 1.4;
        } else if (temperature < 0) {
            tempFactor = 1.15;
        } else if (temperature < 10) {
            tempFactor = 1.0;
        } else if (temperature <= 25) {
            tempFactor = 0.9;
        } else if (temperature <= 35) {
            tempFactor = 1.1;
        } else {
            tempFactor = 1.2;
        }
        
        return weatherMultiplier * tempFactor;
    }
    
    private String generateWeatherImpactDescription(WeatherType weather, double temperature) {
        StringBuilder impact = new StringBuilder();
        
        switch(weather) {
            case SUNNY:
                impact.append("Minimal impact -> Ideal weather conditions");
                break;
            case CLOUDY:
                impact.append("Slight impact -> Cloud cover has minimal effect on efficiency");
                break;
            case RAIN:
                impact.append("Moderate impact -> Rain increases rolling resistance");
                break;
            case SNOW:
                impact.append("Severe impact - Snow conditions significantly reduce range");
                break;
            case STRONG_WIND:
                impact.append("Significant impact - Strong winds increase air resistance");
                break;
        }
        
        if (temperature < 0) {
            impact.append(", Cold temperature reduces battery efficiency!");
        } else if (temperature > 30) {
            impact.append(", High temperature requires additional cooling!");
        }
        
        return impact.toString();
    }
    
    private String generateTerrainImpactDescription(TerrainType terrain) {
        return switch(terrain) {
            case FLAT -> "Minimal impact - Flat terrain optimal for efficiency";
            case HILLY -> "Moderate impact - Hills affect energy consumption";
            case MOUNTAINOUS -> "Significant impact - Mountainous terrain substantially increases consumption";
        };
    }
    
    private String generateEnvironmentImpactDescription(DrivingEnvironment environment) {
        return switch(environment) {
            case CITY -> "Stop-and-go traffic at " + environment.getAvgSpeedKmh() + " kmh - Benefits from regenerative braking";
            case RURAL -> "Medium speed driving at " + environment.getAvgSpeedKmh() + " km/h - Moderate air resistance!";
            case HIGHWAY -> "Constant high speed at " + environment.getAvgSpeedKmh() + " km/h - Increased air resistance!";
        };
    }
    
    private String generateBatteryConditionDescription(double soc, double temperature) {
        StringBuilder condition = new StringBuilder();
        
        if (soc > 80) {
            condition.append("High SoC (").append(soc).append("%) -> Optimal operating range.");
        } else if (soc > 40) {
            condition.append("Medium SoC (").append(soc).append("%) -> Good operating range.");
        } else if (soc > 20) {
            condition.append("Low SoC (").append(soc).append("%) - Consider charging soon.");
        } else {
            condition.append("Very low SoC (").append(soc).append("%) - Critical level!!! charge immediately.");
        }
        
        condition.append(", ");
        
        if (temperature < -10) {
            condition.append("Battery temperature tooo cold!!! (").append(temperature).append("°C) -> Severely reduced efficiency");
        } else if (temperature < 0) {
            condition.append("Battery temperature cold (").append(temperature).append("°C) -> Reduced efficiency");
        } else if (temperature < 10) {
            condition.append("Battery temperature cool (").append(temperature).append("°C) -> Slightly reduced efficiency");
        } else if (temperature <= 30) {
            condition.append("Battery temperature optimal (").append(temperature).append("°C) -> Maximum efficiency");
        } else if (temperature <= 40) {
            condition.append("Battery temperature warm (perfectly fine) (").append(temperature).append("°C) -> Slightly reduced efficiency");
        } else {
            condition.append("Battery temperature too hot!!! (").append(temperature).append("°C) - Reduced efficiency! potential for degradation!!!");
        }
        
        return condition.toString();
    }

    @Override
    public String getName() {
        return "Consumption-based Range Calculation";
    }

    @Override
    public String getDescription() {
        return "Calculates range based on the car's consumption profile adjusted for external conditions";
    }
} 

			</code></pre>
						</div>
					</div>
				</section>

				<section>
					<h3>Strategy Pattern: Verwendung im Client</h3>
					<div class="horizontal-spaced-container">
						<div>
							<pre style="width: 1000px; height: 500px; overflow: hidden;"><code class="java">// Client-Klasse, die die Strategien verwendet
public class RangeCalculatorService {
    private final List<RangeCalculationStrategyInterface> strategies;
    private RangeCalculationStrategyInterface defaultStrategy;

    public RangeCalculatorService() {
        this.strategies = new ArrayList<>();
        
        WltpBasedRangeCalculationStrategy wltpStrategy = new WltpBasedRangeCalculationStrategy();
        ConsumptionBasedRangeCalculationStrategy consumptionStrategy = new ConsumptionBasedRangeCalculationStrategy();
        
        this.strategies.add(wltpStrategy);
        this.strategies.add(consumptionStrategy);
        
        this.defaultStrategy = consumptionStrategy;
    }
    
    public void addStrategy(RangeCalculationStrategyInterface strategy) {
        Objects.requireNonNull(strategy, "Strategy cannot be null");
        strategies.add(strategy);
    }
    
    public void setDefaultStrategy(RangeCalculationStrategyInterface strategy) {
        Objects.requireNonNull(strategy, "Strategy cannot be null");
        if (!strategies.contains(strategy)) {
            strategies.add(strategy);
        }
        this.defaultStrategy = strategy;
    }
    
    public List<RangeCalculationStrategyInterface> getAvailableStrategies() {
        return new ArrayList<>(strategies);
    }
    
    public RangeCalculationStrategyInterface getDefaultStrategy() {
        return defaultStrategy;
    }
    
    public RangeResult calculateRange(CarProfile carProfile, RangeParameters parameters) {
        Objects.requireNonNull(carProfile, "Car profile cannot be null");
        Objects.requireNonNull(parameters, "Range parameters cannot be null");
        
        return defaultStrategy.calculateRange(carProfile, parameters);
    }
    
    public RangeResult calculateRangeWithStrategy(CarProfile carProfile, RangeParameters parameters, RangeCalculationStrategyInterface strategy) {
        Objects.requireNonNull(carProfile, "Car profile cannot be null");
        Objects.requireNonNull(parameters, "Range parameters cannot be null");
        Objects.requireNonNull(strategy, "Strategy cannot be null");
        
        return strategy.calculateRange(carProfile, parameters);
    }
} 
</code></pre>
						</div>
					</div>
				</section>

				<section>
					<h4>Strategie Pattern: Vergleich</h4>
					<table style="margin: 0 auto; margin-top: 30px; padding: 0;">
						<thead>
							<tr>
								<th>Aspekt</th>
								<th>ConsumptionBasedRangeCalculationStrategy</th>
								<th>WltpBasedRangeCalculationStrategy</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>Basis für Berechnung</td>
								<td>Verbrauchsprofile des Fahrzeugs bei verschiedenen Geschwindigkeiten (50, 100, 130
									km/h)</td>
								<td>WLTP-Reichweite des Fahrzeugs als Fixwert</td>
							</tr>
							<tr>
								<td>Kalkulation Grundverbrauch</td>
								<td>Basierend auf dem aktuellen Fahrumfeld (DrivingEnvironment) wird ein Verbrauchswert
									(kWh/100km) gewählt</td>
								<td>Es wird ein durchschnittlicher Verbrauch aus der WLTP-Reichweite und
									Batteriekapazität berechnet</td>
							</tr>
							<tr>
								<td>Berücksichtigte Faktoren</td>
								<td>Effizienzmodus, Geländeart, Wetterbedingungen, Temperatur, Batterieladestand</td>
								<td>Effizienzmodus, Geländeart, Wetterbedingungen, Temperatur, Batterieladestand,
									zusätzlich ein Fahrumgebungsfaktor (EnvironmentFactor)</td>
							</tr>
						</tbody>
					</table>
				</section>

				<section>
					<h3>Strategy Pattern: UML-Diagramm</h3>
					<img style="scale: 1.25; margin: 0; padding: 0; margin-top: 50px;"
						src="assets/UMLs-imgs/Kapitel_8-Aufgabe_1.png" alt="Strategy Pattern UML Diagram"
						class="uml-image">
				</section>







				<section>
					<h3>Entwurfsmuster 2: Adapter Pattern (4P)</h3>
					<div class="horizontal-spaced-container">
						<div style="width: 50%;">
							<h4>Überblick</h4>
							<ul>
								<li><b>Art/Kategorie:</b> Strukturmuster (Structural Pattern)</li>
								<li><b>Zweck:</b> Konvertiert die Schnittstelle einer Klasse in eine andere, die vom
									Client erwartet wird</li>
								<li><b>Verwendung:</b> Integration von I/O-Operationen in die Clean Architecture</li>
							</ul>
						</div>
						<div style="width: 50%;">
							<h4>Vorteile</h4>
							<ul>
								<li>Flexibilität durch lose Kopplung</li>
								<li>Einfach zu erweitern</li>
								<li>Trennt Geschäftslogik von externen Ressourcen u. Komponenten</li>
								<li>Ermöglicht Zusammenarbeit nicht-kompatibler Schnittstellen</li>
							</ul>
						</div>
					</div>
				</section>

				<section>
					<h3 style="padding: 0; margin-top: 0;">Entwurfsmuster 2: <br /> Adapter Pattern (Fortsetzung)</h3>
					<div style="width: 100%;">
						<h4 style="margin-top: 50px; padding: 0; margin-bottom: 0;">Nachteile</h4>
						<ul>
							<li>Zusätzliche Komplexität durch zusätzliche Abstraktionsebene</li>
							<li>Möglicher Overhead durch zusätzliche Methodenaufrufe</li>
							<li>Erhöhte Anzahl von Klassen und Interfaces</li>
							<li>Externe können abrupt aufrufen</li>
						</ul>
					</div>
				</section>

				<section>
					<h3>Adapter Pattern: Port-Interfaces</h3>
					<div class="horizontal-spaced-container">
						<div>
							<pre style="width: 1000px; height: 500px; overflow: hidden;"><code class="java">// Port Interface für Benutzereingaben
public interface UserInputPortInterface {
    String readLine();
    int readInt();
    double readDouble();
    boolean readBoolean(String yesOption, String noOption);
    String readStringWithValidation(String prompt, String errorMessage, java.util.function.Predicate<String> validator);
    int readIntInRange(String prompt, int min, int max);
    double readDoubleInRange(String prompt, double min, double max);
}

// Port Interface für Benutzerausgaben
public interface UserOutputPortInterface {
    void display(String message);
    void displayLine(String message);
    void displayPrompt(String prompt);
    void displayError(String errorMessage);
    void displaySuccess(String successMessage);
    void displayWarning(String warningMessage);
    void displayTable(String[] headers, String[][] data);
    void clearScreen();
    void displayProgressBar(int current, int total);
}</code></pre>
						</div>
					</div>
				</section>

				<section>
					<h3>Adapter Pattern: ConsoleUserInputAdapter</h3>
					<div class="horizontal-spaced-container">
						<div>
							<pre style="width: 1000px; height: 500px; overflow: hidden;"><code class="java">
public class ConsoleUserInputAdapter implements UserInputPortInterface {
    private final Scanner scanner;
    
    public ConsoleUserInputAdapter(Scanner scanner) {
        this.scanner = Objects.requireNonNull(scanner, "Scanner cannot be null");
    }
    
    @Override
    public String readLine() {
        return scanner.nextLine();
    }
    
    @Override
    public int readInt() {
        while (true) {
            try {
                return Integer.parseInt(scanner.nextLine());
            } catch (NumberFormatException e) {
                System.out.println("Invalid input. Please enter a valid integer.");
            }
        }
    }
    
    @Override
    public double readDouble() {
        while (true) {
            try {
                return Double.parseDouble(scanner.nextLine());
            } catch (NumberFormatException e) {
                System.out.println("Invalid input. Please enter a valid number.");
            }
        }
    }
    
    @Override
    public boolean readBoolean(String yesOption, String noOption) {
        while (true) {
            String input = scanner.nextLine().toLowerCase();
            if (input.equals(yesOption.toLowerCase())) {
                return true;
            } else if (input.equals(noOption.toLowerCase())) {
                return false;
            }
            System.out.println("Invalid input. Please enter '" + yesOption + "' or '" + noOption + "'.");
        }
    }
    
    @Override
    public String readStringWithValidation(String prompt, String errorMessage, Predicate<String> validator) {
        while (true) {
            System.out.print(prompt);
            String input = scanner.nextLine();
            if (validator.test(input)) {
                return input;
            }
            System.out.println(errorMessage);
        }
    }
    
    @Override
    public int readIntInRange(String prompt, int min, int max) {
        while (true) {
            System.out.print(prompt);
            try {
                int value = Integer.parseInt(scanner.nextLine());
                if (value >= min && value <= max) {
                    return value;
                }
                System.out.println("Please enter a number between " + min + " and " + max);
            } catch (NumberFormatException e) {
                System.out.println("Invalid input. Please enter a valid integer.");
            }
        }
    }
    
    @Override
    public double readDoubleInRange(String prompt, double min, double max) {
        while (true) {
            System.out.print(prompt);
            try {
                double value = Double.parseDouble(scanner.nextLine());
                if (value >= min && value <= max) {
                    return value;
                }
                System.out.println("Please enter a number between " + min + " and " + max);
            } catch (NumberFormatException e) {
                System.out.println("Invalid input. Please enter a valid number.");
            }
        }
    }
}</code></pre>
						</div>
					</div>
				</section>

				<section>
					<h3>Adapter Pattern: ConsoleUserOutputAdapter</h3>
					<div class="horizontal-spaced-container">
						<div>
							<pre style="width: 1000px; height: 500px; overflow: hidden;"><code class="java">
public class ConsoleUserOutputAdapter implements UserOutputPortInterface {
    private static final String ANSI_RESET = "\u001B[0m";
    private static final String ANSI_RED = "\u001B[31m";
    private static final String ANSI_GREEN = "\u001B[32m";
    private static final String ANSI_YELLOW = "\u001B[33m";
    private static final String ANSI_CLEAR = "\033[H\033[2J";
    
    @Override
    public void display(String message) {
        System.out.print(message);
    }
    
    @Override
    public void displayLine(String message) {
        System.out.println(message);
    }
    
    @Override
    public void displayPrompt(String prompt) {
        System.out.print(prompt + ": ");
    }
    
    @Override
    public void displayError(String errorMessage) {
        System.out.println(ANSI_RED + "Error: " + errorMessage + ANSI_RESET);
    }
    
    @Override
    public void displaySuccess(String successMessage) {
        System.out.println(ANSI_GREEN + "Success: " + successMessage + ANSI_RESET);
    }
    
    @Override
    public void displayWarning(String warningMessage) {
        System.out.println(ANSI_YELLOW + "Warning: " + warningMessage + ANSI_RESET);
    }
    
    @Override
    public void displayTable(String[] headers, String[][] data) {
        // Calculate column widths
        int[] columnWidths = new int[headers.length];
        for (int i = 0; i < headers.length; i++) {
            columnWidths[i] = headers[i].length();
            for (String[] row : data) {
                if (row[i].length() > columnWidths[i]) {
                    columnWidths[i] = row[i].length();
                }
            }
        }
        
        // Print headers
        StringBuilder format = new StringBuilder("|");
        for (int width : columnWidths) {
            format.append(" %-").append(width).append("s |");
        }
        format.append("\n");
        
        System.out.println(format.toString().formatted((Object[]) headers));
        
        // Print separator
        System.out.println("-".repeat(Arrays.stream(columnWidths).sum() + headers.length * 3 + 1));
        
        // Print data
        for (String[] row : data) {
            System.out.println(format.toString().formatted((Object[]) row));
        }
    }
    
    @Override
    public void clearScreen() {
        System.out.print(ANSI_CLEAR);
        System.out.flush();
    }
    
    @Override
    public void displayProgressBar(int current, int total) {
        int width = 50;
        int progress = (int) ((double) current / total * width);
        
        StringBuilder bar = new StringBuilder("[");
        for (int i = 0; i < width; i++) {
            if (i < progress) {
                bar.append("=");
            } else {
                bar.append(" ");
            }
        }
        bar.append("] ").append(current).append("/").append(total);
        
        System.out.print("\r" + bar.toString());
        if (current == total) {
            System.out.println();
        }
    }
}</code></pre>
						</div>
					</div>
				</section>

				<section>
					<h3>Adapter Pattern: Verwendung im Controller</h3>
					<div class="horizontal-spaced-container">
						<div>
							<pre style="width: 1000px; height: 500px; overflow: hidden;"><code class="java">
public class RangeCalculationController {
    private final UserInputPortInterface userInputPort;
    private final UserOutputPortInterface userOutputPort;
    private final CalculateRangeUseCaseInterface calculateRangeUseCase;
    
    public RangeCalculationController(
            UserInputPortInterface userInputPort,
            UserOutputPortInterface userOutputPort,
            CalculateRangeUseCaseInterface calculateRangeUseCase) {
        this.userInputPort = Objects.requireNonNull(userInputPort, "UserInputPort cannot be null");
        this.userOutputPort = Objects.requireNonNull(userOutputPort, "UserOutputPort cannot be null");
        this.calculateRangeUseCase = Objects.requireNonNull(calculateRangeUseCase, "CalculateRangeUseCase cannot be null");
    }
    
    public void processRangeCalculation() {
        try {
            // Benutzereingaben über Port sammeln
            userOutputPort.displayPrompt("Enter temperature (°C)");
            double temperature = userInputPort.readDoubleInRange("", -50, 50);
            
            userOutputPort.displayPrompt("Enter state of charge (%)");
            double soc = userInputPort.readDoubleInRange("", 0, 100);
            
            userOutputPort.displayPrompt("Select weather condition (SUNNY, CLOUDY, RAIN, SNOW, STRONG_WIND)");
            WeatherType weather = WeatherType.valueOf(userInputPort.readStringWithValidation(
                "",
                "Invalid weather condition. Please enter one of: SUNNY, CLOUDY, RAIN, SNOW, STRONG_WIND",
                input -> Arrays.stream(WeatherType.values())
                    .map(Enum::name)
                    .anyMatch(name -> name.equalsIgnoreCase(input))
            ).toUpperCase());
            
            userOutputPort.displayPrompt("Select terrain type (FLAT, HILLY, MOUNTAINOUS)");
            TerrainType terrain = TerrainType.valueOf(userInputPort.readStringWithValidation(
                "",
                "Invalid terrain type. Please enter one of: FLAT, HILLY, MOUNTAINOUS",
                input -> Arrays.stream(TerrainType.values())
                    .map(Enum::name)
                    .anyMatch(name -> name.equalsIgnoreCase(input))
            ).toUpperCase());
            
            userOutputPort.displayPrompt("Select driving environment (CITY, RURAL, HIGHWAY)");
            DrivingEnvironment environment = DrivingEnvironment.valueOf(userInputPort.readStringWithValidation(
                "",
                "Invalid driving environment. Please enter one of: CITY, RURAL, HIGHWAY",
                input -> Arrays.stream(DrivingEnvironment.values())
                    .map(Enum::name)
                    .anyMatch(name -> name.equalsIgnoreCase(input))
            ).toUpperCase());
            
            userOutputPort.displayPrompt("Select efficiency mode (NORMAL, ECO, SPORT)");
            EfficiencyMode mode = EfficiencyMode.valueOf(userInputPort.readStringWithValidation(
                "",
                "Invalid efficiency mode. Please enter one of: NORMAL, ECO, SPORT",
                input -> Arrays.stream(EfficiencyMode.values())
                    .map(Enum::name)
                    .anyMatch(name -> name.equalsIgnoreCase(input))
            ).toUpperCase());
            
            // Use Case über Interface ausführen
            RangeParameters parameters = new RangeParameters(
                temperature,
                soc,
                weather,
                terrain,
                environment,
                mode
            );
            
            calculateRangeUseCase.calculateRange(parameters);
            
        } catch (Exception e) {
            userOutputPort.displayError("An error occurred during range calculation: " + e.getMessage());
        }
    }
}</code></pre>
						</div>
					</div>
				</section>

				<section>
					<h3>Adapter Pattern: UML-Diagramm</h3>
					<img style="scale: 1.3" src="assets/UMLs-imgs/Kapitel_8-Aufgabe_2.png"
						alt="Adapter Pattern UML Diagram" class="uml-image">
				</section>
			</section>


		</div>
	</div>

	<script src="dist/reveal.js"></script>
	<script src="plugin/notes/notes.js"></script>
	<script src="plugin/markdown/markdown.js"></script>
	<script src="plugin/highlight/highlight.js"></script>
	<script>
		// Debug logging
		console.log('RevealHighlight plugin:', typeof RevealHighlight);
		console.log('hljs global:', typeof window.hljs);

		// More info about initialization & config:
		// - https://revealjs.com/initialization/
		// - https://revealjs.com/config/
		Reveal.initialize({
			hash: true,
			slideNumber: true,

			// Explicit highlight config
			highlight: {
				highlightOnLoad: true,
				escapeHTML: false
			},

			// Learn about plugins: https://revealjs.com/plugins/
			plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
		});

		// Load all slide content, then initialize highlight.js
		const loadSlidesPromises = [];
		document.querySelectorAll('[data-include]').forEach((section) => {
			const url = section.getAttribute('data-include');
			const promise = fetch(url)
				.then(response => response.text())
				.then(html => {
					section.html = ""
					section.innerHTML = html;
				});
			loadSlidesPromises.push(promise);
		});

		// After all slides are loaded, re-initialize highlight.js
		Promise.all(loadSlidesPromises).then(() => {
			// Force Reveal to update
			Reveal.sync();

			// Try multiple ways to initialize highlighting

			// 1. Through Reveal plugin
			const highlight = Reveal.getPlugin('highlight');
			if (highlight) {
				document.querySelectorAll('code').forEach(block => {
					highlight.highlightBlock(block);
				});
			}

			// 2. Direct hljs initialization if available
			if (window.hljs) {
				window.hljs.configure({
					languages: ['bash', 'javascript', 'html', 'xml', 'css']
				});
				document.querySelectorAll('code.bash, code.hljs.bash').forEach(block => {
					window.hljs.highlightElement(block);
				});
			}
		});
	</script>
</body>

</html>