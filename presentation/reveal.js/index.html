<!doctype html>
<html lang="en" xmlns="http://www.w3.org/1999/html">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>ULRICA - Programmentwurf Protokoll</title>

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/white.css">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/lightfair.css">
</head>
<style>
    code:not(.hljs) {
        font-size: 1.25rem;
    }

    pre {
        border-radius: 5px;
    }

    code {
        border-radius: 5px;
        font-size: 1rem !important;
    }


    /* Syntax highlighting styles similar to the screenshot */
    .hljs-keyword {
        color: blue;
        /* softer green */
        font-weight: 500;
    }

    .hljs-built_in {
        color: rgb(0, 0, 138);
        font-weight: normal;
    }

    .hljs-string {
        color: rgb(0, 167, 206) !important;
        /* softer yellow/orange */
        font-weight: normal;
    }

    .hljs {
        font-size: 1.25rem;
        background: transparent;
        display: inline;
    }

    h1 {
        font-size: 4rem;
    }

    h2 {
        font-size: 3rem;
    }

    h3 {
        font-size: 2.5rem;
    }

    h4 {
        font-size: 2.25rem;
        font-weight: semibold;
    }

    h5 {
        font-size: 2rem;
        font-weight: semibold;
    }

    h6 {
        font-size: 1.6rem;
        font-weight: semibold;
    }

    p {
        font-size: 1.6rem;
    }

    li {
        font-size: 1.6rem;
        margin: 5px 0;
    }

    ul {
        text-align: start;
        align-self: start;
    }

    ol {
        text-align: start;
        align-self: start;
    }

    thead {
        font-size: 1.4rem;
    }

    tr {
        font-size: 1.3rem;
    }

    th {
        font-size: 1.4rem;
    }


    .primary-color {
        color: rgb(0, 167, 206) !important;
    }


    .horizontal-container {
        display: flex;
        gap: 2rem;
        justify-content: center;
    }

    .horizontal-spaced-container {
        display: flex;
        gap: 2rem;
        justify-content: space-evenly;
    }

    .gray {
        color: #808080;
    }

    .slide-number {
        font-size: 16px !important;
        color: #333 !important;
        background-color: rgba(255, 255, 255, 0.7);
        padding: 3px 8px !important;
        border-radius: 10px;
    }

    .chapter-title {
        font-size: 3.5rem;
        margin-bottom: 2rem;
        color: #333;
        text-align: center;
    }

    .uml-image {
        max-width: 90%;
        max-height: 70vh;
        margin: 0 auto;
    }

    .center {
        text-align: center;
    }

    .acronym-letter {
        font-weight: 900;
        font-size: 120%;
    }

    .name-explanation {
        font-size: 2.5rem;
        text-align: center;
        margin: 2rem 0;
    }

    .subchapter {
        color: rgb(179, 177, 195);
        font-size: 1.8rem;
        margin-top: 1rem;
        font-style: italic;
    }
</style>

<body>
    <div class="reveal">
        <div class="slides">
            <section alt="Anfang/Einleitung">
                <h3>Programmentwurf - Protokoll</h3>
                <p class="gray center">zu</p>
                <img style="margin: 50px 0;" src="./assets/imgs/ulrica-blue.png" alt="ULRICA Logo" class="logo">
                <div class="horizontal-container gray">
                    <p>Robin Schwenzfeier</p>
                    <p>-</p>
                    <p>4868455</p>
                    <p>-</p>
                    <p>TINF22B5</p>
                </div>
            </section>
            <!-- Kapitel 1-->
            <section alt="Kapitel 1">
                <section>
                    <h2 class="chapter-title">Kapitel 1:<br /> Einleitung (4P)</h2>
                </section>

                <section>
                    <h3 class="subchapter">Inhalt des Kapitels</h3>
                    <div class="horizontal-spaced-container"
                        style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
                        <div>
                            <h6>1. Übersicht über die Applikation (1P)</h6>
                            <ul>
                                <li>Name und Bedeutung</li>
                                <li>Features und Funktionen</li>
                                <li>Probleme, die sie löst</li>
                            </ul>
                        </div>
                        <div>
                            <h6>2. Starten der Applikation (1P)</h6>
                            <ul>
                                <li>Voraussetzungen</li>
                                <li>Schritte zum Starten</li>
                                <li>Alternative zum Starten</li>
                            </ul>
                        </div>
                        <div>
                            <h6>3. Technischer Überblick (2P)</h6>
                            <ul>
                                <li>Java (JDK 17)</li>
                                <li>Maven</li>
                                <li>JSON & GSON</li>
                                <li>JUnit & JaCoCo</li>
                                <li>Clean Architecture</li>
                            </ul>
                        </div>
                        <div>
                        </div>
                    </div>
                </section>

                <section>
                    <h3>Übersicht über die Applikation (1P)</h3>
                    <p class="subchapter">Was macht die Applikation? Wie
                        funktioniert sie? Welches Problem löst
                        sie/welchen Zweck hat sie?</p>
                </section>

                <section>
                    <h3><strong>ULRICA</strong>: Name erklärt</h3>
                    <p class="subchapter">Ein Acronym.</p>
                    <p class="name-explanation">
                        <span class="acronym-letter primary-color">U</span>niversa<span
                            class="acronym-letter primary-color">L</span>
                        <span class="acronym-letter primary-color">R</span>ange and
                        dest<span class="acronym-letter primary-color">I</span>nation
                        <span class="acronym-letter primary-color">CA</span>lculator
                    </p>
                </section>

                <section>
                    <h3>Features der Applikation</h3>
                    <p class="subchapter">Probleme, die sie löst.</p>
                    <ul>
                        <li><span class="primary-color">1.</span> Erstellt und
                            verwaltet Fahrzeugprofile für
                            Elektrofahrzeuge
                        </li>
                        <li><span class="primary-color">2.</span> Berechnet
                            verbleibende Reichweite von
                            Elektrofahrzeugen
                        </li>
                        <li><span class="primary-color">3. + 4.</span> Berechnet
                            Ladezeiten an DC- und AC-Ladestationen
                        </li>
                        <li><s><span class="primary-color">5.</span> Berechnet und
                                simmuliert eine Route</s></li>
                    </ul>
                </section>

                <section>
                    <h3>Features der Applikation</h3>
                    <div class="horizontal-spaced-container">
                        <div>
                            <h5><span class="primary-color">1.</span>
                                Fahrzeugprofil-Management</h5>
                            <ul>
                                <li>Erstellung, Anzeige und Löschung von
                                    Fahrzeugprofilen
                                </li>
                                <li>Konfiguration von Batteriedaten (Typ, Kapazität,
                                    Degradation, etc.)
                                </li>
                                <li>Definition von Verbrauchsprofilen (bei 50km/h,
                                    100km/h, 130km/h)
                                </li>
                            </ul>
                        </div>
                        <div>
                            <h5><span class="primary-color">2.</span>
                                Reichweitenberechnung</h5>
                            <ul>
                                <li>Strategie-Pattern für verschiedene
                                    Berechnungsmethoden
                                </li>
                                <li>WLTP-basierte Berechnung mit "echten"
                                    Bedingungen
                                </li>
                                <li>Temperatureinflüsse</li>
                                <li>Geländebedingungen</li>
                                <li>etc.</li>
                            </ul>
                        </div>
                    </div>
                </section>

                <section>
                    <h3>Features der Applikation</h3>
                    <div class="horizontal-spaced-container">
                        <div>
                            <h5><span class="primary-color">3.</span> DC (Schnelles)
                                Laden</h5>
                            <ul>
                                <li>SoC-basierte Berechnungen</li>
                                <li>Temperatureinflüsse beim Laden</li>
                                <li>Leistungsreduktion basierend auf
                                    Batteriezustand
                                </li>
                                <li>Detaillierte Ladezeitschätzungen</li>
                                <li>Berücksichtigung von Batterie-Typ</li>
                            </ul>
                        </div>
                        <div>
                            <h5><span class="primary-color">4.</span> AC (Langsames)
                                Laden</h5>
                            <ul>
                                <li>Verschiedene Anschlusstypen (Haushalt, Camping,
                                    Wallbox)
                                </li>
                                <li>Berechnung von Effizienzverlusten</li>
                                <li>Temperatur-Effizenzfaktoren</li>
                                <li>Ladezeitprognosen</li>
                            </ul>
                        </div>
                    </div>
                </section>


                <section>
                    <h3>Starten der Applikation (1P)</h3>
                    <p class="subchapter">Wie startet man die Applikation? Was für
                        Voraussetzungen werden benötigt?
                        Schritt-für-Schritt-Anleitung</p>
                </section>
                <section>
                    <h3>Voraussetzungen:</h3>
                    <ul>
                        <li>Java 17 oder höher</li>
                        <li>Maven</li>
                        <li>Git</li>
                    </ul>
                </section>
                <section>
                    <h3>Schritte zum Starten:</h3>
                    <ol>
                        <li>
                            Repository klonen: <span
                                style="background-color: whitesmoke; padding: 2px; border-radius: 5px;"><span
                                    class="hljs-keyword">git</span> <span class="hljs-built_in">clone</span>
                                https://github.com/mausio/ULRICA</span>
                        </li>
                        <li style="text-align: start;">In Projektverzeichnis
                            wechseln: <span
                                style="background-color: whitesmoke; padding: 2px; border-radius: 5px;"><span
                                    class="hljs-keyword">cd </span>/path/to/ULRICA</span>
                        </li>
                        <li>Projekt kompilieren: <span
                                style="background-color: whitesmoke; padding: 2px; border-radius: 5px;"><span
                                    class="hljs-keyword">mvn</span> <span class="hljs-built_in">clean</span> <span
                                    class="hljs-built_in">compile</span></span>
                        </li>
                        <li>ULRICA starten: <span
                                style="background-color: whitesmoke; padding: 2px; border-radius: 5px;"><span
                                    class="hljs-keyword">mvn</span> <span class="hljs-built_in">exec:java</span>
                                -Dexec.mainClass="org.ulrica.App"</span>
                        </li>
                    </ol>
                </section>
                <section>
                    <h3>Alternative zum Starten:</h3>
                    <ol>
                        <li>JAR-Datei erstellen: <span
                                style="background-color: whitesmoke; padding: 2px; border-radius: 5px;"><span
                                    class="hljs-keyword">mvn</span> <span class="hljs-built_in">clean</span> <span
                                    class="hljs-built_in">package</span></span>
                            <ul>
                                <li>Dieser Befehl kompiliert den Code und erstellt
                                    eine ausführbare JAR-Datei im
                                    Verzeichnis <span>target/</span></li>
                                <li>Die JAR-Datei wird als <span
                                        style="background-color: whitesmoke; padding: 2px; border-radius: 5px;"
                                        class="primary-color">ULRICA-1.0-SNAPSHOT.jar</span>
                                    gespeichert
                                </li>
                            </ul>
                        </li>
                        <li>JAR-Datei ausführen: <span
                                style="background-color: whitesmoke; padding: 2px; border-radius: 5px;"><span
                                    class="hljs-keyword">java</span> <span class="hljs-built_in">-jar</span>
                                target/ULRICA-1.0-SNAPSHOT.jar</span>
                            <ul>
                                <li>Stellt sicher, dass Java 17 oder höher
                                    installiert ist
                                </li>
                                <li>Die JAR-Datei enthält alle notwendigen
                                    Abhängigkeiten
                                </li>
                                <li>Kann auf jedem System mit Java 17+ ausgeführt
                                    werden
                                </li>
                            </ul>
                        </li>
                    </ol>
                </section>

                <section>
                    <h3>Technischer Überblick (2P)</h3>
                    <p class="subchapter">Nennung und Erläuterung der Technologien
                        (z.B. Java, MySQL, …), jeweils
                        Begründung für den Einsatz der Technologien</p>
                </section>
                <section>
                    <h3>Technologien: Überblick</h3>
                    <ul>
                        <li><strong>Java (JDK 17):</strong> Objektorientierte
                            Programmiersprache
                        </li>
                        <li><strong>Maven:</strong> Build-Management-Tool</li>
                        <li><strong>JSON/GSON:</strong> Datenaustauschformat und
                            Java-Bibliothek für Persistenz
                        </li>
                        <li><strong>JUnit 4:</strong> Test-Framework für
                            automatisierten Tests
                        </li>
                        <li><strong>JaCoCo:</strong> Code-Coverage-Tool</li>
                        <li><strong>Github Workflow:</strong>CI/CD Pipeline-Tool mit
                            Maven Build
                        </li>
                    </ul>
                </section>

                <section>
                    <h3>Java (JDK 17)</h3>
                    <div class="horizontal-spaced-container">
                        <div>
                            <h5>Vorteile:</h5>
                            <ul>
                                <li>Plattformunabhängigkeit durch Java Virtual
                                    Machine
                                </li>
                                <li>Starke objektorientierte Programmierung</li>
                                <li>Typ-Sicherheit bei Laufzeit</li>
                                <li>LongTermSupport</li>
                                <li>Umfangreiche Bibliotheken verfügbar -> GSON</li>
                                <li>Ideale Grundlage für Clean Architecture und
                                    Implementierung von Prinzipien
                                </li>
                            </ul>
                        </div>
                        <div>
                            <h5>Alternativen:</h5>
                            <ul>
                                <li><strong>Kotlin</strong>:<br>Eleganter, aber
                                    weniger etabliert (auch nicht erlaubt)
                                </li>
                                <li><strong>Python</strong>: <br>Einfacher, aber
                                    weniger performant und relativ
                                    unbekannt für mich
                                </li>
                                <li><strong>JavaScript</strong>:<br>Mir sehr
                                    bekannt, aber schwierig
                                    Architekturprinzipien zu implementieren (auch
                                    nicht erlaubt)
                                </li>
                            </ul>
                        </div>
                    </div>
                </section>

                <section>
                    <h3>Maven</h3>
                    <div class="horizontal-spaced-container">
                        <div>
                            <h5>Vorteile</h5>
                            <ul>
                                <li>"Plug&Play" für Nutzer:innen</li>
                                <li>Konsistente Projektstruktur</li>
                                <li>Automatisiertes Abhängigkeitsmanagement</li>
                                <li>Standardisierte Build-Lebenszyklen</li>
                                <li>Integration mit JUnit und JaCoCo</li>
                                <li>Plugin-Ökosystem für erweiterte Funktionen</li>
                            </ul>
                        </div>
                        <div>
                            <h5>Konfiguration in ULRICA</h5>
                            <pre><code class="xml">&lt;dependencies&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;junit&lt;/groupId&gt;
		&lt;artifactId&gt;junit&lt;/artifactId&gt;
		&lt;version&gt;4.13.2&lt;/version&gt;
		&lt;scope&gt;test&lt;/scope&gt;
	&lt;/dependency&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;
		&lt;artifactId&gt;gson&lt;/artifactId&gt;
		&lt;version&gt;2.10.1&lt;/version&gt;  
	&lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
                        </div>
                    </div>
                </section>

                <section>
                    <h3>JSON & GSON</h3>
                    <div class="horizontal-spaced-container">
                        <div>
                            <h5>Vorteile</h5>
                            <ul>
                                <li>Leichtgewichtiges Datenformat</li>
                                <li>Für Menschen lesbar und einfach zu bearbeiten
                                </li>
                                <li>Ideal für Konfigurationsdaten, e.g.
                                    Fahrzeugprofile
                                </li>
                                <li>Weit verbreitet und unterstützt</li>
                                <li>GSON bietet einfache Java-Integration</li>
                                <li>TypeAdapter für komplexe Datentypen</li>
                            </ul>
                        </div>
                        <div>
                            <h5>Implementierung</h5>
                            <pre style="width: 500px"><code class="java">public class JsonCarProfileRepository

implements CarProfilePersistencePortInterface { // Implementierung des Persistenz-Ports für Fahrzeugprofile
	private final Gson gson; // Gson-Instanz für JSON-Serialisierung/Deserialisierung
	private final Path filePath; // Pfad zur JSON-Datei

	public JsonCarProfileRepository() {
		this.gson = new GsonBuilder() 
			.setPrettyPrinting() // Formatiert die JSON-Ausgabe lesbar
			.registerTypeAdapterFactory( // Ermöglicht die Serialisierung von Optional-Werten
				new OptionalTypeAdapterFactory())  // Registriert eine Factory zur Unterstützung von "Optional<T>"-Typen
			.create(); // Factory: Entwurfsmuster (Design Pattern) für die Erstellung von bestimmten Objekten
		this.filePath = Paths.get(
			STORAGE_DIR, FILE_NAME); // Definiert den Speicherort der JSON-Datei
	}
	// ...
}
                        </code></pre>
                        </div>
                    </div>
                </section>

                <section>
                    <h3>Test-Framework: JUnit</h3>
                    <div class="horizontal-spaced-container">
                        <div>
                            <h5>Vorteile</h5>
                            <ul>
                                <li>De-facto Standard für Java-Tests</li>
                                <li>Umfangreiche Assertions-Bibliothek</li>
                                <li>Integration mit Build-Tools und JaCoCo</li>
                                <li>Test-getriebene Entwicklung (TDD) wird
                                    unterstützt
                                </li>
                            </ul>
                        </div>
                        <div>
                        </div>
                    </div>
                </section>

                <section>
                    <h3>Code-Coverage: JaCoCo</h3>
                    <p class="subchapter">Fokus auf qualitative Tests u. kritische
                        Komponenten, statt bloßer Maximierung
                    </p>
                    <div class="horizontal-spaced-container">
                        <div>
                            <h5>Vorteile</h5>
                            <ul>
                                <li>Detaillierte Abdeckungsmetriken</li>
                                <li>Integration mit Maven und CI/CD</li>
                                <li>Identifikation von ungetesteten Codebereichen
                                </li>
                                <li>Visualisierung der Testabdeckung</li>
                                <li>Qualitätssicherung während der Entwicklung</li>
                                <li>Motivation zur Erhöhung der Testabdeckung</li>
                            </ul>
                        </div>
                        <div>
                            <h5>Ergebnisse</h5>
                            <ul>
                                <li>Gesamtabdeckung: 47%</li>
                                <li>Domain Layer: 68%</li>
                                <li>Application Layer: 53%</li>
                                <li>Presentation Layer: 42%</li>
                                <li>Infrastructure Layer: 36%</li>
                                <li>Core-Komponenten: 75%</li>
                            </ul>

                        </div>
                    </div>
                </section>

                <section>
                    <h3>Github Workflow</h3>
                    <p class="subchapter">Kontinuierliche Integration und
                        automatische Qualitätssicherung</p>
                    <div class="horizontal-spaced-container">
                        <div>
                            <h5>Vorteile</h5>
                            <ul>
                                <li>Automatisierte Builds bei jedem Commit</li>
                                <li>Kontinuierliche Ausführung der Tests</li>
                                <li>Automatische Code-Coverage-Analyse</li>
                                <li>Codequalitätsmessung mit CLOC</li>
                                <li>E-Mail-Benachrichtigungen über Build-Status</li>
                                <li>Früherkennung von Fehlern und
                                    Qualitätsproblemen
                                </li>
                            </ul>
                        </div>
                        <div>
                            <h5>Implementierung</h5>
                            <pre style="width: 400px"><code class="yaml">name: Java CI with Maven

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3
    
    - name: Set up JDK 17
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'temurin'
    
    - name: Build, test and check coverage
      run: mvn -B verify
    
    - name: Install CLOC
      run: sudo apt-get install -y cloc

    - name: Count Java lines of code
      run: cloc --include-lang=Java ./src/main/java/org/ulrica

    # E-Mail-Benachrichtigung über Ergebnisse
    - name: Send Email with Results
      uses: dawidd6/action-send-mail@v3
      # ...</code></pre>
                        </div>
                    </div>
                </section>

                <!-- <section>
                <h3>Clean Architecture</h3>
                <div class="horizontal-spaced-container">
                    <div>
                        <h5>Vorteile für ULRICA</h5>
                        <ul>
                            <li>Separation of Concerns</li>
                            <li>Unabhängige Domänenlogik</li>
                            <li>Dependency Inversion Principle</li>
                            <li>Testbarkeit durch lose Kopplung</li>
                            <li>Austauschbarkeit von Infrastruktur</li>
                            <li>Strukturierte Codebasis</li>
                        </ul>
                    </div>
                    <div>
                        <h5>Schichten in ULRICA</h5>
                        <ul>
                            <li><strong>Domain:</strong> 3 Packages, 23 Klassen</li>
                            <li><strong>Application:</strong> 3 Packages, 26 Klassen</li>
                            <li><strong>Infrastructure:</strong> 3 Packages, 7 Klassen</li>
                            <li><strong>Presentation:</strong> 3 Packages, 16 Klassen</li>
                        </ul>
                        <p>Details in Kapitel 2: Softwarearchitektur</p>
                    </div>
                </div>
            </section>

            <section>
                <h3>Architekturübersicht</h3>
                <img src="./assets/architecture.png" alt="ULRICA Architecture" style="max-height: 500px;">
                <p>Clean Architecture mit klarer Trennung der Schichten</p>
            </section> -->
            </section>
            <!-- Kapitel 2 -->
            <section alt="Kapitel 2">
                <section>
                    <h2 class="chapter-title">Kapitel 2: <br /> Softwarearchitektur
                        (8P)</h2>
                </section>

                <section>
                    <h3 class="subchapter">Inhalt des Kapitels</h3>
                    <div class="horizontal-spaced-container"
                        style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
                        <div>
                            <h6>1. Gewählte Architektur (4P)</h6>
                            <ul>
                                <li>Clean Architecture</li>
                                <li>Architekturschichten</li>
                                <li>Analyse und Begründung</li>
                                <li>UML der wichtigsten Klassen</li>
                            </ul>
                        </div>
                        <div>
                            <h6>2. Domain Code (1P)</h6>
                            <ul>
                                <li>Definition von Domain Code</li>
                                <li>Code-Beispiel aus ULRICA</li>
                                <li>Analyse der Domain-Schicht</li>
                            </ul>
                        </div>
                        <div>
                            <h6>3. Analyse der Dependency Rule (3P)</h6>
                            <ul>
                                <li>Positives Beispiel</li>
                                <li>Negatives Beispiel</li>
                                <li>UML der Abhängigkeiten</li>
                                <li>Lösungsansätze</li>
                            </ul>
                        </div>
                        <div>
                        </div>
                    </div>
                </section>


                <section>
                    <h3>Gewählte Architektur (4P)</h3>
                    <p class="subchapter">In der Vorlesung wurden
                        Softwarearchitekturen vorgestellt. Welche Architektur
                        wurde davon umgesetzt? Analyse und Begründung inkl. UML der
                        wichtigsten Klassen, sowie
                        Einordnung dieser Klassen in die gewählte Architektur</p>
                </section>

                <section>
                    <h3>Clean Architecture</h3>
                    <div class="horizontal-spaced-container">
                        <ul>
                            <li><b>Application Layer:</b> <br /> Implementiert Use
                                Cases (Interfaces) über Interaktoren
                                und Ports für Kommunikation
                            </li>
                            <li><b>Domain Layer:</b> <br /> Enthält die Entität,
                                Value Objects, Services (z.B.
                                Kalkulation) und Application State
                            </li>
                            <li><b>Infrastructure Layer:</b> <br /> Konkrete
                                Implementierungen von Repositories und
                                Adaptern und Utils
                            </li>
                            <li><b>Presentation Layer:</b> <br /> Steuert die
                                Benutzerinteraktion über Controller und
                                Views und Utils
                            </li>
                        </ul>
                        <pre
                            style="overflow: hidden; height: 580px; width: 700px; position: relative; margin-left: 50px; bottom: 20px; right: 20px;"><code
                            class="">➜  ulrica git:(main) ✗ tree -d
			.
			├── application
			│   ├── port
			│   │   ├── in
			│   │   └── out
			│   ├── service
			│   └── usecase
			├── domain
			│   ├── entity
			│   ├── service
			│   └── valueobject
			├── infrastructure
			│   ├── adapter
			│   ├── persistence
			│   └── util
			└── presentation
				├── controller
				├── util
				└── view

			19 directories
	</code></pre>
                    </div>
                </section>

                <section>
                    <h3>Clean Architecture: UML</h3>
                    <div style="display: flex; flex-direction: column;" class="horizontal-spaced-container">
                        <div>
                            <ul>
                                <li>Domänenlogik ist unabhängig von externen
                                    Frameworks/Bibliotheken
                                </li>
                                <li>Application Layer enthält anwendungsspezifische
                                    Regeln
                                </li>
                                <li>Ports definieren Schnittstellen zwischen
                                    Schichten
                                </li>
                                <li>Adapters verbinden externe Systeme mit inneren
                                    Schichten
                                </li>
                                <li>Abhängigkeiten zeigen immer nach innen</li>
                            </ul>
                        </div>
                        <img style="overflow: scroll; scale: 1.1; justify-self: center; align-self: center;"
                            src="./assets/UMLs-imgs/clean_arch.svg" alt="ULRICA Clean Architecture" class="uml-image">
                    </div>
                </section>

                <section>
                    <div style="display: flex; flex-direction: column; justify-content: space-around; gap: 0;">
                        <img style="margin: 0; padding: 0;" src="assets/UMLs-imgs/2-1-1.png">
                        <img style="margin: 0; padding: 0;" src="assets/UMLs-imgs/2-1-2.png">
                        <img style="margin: 0; padding: 0;" src="assets/UMLs-imgs/2-1-3.png">
                    </div>
                </section>

                <section>
                    <h3>
                        Clean Architecture: <br /> Analyse u. Begründung
                    </h3>
                </section>

                <section>
                    <h3>Domain Layer</h3>
                    <p class="subchapter">Der Domain Layer ist das <strong>Herzstück
                            der Clean Architecture</strong> und
                        enthält die gesamte Geschäftslogik ohne externe
                        Abhängigkeiten</p>
                    <ul>
                        <li><strong>CarProfile</strong> (Entity): Kernentität, die
                            ein Car mit seinen Eigenschaften
                            repräsentiert
                        </li>
                        <li><strong>BatteryProfile</strong> (Value Object):
                            Immutable Objekt, das die
                            Batterieeigenschaften eines Fahrzeugs beschreibt
                        </li>
                        <li><strong>ConsumptionProfile</strong> (Value Object):
                            Kapselt Verbrauchsdaten und
                            Verbrauchfaktoren des Fahrzeugs ab
                        </li>
                        <li><strong>RangeCalculatorService</strong> (Service):
                            Berechnet die Reichweite basierend auf
                            verschiedenen Strategien
                        </li>
                        <li><strong>RangeCalculationStrategyInterface</strong>:
                            Definiert die Schnittstelle für
                            verschiedene Berechnungsalgorithmen
                        </li>
                    </ul>
                </section>

                <section>
                    <h3>Application Layer</h3>
                    <p class="subchapter">Der Application Layer implementiert
                        <strong>Use Cases</strong> und definiert
                        <strong>Ports</strong>. Die Klassen orchestrieren
                        Domänenobjekte, ohne direkten Zugriff auf die
                        Infrastruktur, was dadurch die <strong>Dependency
                            Rule</strong> einhäl
                    </p>
                    <ul>
                        <li><strong>CalculateRangeUseCaseInterface</strong> (Port):
                            Definiert die Schnittstelle für den
                            Anwendungsfall der Reichweitenberechnung
                        </li>
                        <li><strong>CalculateRangeInteractor</strong> (Use Case):
                            Implementiert die Geschäftslogik für
                            die Reichweitenberechnung
                        </li>
                        <li><strong>CarProfilePersistencePortInterface</strong>
                            (Port): Abstrahiert die Datenpersistenz
                            für Fahrzeugprofile
                        </li>
                        <li><strong>NavigationUseCase</strong> (Use Case): Steuert
                            die Navigationslogik und
                            Routenplanung
                        </li>
                    </ul>
                </section>

                <section>
                    <h3>Infrastructure Layer</h3>
                    <p class="subchapter">Der Infrastructure Layer implementiert
                        <strong>konkrete Adapter</strong> für
                        externe Systeme. Diese Klassen sind austauschbar ohne
                        Änderungen an inneren Schichten, was
                        wichtig für e.g. <strong>OCP</strong> wichtig ist.
                    </p>
                    <ul>
                        <li><strong>JsonCarProfileRepository</strong>: Implementiert
                            die Persistenz von Fahrzeugprofilen
                            als JSON-Dateien
                        </li>
                        <li><strong>ConsoleUserInputAdapter</strong>: Verarbeitet
                            Benutzereingaben über die Konsole
                        </li>
                        <li><strong>ConsoleUserOutputAdapter</strong>: Zeigt
                            Ausgaben und Ergebnisse in der Konsole an
                        </li>
                        <li><strong>ValidationUtils</strong>: Hilfsmethoden zur
                            Validierung von Eingabedaten
                        </li>
                    </ul>
                </section>

                <section>
                    <h3>Presentation Layer</h3>
                    <p class="subchapter">Der Presentation Layer kapselt die
                        Benutzerinteraktion. Diese Klassen
                        kommunizieren nur über definierte Schnittstellen mit inneren
                        Schichten, was eine <strong>klare
                            Trennung von UI und Geschäftslogik</strong>
                        gewährleistet</p>
                    <ul>
                        <li><strong>ApplicationControllerWithActionMenu</strong>:
                            Hauptcontroller, der die verschiedenen
                            Aktionen der Anwendung steuert
                        </li>
                        <li><strong>RangeCalculationController</strong>:
                            Spezialisierter Controller für die
                            Reichweitenberechnung
                        </li>
                        <li><strong>ActionMenuView</strong>: Stellt das Hauptmenü
                            der Anwendung dar
                        </li>
                        <li><strong>CarProfileView</strong>: Visualisiert die
                            Fahrzeugprofile und deren Details
                        </li>
                    </ul>
                </section>

                <section>
                    <h3>Domain Code (1P)</h3>
                    <p class="subchapter">Kurze Erläuterung in eigenen Worten, was
                        Domain Code ist – 1 Beispiel im Code
                        zeigen, das bisher noch nicht gezeigt wurde.</p>
                    <ul>
                        <li>Bildet die Fachlogik der Domäne (Geschäftsregeln) ab
                        </li>
                        <li>Modelliert Prozesse, Regeln und Datenstrukturen</li>
                        <li>Unabhängig von externen Systemen (Datenbank, UI,
                            Frameworks,...)
                        </li>
                        <li>Bleibt Stabil bei Änderung (an Technologien)</li>
                        <li>Domäne orientiert (Entity, Valueobject, Aggregate)</li>
                        <li>Bleibt fachlich und ist frei von Presentation- und
                            Persistenzlogik (siehe Domainlayer)
                        </li>
                    </ul>
                </section>

                <section>
                    <h3>Beispiel Domain Code: RangeCalculatorService</h3>
                    <pre><code class="java">public class RangeCalculatorService { // Reichweitenberechnung innerhalb der Domäne
	private final List<RangeCalculationStrategyInterface> strategies; // Hält verschiedene fachliche Berechnungsstrategien
	private RangeCalculationStrategyInterface defaultStrategy; // Definiert, welche Strategie standardmäßig verwendet wird

	public RangeCalculatorService() { // wird direkt mit zwei vordefinierten Strategien gestartet
		this.strategies = new ArrayList<>();
		
		WltpBasedRangeCalculationStrategy wltpStrategy = new WltpBasedRangeCalculationStrategy(); // Strategie basierend auf WLTP-Standard
		ConsumptionBasedRangeCalculationStrategy consumptionStrategy = new ConsumptionBasedRangeCalculationStrategy(); // Strategie basierend auf realem Verbrauch

		this.strategies.add(wltpStrategy); // Beide Strategien werden in die Domain-intern verfügbare Liste aufgenommen
		this.strategies.add(consumptionStrategy);

		this.defaultStrategy = consumptionStrategy; // Standardmäßig wird die Verbrauchsstrategie für Berechnungen genutzt
	}
	
	public void addStrategy(RangeCalculationStrategyInterface strategy) { // neue Strategien werden fachlich verfügbar gemacht
		Objects.requireNonNull(strategy, "Strategy cannot be null"); // Eine Strategie muss immer gültig sein
		strategies.add(strategy); // Neue Strategie wird der Liste hinzugefügt
	}
	
	public void setDefaultStrategy(RangeCalculationStrategyInterface strategy) { // Hier kann eine andere Standardstrategie gesetzt werden
		Objects.requireNonNull(strategy, "Strategy cannot be null"); // Die Strategie darf nicht null sein
		if (!strategies.contains(strategy)) { // Falls sie noch nicht bekannt ist, wird sie aufgenommen
			strategies.add(strategy);
		}
		this.defaultStrategy = strategy; // Danach wird sie als neue Standardstrategie gespeichert
	}
	
	public List<RangeCalculationStrategyInterface> getAvailableStrategies() { // Gibt alle aktuell verfügbaren Strategien der Domäne zurück
		return new ArrayList<>(strategies); // Liefert eine Kopie, damit die interne Liste geschützt bleibt
	}
	
	public RangeCalculationStrategyInterface getDefaultStrategy() { // Gibt die aktuelle Standardstrategie zurück
		return defaultStrategy;
	}
	
	public RangeResult calculateRange(CarProfile carProfile, RangeParameters parameters) { // Berechnet die Reichweite basierend auf dem Fahrzeugprofil und Standardstrategie
		Objects.requireNonNull(carProfile, "Car profile cannot be null"); // Ein Fahrzeugprofil ist zwingend notwendig
		Objects.requireNonNull(parameters, "Range parameters cannot be null"); // Auch die Parameter müssen angegeben sein
		
		return defaultStrategy.calculateRange(carProfile, parameters); // Übergibt die Berechnung an die Standardstrategie
	}
	
	public RangeResult calculateRangeWithStrategy(CarProfile carProfile, RangeParameters parameters, RangeCalculationStrategyInterface strategy) { // Alternativ kann eine konkrete Strategie verwendet werden
		Objects.requireNonNull(carProfile, "Car profile cannot be null"); // Fahrzeugprofil darf nicht fehlen
		Objects.requireNonNull(parameters, "Range parameters cannot be null"); // Parameter dürfen nicht fehlen
		Objects.requireNonNull(strategy, "Strategy cannot be null"); // Auch die Strategie muss vorhanden sein
		
		return strategy.calculateRange(carProfile, parameters); // Übergibt die Berechnung an die angegebene Strategie
	}
}</code></pre>
                </section>

                <section>
                    <h3>Analyse des Domain Codes</h3>
                    <ul>
                        <li>Service kapselt reine Fachlogik zur
                            Reichweitenberechnung
                        </li>
                        <li>Strategien sind fachliche Varianten zur
                            Reichweitenermittlung
                        </li>
                        <li>Keine technische Infrastruktur wie DB, API oder UI
                            enthalten
                        </li>
                        <li>Arbeitet nur mit Domain-spezifischen Typen (CarProfile,
                            RangeParameters)
                        </li>
                        <li>Erweiterbarkeit durch neue Strategien innerhalb der
                            Domäne möglich
                        </li>
                        <li>Berechnungen (calculateRange) folgen direkt fachlichen
                            Regeln
                        </li>
                    </ul>
                </section>

                <section>
                    <h3>Analyse der Dependency Rule (3P)</h3>
                    <p class="subchapter">In der Vorlesung wurde im Rahmen der
                        'Clean Architecture' die s.g. Dependency
                        Rule vorgestellt. Je 1 Klasse zeigen, die die Dependency
                        Rule einhält und 1 Klasse, die die
                        Dependency Rule verletzt; jeweils UML (mind. die betreffende
                        Klasse inkl. der Klassen, die von
                        ihr abhängen bzw. von der sie abhängt) und Analyse der
                        Abhängigkeiten in beide Richtungen (d.h.,
                        von wem hängt die Klasse ab und wer hängt von der Klasse ab)
                        in Bezug auf die Dependency Rule
                    </p>
                </section>


                <section>
                    <h3>Analyse der Dependency Rule </h3>
                    <ul>
                        <li>Die Abhängigkeiten zeigen nur zum Zentrum der
                            Architektur (größtenteils)
                        </li>
                        <li>Innere Schichten (Domain) dürfen nichts über äußere
                            Schichten wissen
                        </li>
                        <li>Äußere Schichten (Infrastruktur) dürfen von inneren
                            abhängen
                        </li>
                        <li>Die Abstraktionen (Interfaces) gehören zur inneren
                            Schicht
                        </li>
                        <li>Die Implementierungen gehören zur äußeren Schicht</li>
                    </ul>
                    <img src="assets/UMLs-imgs/Kapitel_2-Aufgabe_3.png" alt="Dependency Rule UML" class="uml-image">
                </section>

                <section>
                    <h3>Positives Beispiel: CalculateRangeInteractor</h3>
                    <pre><code class="java">public class CalculateRangeInteractor implements CalculateRangeUseCaseInterface {
					
					private final RangeCalculatorService rangeCalculatorService;
					private final RangeCalculationOutputPortInterface outputPort;
					private final ProfileSelectionService profileSelectionService;
					
					public CalculateRangeInteractor(
							RangeCalculatorService rangeCalculatorService,
							RangeCalculationOutputPortInterface outputPort,
							ProfileSelectionService profileSelectionService) {
						this.rangeCalculatorService = Objects.requireNonNull(rangeCalculatorService);
						this.outputPort = Objects.requireNonNull(outputPort);
						this.profileSelectionService = Objects.requireNonNull(profileSelectionService);
					}
					
					@Override
					public void calculateRange(CalculateRangeCommand command) {
						CarProfile profile = profileSelectionService.getSelectedProfile();
						// Weitere Implementierung...
						
						RangeResult result = rangeCalculatorService.calculateRange(profile, parameters);
						outputPort.displayRangeResult(result);
					}
				}</code></pre>
                </section>

                <section>
                    <h3>UML: Positives Beispiel</h3>
                    <img src="assets/UMLs-imgs/Kapitel_2-Aufgabe_3-Dependency_Rule_Positiv.png"
                        alt="Positive Dependency Rule Example UML" class="uml-image">
                </section>

                <section>
                    <h3>Analyse des positiven Beispiels</h3>
                    <ul>
                        <li>Implementiert ein Interface aus der
                            Application-Schicht
                        </li>
                        <li>Abhängigkeiten werden über Konstruktor-Injection
                            bereitgestellt
                        </li>
                        <li>Abhängigkeiten sind alle Interfaces oder
                            Domain-Services
                        </li>
                        <li>Keine Abhängigkeit zu konkreten Implementierungen der
                            äußeren Schichten
                        </li>
                        <li>Ausgabe erfolgt über ein Port-Interface
                            (RangeCalculationOutputPortInterface)
                        </li>
                        <li>Strikte Validierung mit Objects.requireNonNull()</li>
                    </ul>
                </section>

                <section>
                    <h3>Negatives Beispiel: JsonCarProfileRepository</h3>
                    <pre><code class="java">public class JsonCarProfileRepository implements CarProfilePersistencePortInterface {
					private static final String STORAGE_DIR = "data";
					private static final String FILE_NAME = "car_profiles.json";
					private final Gson gson;
					private final Path filePath;
				
					public JsonCarProfileRepository() {
						this.gson = new GsonBuilder()
								.setPrettyPrinting()
								.registerTypeAdapterFactory(new OptionalTypeAdapterFactory())
								.create();
						this.filePath = Paths.get(STORAGE_DIR, FILE_NAME);
						ensureStorageDirectoryExists();
					}
					
					@Override
					public List<CarProfile> findAll() {
						try (FileReader reader = new FileReader(filePath.toFile())) {
							Type listType = new TypeToken<List<CarProfile>>() {}.getType();
							List<CarProfile> profiles = gson.fromJson(reader, listType);
							return profiles != null ? profiles : new ArrayList<>();
						} catch (IOException e) {
							throw new RuntimeException("Failed to read car profiles", e);
						}
					}
				}</code></pre>
                </section>

                <section>
                    <h3>UML: Negatives Beispiel</h3>
                    <img src="assets/UMLs-imgs/Kapitel_2-Aufgabe_3-Dependency_Rule_Negative.png"
                        alt="Negative Dependency Rule Example UML" class="uml-image">
                </section>

                <section>
                    <h3>Analyse des negativen Beispiels</h3>
                    <div class="horizontal-spaced-container">
                        <div>
                            <p>Verstöße gegen die Dependency Rule:</p>
                            <ul>
                                <li>Direkte Abhängigkeit zu externen Bibliotheken
                                    (Gson)
                                </li>
                                <li>Direkter Zugriff auf das Dateisystem (java.io,
                                    java.nio)
                                </li>
                                <li>Hartcodierte Pfade (STORAGE_DIR, FILE_NAME)</li>
                                <li>Ausnahmebehandlung mit generischen Exceptions
                                </li>
                                <li>Direkte Implementierung der Dateioperationen
                                </li>
                            </ul>
                        </div>
                        <div>
                            <p>Verbesserungsvorschlag:</p>
                            <ul>
                                <li>Einführung eines FileStoragePortInterface</li>
                                <li>Auslagerung der JSON-Serialisierung</li>
                                <li>Konfigurierbare Pfade (z.B. über
                                    Umgebungsvariablen)
                                </li>
                                <li>Fachliche Exceptions wie
                                    ProfileNotFoundException
                                </li>
                                <li>Strikte Trennung von Persistenz und
                                    Domänenmodell
                                </li>
                            </ul>
                        </div>
                    </div>
                </section>
            </section>
            <!-- Kapitel 3 -->
            <section alt="Kapitel 3">
                <section>
                    <h2 class="chapter-title">Kapitel 3: <br /> SOLID (8P)</h2>
                </section>

                <section>
                    <h3>SRP – Single Responsibility Principle (3P)</h3>
                    <ul>
                        <li>
                            <p class="subchapter">Jeweils eine Klasse als positives und negatives Beispiel für SRP;
                                <br />
                                jeweils UML und Beschreibung der Aufgabe bzw. der Aufgaben und <br /> möglicher
                                Lösungsweg des
                                Negativ-Beispiels (inkl.
                                UML).
                            </p>
                        </li>
                        <li>
                            <p class="hljs-string" style="font-style: italic">Def.: <br />Jede Klasse sollte genau eine
                                Verantwortlichkeit
                                haben, <br />
                                d.h.
                                einen einzigen
                                Grund
                                für
                                Änderungen.</p>
                        </li>
                    </ul>
                </section>

                <section>
                    <h3>Positives Beispiel: RangeCalculatorService</h3>
                    <div class="horizontal-spaced-container">
                        <ul style="width: 50%">
                            <h6>Verantwortung der Klasse:</h6>
                            <li>Verwaltung von Reichweiten-Berechnungsstrategien</li>
                            <li>Bereitstellung einer einheitlichen Schnittstelle zur Reichweitenberechnung</li>
                            <li>Delegation der Berechnung an die jeweils konfigurierte Strategie</li>
                        </ul>
                        <ul style="width: 50%">
                            <h6>Was die Klasse ausdrücklich <strong>nicht</strong> macht:</h6>
                            <li>Interaktion mit dem Benutzer (Eingaben verarbeiten)</li>
                            <li>Ausgabe oder Darstellung der Ergebnisse</li>
                            <li>Laden oder Speichern von Fahrzeugdaten</li>
                        </ul>
                    </div>
                    <p>Die Klasse erfüllt somit das SRP: Änderungen wären ausschließlich aufgrund interner
                        Strategie-Logik oder Berechnung notwendig – nicht wegen externer Anliegen.</p>
                </section>

                <section>
                    <h3>Positives Beispiel: Code</h3>
                    <pre><code class="java">public class RangeCalculatorService {
    private final List<RangeCalculationStrategyInterface> strategies;
    private RangeCalculationStrategyInterface defaultStrategy;

    public RangeCalculatorService() {
        this.strategies = new ArrayList<>();

        WltpBasedRangeCalculationStrategy wltpStrategy = new WltpBasedRangeCalculationStrategy();
        ConsumptionBasedRangeCalculationStrategy consumptionStrategy = new ConsumptionBasedRangeCalculationStrategy();

        this.strategies.add(wltpStrategy);
        this.strategies.add(consumptionStrategy);

        this.defaultStrategy = consumptionStrategy;
    }

    public void addStrategy(RangeCalculationStrategyInterface strategy) {
        Objects.requireNonNull(strategy, "Strategy cannot be null");
        strategies.add(strategy);
    }

    public void setDefaultStrategy(RangeCalculationStrategyInterface strategy) {
        Objects.requireNonNull(strategy, "Strategy cannot be null");
        if (!strategies.contains(strategy)) {
            strategies.add(strategy);
        }
        this.defaultStrategy = strategy;
    }

    public List<RangeCalculationStrategyInterface> getAvailableStrategies() {
        return new ArrayList<>(strategies);
    }

    public RangeCalculationStrategyInterface getDefaultStrategy() {
        return defaultStrategy;
    }

    public RangeResult calculateRange(CarProfile carProfile, RangeParameters parameters) {
        Objects.requireNonNull(carProfile, "Car profile cannot be null");
        Objects.requireNonNull(parameters, "Range parameters cannot be null");

        return defaultStrategy.calculateRange(carProfile, parameters);
    }

    public RangeResult calculateRangeWithStrategy(CarProfile carProfile, RangeParameters parameters, RangeCalculationStrategyInterface strategy) {
        Objects.requireNonNull(carProfile, "Car profile cannot be null");
        Objects.requireNonNull(parameters, "Range parameters cannot be null");
        Objects.requireNonNull(strategy, "Strategy cannot be null");

        return strategy.calculateRange(carProfile, parameters);
    }
} </code></pre>
                </section>

                <section>
                    <h3>Negatives Beispiel: ApplicationControllerWithActionMenu</h3>
                </section>


                <section>
                    <h3>Negatives Beispiel: Erklärung</h3>
                    <div class="horizontal-spaced-container">
                        <ul>
                            <h6>Verantwortlichkeiten:</h6>
                            <li><b>Navigation:</b> Verwaltet Zustandsübergänge zwischen allen Bildschirmen</li>
                            <li><b>UI-Logik:</b> Verarbeitet Benutzereingaben aus mehreren Menüs</li>
                            <li><b>Profilmanagement:</b> Erstellen, Editieren und Löschen von Fahrzeugprofilen</li>
                            <li><b>View-Management:</b> Interaktion mit zahlreichen Views</li>
                            <li><b>Validierung:</b> Eingabevalidierung und Datensammlung</li>
                        </ul>
                        <ul>
                            <h6>Probleme:</h6>
                            <li>Mehrere Gründe für Änderungen (UI-Änderung, Navigationslogik, Profilmanagement)</li>
                            <li>Schwer testbar (zu viele Abhängigkeiten und komplexe Interaktionen)</li>
                            <li>Verletzt Clean Architecture durch zu enge Kopplung von Verantwortlichkeiten</li>
                            <li>Hohe Komplexität durch zahlreiche Methoden und switch-case Logik</li>
                            <li>Mehr als 300 Zeilen -> Schlechte Lesbarkeit</li>
                        </ul>
                    </div>
                </section>


                <section>
                    <h3>Negatives Beispiel: Code</h3>
                    <pre><code class="java">public class ApplicationControllerWithActionMenu {
    private final CarProfilePersistencePortInterface repository;
    private final NavigationUseCaseInterface navigationUseCase;
    private final ProfileSelectionService profileSelectionService;
    private final UserInputService userInputService;
    private final ActionAvailabilityService actionAvailabilityService;
    
    
    private final ShowWelcomeUseCaseInterface showWelcomeUseCase;
    private final ShowCarProfileMenuUseCaseInterface showCarProfileMenuUseCase;
    private final CreateCarProfileUseCaseInterface createCarProfileUseCase;
    
    
    private final WelcomeView welcomeView;
    private final MainMenuView mainMenuView;
    private final CarProfileView carProfileView;
    
    
    private final UserInputPortInterface userInputPort;
    private final UserOutputPortInterface userOutputPort;
    
    
    private final ActionMenuController actionMenuController;
    
    public ApplicationControllerWithActionMenu(
        UserInputPortInterface userInputPort,
        UserOutputPortInterface userOutputPort,
        CarProfilePersistencePortInterface repository,
        NavigationUseCaseInterface navigationUseCase,
        ProfileSelectionService profileSelectionService,
        ActionAvailabilityService actionAvailabilityService,
        ShowWelcomeUseCaseInterface showWelcomeUseCase,
        ShowCarProfileMenuUseCaseInterface showCarProfileMenuUseCase,
        ShowActionMenuUseCaseInterface showActionMenuUseCase,
        CreateCarProfileUseCaseInterface createCarProfileUseCase,
        ExecuteActionUseCaseInterface executeActionUseCase,
        InputValidationServiceInterface validationService,
        WelcomeView welcomeView, MainMenuView mainMenuView,
        CarProfileView carProfileView) {
    this.userInputPort = userInputPort;
    this.userOutputPort = userOutputPort;
    this.repository = repository;
    this.navigationUseCase = navigationUseCase;
    this.profileSelectionService = profileSelectionService;
    this.actionAvailabilityService = actionAvailabilityService;
    this.showWelcomeUseCase = showWelcomeUseCase;
    this.showCarProfileMenuUseCase = showCarProfileMenuUseCase;
    this.createCarProfileUseCase = createCarProfileUseCase;
    this.welcomeView = welcomeView;
    this.mainMenuView = mainMenuView;
    this.carProfileView = carProfileView;
    this.userInputService = new UserInputService(userInputPort,
                                                    userOutputPort,
                                                    validationService);
    
    this.actionMenuController = new ActionMenuController(userInputPort,
                                                            userOutputPort,
                                                            showActionMenuUseCase,
                                                            executeActionUseCase,
                                                            actionAvailabilityService);
    }
    
    public void processCurrentState() {
    ApplicationState currentState = navigationUseCase.getCurrentState();
    
    switch (currentState) {
        case WELCOME:
        handleWelcome();
        break;
        case MAIN_MENU:
        handleMainMenu();
        break;
        case CAR_PROFILE_MENU:
        handleCarProfileMenu();
        break;
        case CREATE_CAR_PROFILE:
        handleCreateCarProfile();
        break;
        case EDIT_CAR_PROFILE:
        handleEditCarProfile();
        break;
        case DELETE_CAR_PROFILE:
        handleDeleteCarProfile();
        break;
        case ACTION_MENU:
        handleActionMenu();
        break;
        default:
        break;
    }
    }
    
    private void handleWelcome() {
    showWelcomeUseCase.showWelcome(welcomeView);
    navigationUseCase.navigateToMainMenu();
    }
    
    private void handleMainMenu() {
    CarProfile selectedProfile = profileSelectionService.getSelectedProfile();
    
    mainMenuView.showMainMenu();
    if (selectedProfile != null) {
        mainMenuView.showProfileSelected(selectedProfile.getName());
    } else {
        mainMenuView.showNoProfileSelected();
    }
    mainMenuView.showMenuOptions();
    mainMenuView.showPrompt();
    
    int choice = userInputPort.readInt();
    
    switch (choice) {
        case 1:
        navigationUseCase.navigateToCarProfileMenu();
        break;
        case 2:
        if (actionAvailabilityService.areActionsAvailable()) {
            navigationUseCase.navigateToActionMenu();
        } else {
            userOutputPort.displayLine(
                "No car profile selected. Please select a profile first.");
            userInputPort.readLine(); 
        }
        break;
        case 3:
        navigationUseCase.exit();
        break;
        default:
        userOutputPort.displayLine("Invalid choice. Please try again.");
    }
    }
    
    private void handleCarProfileMenu() {
    showCarProfileMenuUseCase.showCarProfileMenu(carProfileView);
    
    int choice = userInputPort.readInt();
    
    switch (choice) {
        case 1:
        viewAllCarProfiles();
        break;
        case 2:
        navigationUseCase.navigateToCreateCarProfile();
        break;
        case 3:
        navigationUseCase.navigateToDeleteCarProfile();
        break;
        case 4:
        navigationUseCase.navigateToEditCarProfile();
        break;
        case 5:
        navigationUseCase.navigateToMainMenu();
        break;
        default:
        userOutputPort.displayLine("Invalid choice. Please try again.");
    }
    }
    
    private void handleActionMenu() {
    actionMenuController.processActionMenu();
    userInputPort.readLine(); 
    navigationUseCase.navigateToMainMenu();
    }
    
    private void viewAllCarProfiles() {
    List<CarProfile> profiles = repository.findAll();
    if (profiles.isEmpty()) {
        carProfileView.showNoProfilesMessage();
        return;
    }
    carProfileView.showAllCarProfiles(profiles);
    
    carProfileView.askToSelectProfile();
    String response = userInputPort.readLine().toLowerCase();
    if (response.equals("yes") || response.equals("y")) {
        selectCarProfile(profiles);
    }
    }
    
    private void selectCarProfile(List<CarProfile> profiles) {
    carProfileView.showProfileSelection(profiles);
    int choice = userInputPort.readInt();
    
    if (choice > 0 && choice <= profiles.size()) {
        CarProfile selectedProfile = profiles.get(choice - 1);
        profileSelectionService.selectProfile(selectedProfile);
        carProfileView.showSelectedProfile(selectedProfile);
    } else {
        carProfileView.showInvalidChoice();
    }
    }
    
    private void handleCreateCarProfile() {
    carProfileView.showCreateProfileHeader();
    
    String name = userInputService.getValidatedTextInput(
        "Enter profile name: ",
        "name");
    String manufacturer = userInputService.getValidatedTextInput(
        "Enter manufacturer: ",
        "manufacturer");
    String model = userInputService.getValidatedTextInput(
        "Enter model: ",
        "model");
    int year = userInputService.getValidatedIntInput(
        "Enter build year: ",
        "year");
    boolean hasHeatPump = userInputService.getBooleanInput(
        "Has heat pump? (yes/no): ");
    double wltpRangeKm = userInputService.getValidatedDoubleInput(
        "Enter WLTP range (km): ",
        "wltp range");
    double maxDcPowerKw = userInputService.getValidatedDoubleInput(
        "Enter maximum DC charging power (kW): ",
        "dc charging power");
    double maxAcPowerKw = userInputService.getValidatedDoubleInput(
        "Enter maximum AC charging power (kW): ",
        "ac charging power");
    
    org.ulrica.domain.valueobject.BatteryType batteryType = userInputService.selectBatteryType();
    double batteryCapacityKwh = userInputService.getValidatedDoubleInput(
        "Enter battery capacity (kWh): ",
        "battery capacity");
    double batteryDegradationPercent = userInputService.getValidatedDoubleInput(
        "Enter current battery degradation (%): ",
        "battery degradation");
    
    carProfileView.showConsumptionProfileSetup();
    
    double consumptionAt50Kmh = userInputService.getValidatedDoubleInput(
        "Enter consumption at 50 km/h (kWh/100km): ",
        "consumption");
    double consumptionAt100Kmh = userInputService.getValidatedDoubleInput(
        "Enter consumption at 100 km/h (kWh/100km): ",
        "consumption");
    double consumptionAt130Kmh = userInputService.getValidatedDoubleInput(
        "Enter consumption at 130 km/h (kWh/100km): ",
        "consumption");
    
    CreateCarProfileUseCaseInterface.CreateCarProfileCommand command = new CreateCarProfileUseCaseInterface.CreateCarProfileCommand(
        name,
        manufacturer,
        model,
        year,
        hasHeatPump,
        wltpRangeKm,
        maxDcPowerKw,
        maxAcPowerKw,
        batteryType.name(),
        batteryCapacityKwh,
        batteryDegradationPercent,
        consumptionAt50Kmh,
        consumptionAt100Kmh,
        consumptionAt130Kmh);
    
    CarProfile carProfile = createCarProfileUseCase.createCarProfile(
        command);
    carProfileView.showProfileCreated(carProfile);
    userInputPort.readLine(); 
    
    navigationUseCase.navigateToCarProfileMenu();
    }
    
    private void handleEditCarProfile() {
    List<CarProfile> profiles = repository.findAll();
    if (profiles.isEmpty()) {
        carProfileView.showNoProfilesMessage();
        navigationUseCase.navigateToCarProfileMenu();
        return;
    }
    
    carProfileView.showAllCarProfiles(profiles);
    int choice = userInputService.getValidatedIntInput(
        "Select profile to edit (1-" + profiles.size() + "): ",
        "profile selection");
    
    if (choice > 0 && choice <= profiles.size()) {
        carProfileView.showEditNotImplemented();         
    } else {
        carProfileView.showInvalidChoice();
    }
    
    navigationUseCase.navigateToCarProfileMenu();
    }
    
    private void handleDeleteCarProfile() {
    List<CarProfile> profiles = repository.findAll();
    if (profiles.isEmpty()) {
        carProfileView.showNoProfilesMessage();
        navigationUseCase.navigateToCarProfileMenu();
        return;
    }
    
    carProfileView.showAllCarProfiles(profiles);
    int choice = userInputService.getValidatedIntInput(
        "Select profile to delete (1-" + profiles.size() + "): ",
        "profile selection");
    
    if (choice > 0 && choice <= profiles.size()) {
        CarProfile profileToDelete = profiles.get(choice - 1);
        repository.delete(profileToDelete.getId());
        carProfileView.showProfileDeleted(profileToDelete);
        
        if (profileSelectionService.getSelectedProfile() != null && profileSelectionService
            .getSelectedProfile()
            .getId()
            .equals(profileToDelete.getId())) {
        profileSelectionService.clearSelection();
        }
    } else {
        carProfileView.showInvalidChoice();
    }
    
    navigationUseCase.navigateToCarProfileMenu();
    }
} 
</code></pre>
                </section>

                <section>
                    <h3>Negatives Beispiel: UML</h3>
                    <img src="assets/UMLs-imgs/SRP_negative.png" alt="Negative SRP Example UML" class="uml-image">
                </section>

                <section>
                    <h3>Negatives Beispiel: <br /> Verbesserungen & UML</h3>
                    <ul>
                        <li>Klare Aufteilung in Verantwortlichkeitsbereiche (Controller, Collector, Views)</li>
                        <li>Stärkere Modularität und Wiederverwendbarkeit</li>
                        <li>Einfacheres Testen durch geringe Kopplung</li>
                        <li>Einheitliche, kohärente Klassenstruktur <br /> -> Verletzt nicht die Clean Architecture mehr
                        </li>
                    </ul>
                    <img src="assets/UMLs-imgs/SRP_refactored.png" alt="Refactored SRP Example UML" class="uml-image">
                </section>



                <section>
                    <h3>Negatives Beispiel: Refactoring</h3>
                    <p>Aufteilung in spezialisierte Controller:</p>
                    <div class="horizontal-spaced-container">
                        <div>
                            <pre style="width: 450px"><code class="java">// Spezialisiert auf Navigation
public class NavigationController {
    private final NavigationUseCaseInterface navigationUseCase;
    private final ActionAvailabilityService actionService;

    public void processMainMenu(int choice) {
        switch (choice) {
        case 1: 
            navigationUseCase.navigateToCarProfileMenu();
            break;
        case 2:
            if (actionService.areActionsAvailable()) {
            navigationUseCase.navigateToActionMenu();
            }
            break;
        // ...
        }
}
}</code></pre>
                        </div>
                        <div>
                            <pre style="width: 450px"><code class="java">// Spezialisiert auf Profilmanagement
public class CarProfileController {
    private final CreateCarProfileUseCaseInterface createUseCase;
    private final CarProfileView carProfileView;

    public CarProfile createCarProfile(CreateCarProfileCommand cmd) {
        CarProfile profile = createUseCase.createCarProfile(cmd);
        carProfileView.showProfileCreated(profile);
        return profile;
    }

    public void showProfiles(List<CarProfile> profiles) {
        carProfileView.showAllCarProfiles(profiles);
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section>
                    <h3>Negatives Beispiel: Refactoring (Fortsetzung)</h3>
                    <div class="horizontal-spaced-container">
                        <div>
                            <pre style="width: 450px"><code class="java">// Spezialisiert auf Eingabesammlung
public class ProfileDataCollector {
    private final UserInputService inputService;

    public CreateCarProfileCommand collectProfileData() {
        String name = inputService.getValidatedTextInput(
            "Enter name: ", "name");
        String manufacturer = inputService.getValidatedTextInput(
            "Enter manufacturer: ", "manufacturer");
        // Weitere Eingabeabfragen...
        
        return new CreateCarProfileCommand(
            name, manufacturer, model, year, 
            hasHeatPump, wltpRange, dcPower,
            acPower, batteryType.name(), capacity,
            degradation, consumption50, 
            consumption100, consumption130);
    }
}</code></pre>
                        </div>
                        <div>
                            <pre style="width: 450px"><code class="java">// Koordinator-Klasse mit weniger Verantwortung
public class ApplicationCoordinator {
    private final NavigationController navController;
    private final CarProfileController profileController;
    private final ProfileDataCollector dataCollector;

    public void processCurrentState(ApplicationState state) {
        switch (state) {
        case CREATE_CAR_PROFILE:
            CreateCarProfileCommand data = 
                dataCollector.collectProfileData();
            profileController.createCarProfile(data);
            navController.navigateToCarProfileMenu();
            break;
        // Weitere vereinfachte Zustandsverarbeitung
        }
    }
}</code></pre>
                        </div>
                    </div>
                </section>


                <section>
                    <h3>OCP - Open Closed Principle (3p)</h3>
                    <p class="subchapter">Jeweils eine Klasse als positives und negatives Beispiel für OCP; jeweils UML
                        und Analyse mit Begründung, warum das OCP erfüllt/nicht erfüllt wurde – falls erfüllt: warum
                        hier sinnvoll/welches Problem gab es? Falls nicht erfüllt: wie könnte man es lösen (inkl. UML)?
                    </p>
                </section>


                <section>
                    <h3>Positives Beispiel: UML & Beschreibung</h3>
                    <ul style="margin-bottom: 0; padding-bottom: 0;">
                        <li>Abstraktion über Interface: RangeCalculationStrategyInterface</li>
                        <li>Neue Strategien können ohne Änderung der Kernlogik hinzugefügt werden</li>
                        <li>Der RangeCalculatorService bleibt unverändert</li>
                        <li>Einfache Erweiterung um neue Berechnungsmethoden</li>
                        <li>Geschlossen für Modifikation: Bestehender Code wird nicht geändert</li>
                    </ul>
                    <img style="scale: 0.8; margin-top: 0; padding-top: 0; position: relative; bottom: 20px;"
                        src="assets/UMLs-imgs/OCP_Positive.png" alt="OCP UML Diagram" class="uml-image">
                </section>

                <section>
                    <h3>Positives Beispiel: Code</h3>
                    <pre><code class="java">// Abstraktion (Interface)
public interface RangeCalculationStrategyInterface {

    RangeResult calculateRange(CarProfile carProfile, RangeParameters parameters);

    String getName();

    String getDescription();
}

// Erste Implementierung
public class WltpBasedRangeCalculationStrategy implements RangeCalculationStrategyInterface {

    @Override
    public RangeResult calculateRange(CarProfile carProfile, RangeParameters parameters) {
        // WLTP-basierte Berechnung...
    }

    @Override
    public String getName() {
        return "WLTP-based Range Calculation";
    }
}

// Zweite Implementierung
public class ConsumptionBasedRangeCalculationStrategy implements RangeCalculationStrategyInterface {

    @Override
    public RangeResult calculateRange(CarProfile carProfile, RangeParameters parameters) {
        // Verbrauchsbasierte Berechnung...
    }

    @Override
    public String getName() {
        return "Consumption-based Range Calculation";
    }
}</code></pre>
                </section>



                <section>
                    <h3>OCP - Negatives Beispiel: AcChargingCalculator</h3>
                </section>

                <section>
                    <h3>OCP – Negatives Beispiel: Erklärung</h3>
                    <div class="horizontal-spaced-container">
                        <ul style="width: 40%;">
                            <h6>Verantwortlichkeiten:</h6>
                            <li><b>Typdefinition:</b> <br /> Verwaltet statische Konstanten für Steckertypen</li>
                            <li><b>Leistungsberechnung:</b> <br /> Bestimmt Ladeleistung abhängig vom Steckertyp</li>
                            <li><b>Bezeichnerlogik:</b> <br /> Liefert Namen abhängig vom Steckertyp</li>
                            <li><b>Effizienzberechnung:</b> <br /> Berechnet Effizienzverluste abhängig vom Steckertyp
                            </li>
                        </ul>
                        <ul style="width: 60%;">
                            <h6>Probleme:</h6>
                            <li>Mehrere <span
                                    style="background-color: whitesmoke; border-radius: 5px;">switch</span>-Anweisungen
                                für dieselbe Entscheidungslogik</li>
                            <li>Verstoß gegen das Open/Closed Principle: Änderungen erfordern Modifikationen an
                                bestehenden Methoden</li>
                            <li>Neue Steckertypen erzwingen Änderungen an mehreren Stellen im Code</li>
                            <li>Hohe Fehleranfälligkeit und schlechtere Testbarkeit</li>
                            <li>Verletzung von DRY (Don't Repeat Yourself)</li>
                        </ul>
                    </div>
                </section>

                <section>
                    <h3>Negatives Beispiel: UML</h3>
                    <img src="assets/UMLs-imgs/OCP_Negative.png" alt="Negative OCP Example UML" class="uml-image">
                </section>


                <section>
                    <h3>OCP – Negatives Beispiel: Code</h3>
                    <pre><code class="java">public class AcChargingCalculator {
    public static final double MIN_BATTERY_TEMPERATURE = -20.0;
    public static final double MAX_BATTERY_TEMPERATURE = 60.0;
    public static final double OPTIMAL_TEMPERATURE_MIN = 15.0;
    public static final double OPTIMAL_TEMPERATURE_MAX = 35.0;
    
    public static final int HOUSEHOLD_SOCKET = 1;
    public static final int CAMPING_SOCKET = 2;
    public static final int WALLBOX = 3;
    
    public static final double HOUSEHOLD_SOCKET_POWER_KW = 2.3;
    public static final double CAMPING_SOCKET_POWER_KW = 3.7;
    public static final double WALLBOX_POWER_KW = 11.0;
    

    public double getConnectorPower(int connectorType) {
        switch (connectorType) {
            case HOUSEHOLD_SOCKET:
                return HOUSEHOLD_SOCKET_POWER_KW;
            case CAMPING_SOCKET:
                return CAMPING_SOCKET_POWER_KW;
            case WALLBOX:
                return WALLBOX_POWER_KW;
            default:
                throw new IllegalArgumentException("Invalid connector type: " + connectorType);
        }
    }
    

    public String getConnectorName(int connectorType) {
        switch (connectorType) {
            case HOUSEHOLD_SOCKET:
                return "Household Socket";
            case CAMPING_SOCKET:
                return "Camping Socket";
            case WALLBOX:
                return "Wallbox";
            default:
                throw new IllegalArgumentException("Invalid connector type: " + connectorType);
        }
    }
    

    public AcChargingResult calculateChargingTime(
            CarProfile carProfile,
            int connectorType,
            double startingSocPercent,
            double targetSocPercent,
            double ambientTemperatureCelsius) {
        
        validateInputParameters(connectorType, startingSocPercent, targetSocPercent, ambientTemperatureCelsius);
        
        BatteryProfile batteryProfile = carProfile.getBatteryProfile();
        
        double remainingCapacityKwh = batteryProfile.getRemainingCapacityKwh();
        double energyToAddKwh = remainingCapacityKwh * (targetSocPercent - startingSocPercent) / 100.0;
        
        double temperatureEfficiency = calculateTemperatureEfficiency(ambientTemperatureCelsius);
        
        double efficiencyLoss = calculateEfficiencyLoss(connectorType);
        
        double connectorPowerKw = getConnectorPower(connectorType);
        double maxAcPowerKw = Math.min(batteryProfile.getMaxAcPowerKw(), carProfile.getMaxAcPowerKw());
        double effectivePowerKw = Math.min(connectorPowerKw, maxAcPowerKw);
        
        effectivePowerKw = effectivePowerKw * (1 - efficiencyLoss) * temperatureEfficiency;
        
        double chargingTimeHours = energyToAddKwh / effectivePowerKw;
        
        return new AcChargingResult(
                chargingTimeHours,
                energyToAddKwh,
                effectivePowerKw,
                efficiencyLoss * 100,
                temperatureEfficiency * 100,
                connectorType
        );
    }
    
    private double calculateTemperatureEfficiency(double ambientTemperatureCelsius) {
        if (ambientTemperatureCelsius < MIN_BATTERY_TEMPERATURE || ambientTemperatureCelsius > MAX_BATTERY_TEMPERATURE) {
            return 0.0;
        }
        
        if (ambientTemperatureCelsius >= OPTIMAL_TEMPERATURE_MIN && ambientTemperatureCelsius <= OPTIMAL_TEMPERATURE_MAX) {
            return 1.0; 
        }
        
        if (ambientTemperatureCelsius < OPTIMAL_TEMPERATURE_MIN) {
            return 0.7 + 0.3 * (ambientTemperatureCelsius - MIN_BATTERY_TEMPERATURE) / (OPTIMAL_TEMPERATURE_MIN - MIN_BATTERY_TEMPERATURE);
        } else {
            return 0.7 + 0.3 * (MAX_BATTERY_TEMPERATURE - ambientTemperatureCelsius) / (MAX_BATTERY_TEMPERATURE - OPTIMAL_TEMPERATURE_MAX);
        }
    }
    
    private double calculateEfficiencyLoss(int connectorType) {
        switch (connectorType) {
            case HOUSEHOLD_SOCKET:
                return 0.1; 
            case CAMPING_SOCKET:
                return 0.07; 
            case WALLBOX:
                return 0.05; 
            default:
                throw new IllegalArgumentException("Invalid connector type: " + connectorType);
        }
    }
    
    private void validateInputParameters(
            int connectorType,
            double startingSocPercent,
            double targetSocPercent,
            double ambientTemperatureCelsius) {
        
        if (connectorType < HOUSEHOLD_SOCKET || connectorType > WALLBOX) {
            throw new IllegalArgumentException("Invalid connector type: " + connectorType);
        }
        
        if (startingSocPercent < 0 || startingSocPercent > 100) {
            throw new IllegalArgumentException("Starting SoC must be between 0 and 100 percent");
        }
        
        if (targetSocPercent < 0 || targetSocPercent > 100) {
            throw new IllegalArgumentException("Target SoC must be between 0 and 100 percent");
        }
        
        if (targetSocPercent <= startingSocPercent) {
            throw new IllegalArgumentException("Target SoC must be greater than starting SoC");
        }
        
        if (ambientTemperatureCelsius < MIN_BATTERY_TEMPERATURE || ambientTemperatureCelsius > MAX_BATTERY_TEMPERATURE) {
            throw new IllegalArgumentException("Ambient temperature must be between " + 
                    MIN_BATTERY_TEMPERATURE + " and " + MAX_BATTERY_TEMPERATURE + " Celsius");
        }
    }
    
    public static class AcChargingResult {
        private final double chargingTimeHours;
        private final double energyRequiredKwh;
        private final double effectiveChargingPowerKw;
        private final double efficiencyLossPercent;
        private final double temperatureEfficiencyPercent;
        private final int connectorType;
        
        public AcChargingResult(
                double chargingTimeHours,
                double energyRequiredKwh,
                double effectiveChargingPowerKw,
                double efficiencyLossPercent,
                double temperatureEfficiencyPercent,
                int connectorType) {
            this.chargingTimeHours = chargingTimeHours;
            this.energyRequiredKwh = energyRequiredKwh;
            this.effectiveChargingPowerKw = effectiveChargingPowerKw;
            this.efficiencyLossPercent = efficiencyLossPercent;
            this.temperatureEfficiencyPercent = temperatureEfficiencyPercent;
            this.connectorType = connectorType;
        }

        public double getChargingTimeHours() {
            return chargingTimeHours;
        }

        public double getEnergyRequiredKwh() {
            return energyRequiredKwh;
        }

        public double getEffectiveChargingPowerKw() {
            return effectiveChargingPowerKw;
        }

        public double getEfficiencyLossPercent() {
            return efficiencyLossPercent;
        }

        public double getTemperatureEfficiencyPercent() {
            return temperatureEfficiencyPercent;
        }

        public int getConnectorType() {
            return connectorType;
        }
    }
} </code></pre>
                </section>

                <section>
                    <h3>Negatives Beispiel: Lösung & UML</h3>
                    <img src="assets/UMLs-imgs/OCP_refactored.png" alt="OCP Refactored UML Diagram" class="uml-image">
                    <p>Lösungsansatz:</p>
                    <ul>
                        <li>Einführung eines Connector-Interfaces und konkreter Implementierungen</li>
                        <li>Registry/Factory zur Verwaltung von Connector-Typen</li>
                        <li>Neue Connector-Typen können ohne Änderung der AcChargingCalculator-Klasse hinzugefügt werden
                        </li>
                    </ul>
                </section>



















                <section>
                    <h3>LSP - Liskov Substitution Principle (2p)</h3>
                    <ul>
                        <li>
                            <p class="subchapter">Jeweils eine Klasse als positives und negatives Beispiel für OCP;
                                jeweils
                                UML und Analyse mit Begründung, warum das OCP erfüllt/nicht erfüllt wurde – falls
                                erfüllt:
                                warum hier sinnvoll/welches Problem gab es? Falls nicht erfüllt: wie könnte man es lösen
                                (inkl. UML)?</p>
                        </li>
                        <li>
                            <p class="hljs-string">Eine abgeleitete Klasse soll an jeder beliebigen Stelle ihre
                                Basisklasse ersetzen
                                können, ohne, dass es zu unerwünschten Nebeneffekten kommt.</p>
                        </li>
                    </ul>
                </section>




                <section>
                    <h3>Positives Beispiel: </h3>
                    <div class="horizontal-spaced-container">
                        <ul style="width: 50%;">
                            <h6>Hält LSP ein:</h6>
                            <li>Die Klasse <code>CreateCarProfileInteractor</code> verwendet ausschließlich das
                                Interface <code>CarProfilePersistencePortInterface</code></li>
                            <li><code>JsonCarProfileRepository</code> implementiert alle Methoden des Interfaces
                                vollständig</li>
                            <li>Das Verhalten bei Methodenaufrufen entspricht exakt dem was durch das Interface
                                definiert wird</li>
                            <li>Die konkrete Implementierung kann jederzeit durch eine andere ersetzt werden, ohne dass
                                das Verhalten des Systems sich ändert.</li>
                        </ul>
                        <ul style="width: 50%;">
                            <h6>Vorteile dadurch:</h6>
                            <li>Ermöglicht sauberes und sicheres Austauschen z.B. der Persistenzlogik</li>
                            <li>Erhöhte Wartbarkeit, da Änderungen in der Infrastruktur keine (Seiten-)Effekte auf die
                                Anwendungsschicht haben</li>
                            <li>Fördert Erweiterbarkeit und Offenheit für neue Anforderungen (Open/Closed-Prinzip).</li>
                            <li>Entkopplung von Infrastruktur und Geschäftslogik führt zu robusterer Architektur.</li>
                        </ul>
                    </div>
                </section>


                <section>
                    <h3>Positives Beispiel: UML</h3>
                    <img src="assets/UMLs-imgs/LSP_Positive.png" alt="LSP UML Diagram" class="uml-image">
                </section>



                <section>
                    <h3>LSP – Negatives Beispiel: Controller Hierarchie</h3>
                </section>

                <section>
                    <h3>LSP – Negatives Beispiel: Probleme</h3>
                    <ul>
                        <li><strong>Keine gemeinsame Basisklasse:</strong> AC- und DC-Controller sind strukturell
                            identisch, aber nicht gemeinsam abstrahiert.</li>
                        <li><strong>Redundanz im Code:</strong> Gleichartige Konstruktoren und Methoden wie
                            <code>Process...Calculation()</code>, aber doppelt implementiert.
                        </li>
                        <li><strong>Verletzung der Austauschbarkeit:</strong> Der <code>ExecuteActionInteractor</code>
                            kann nicht einheitlich mit Controllern arbeiten.</li>
                        <li><strong>Kein Polymorphismus:</strong> Zwingt den Client zur Behandlung jeder
                            Controller-Klasse separat (z. B. mit <code>if</code>-Verzweigungen).</li>
                        <li><strong>Mocks dupliziert:</strong> Separate Mock-Klassen mit nahezu identischem Code.</li>
                    </ul>
                    <p class="hljs-string">Diese Struktur verletzt das Liskov-Substitutionsprinzip, da die Controller
                        nicht polymorph verwendet werden können, obwohl sie die gleiche grundlegende Funktionalität
                        anbieten</p>
                </section>

                <section>
                    <h3>Negatives Beispiel: UML</h3>
                    <img src="assets/UMLs-imgs/LSP_negative.png" alt="Negative LSP Example UML" class="uml-image">
                </section>

                <section>
                    <h3>Negatives Beispiel: Lösung & UML</h3>
                    <ul>
                        <li><strong>Einführung einer gemeinsamen Basisklasse <code>ChargingController</code></strong>
                            mit Methode <code>processChargingCalculation()</code></li>
                        <li><strong>Polymorphismus durch Vererbung:</strong> AC- und DC-Controller erben von dieser
                            Abstraktion und können austauschbar verwendet werden</li>
                        <li><strong>Zentrale Nutzung im Client:</strong> Der <code>ExecuteActionInteractor</code>
                            referenziert nur die Abstraktion, nicht konkrete Typen</li>
                        <li><strong>MockController vereinheitlicht:</strong> Ein <code>MockChargingController</code>
                            ersetzt mehrere spezialisierte Mocks.</li>
                    </ul>
                    <img style="scale: 1.05" src="assets/UMLs-imgs/LSP_refactored.png" alt="LSP Refactored UML Diagram"
                        class="uml-image">
                </section>










            </section>
            <!-- Kapitel 4 -->
            <section alt="Kapitel 4">
                <section>
                    <h2 class="chapter-title">Kapitel 4: <br/> Weitere Prinzipien
                        (8P)</h2>
                </section>

                <section>
                    <h3>Analyse GRASP: Geringe Kopplung (3P)</h3>
                    <p class="subchapter">Eine bis jetzt noch nicht behandelte Klasse als positives Beispiel geringer
                        Kopplung; UML mit zusammenspielenden Klassen, Aufgabenbeschreibung der Klasse und Begründung,
                        warum hier eine geringe Kopplung vorliegt; es müssen auch die Aufrufer/Nutzer der Klasse
                        berücksichtigt werden</p>
                </section>

                <section>
                    <h3>Geringe Kopplung: <br /> AcChargingController</h3>
                    <p style="text-align: justify;">
                        Der <code>AcChargingController</code> koordiniert den Ablauf der AC-Ladeberechnung:
                        Benutzereingaben werden gelesen, die Ladeparameter werden über ein Anwendungs & Use-Case
                        Interface berechnet
                        und die Ergebnisse werden anschließend ausgegeben
                    </p>
                    <p style="text-align: justify;">
                        Die gesamte Kommunikation erfolgt ausschließlich über abstrahierte Schnittstellen
                        (Ports), wodurch der Controller unabhängig von konkreten Implementierungen bleibt.
                    </p>
                </section>


                <section>
                    <h3>Geringe Kopplung: <br /> UML & Erklärung</h3>
                    <ul>
                        <li>Verwendet nur Interfaces (Ports) statt konkreter Klassen</li>
                        <li>Konstruktor-Injections aller Abhängigkeiten (DIP)</li>
                        <li>Strikte Trennung von Steuerung, Ein-/Ausgabe und Fachlogik</li>
                        <li>Keine hardcodierten Abhängigkeiten</li>
                        <li>Alle Abhängigkeiten sind austauschbar und leicht testbar</li>
                    </ul>
                    <img style="scale: 1.1" src="assets/UMLs-imgs/Kapitel_4-Aufgabe_1.png"
                        alt="Geringe Kopplung UML Diagram" class="uml-image" />
                </section>

                <section>
                    <h3>Geringe Kopplung: Aufrufer/Nutzer der Klasse</h3>
                    <p style="text-align: justify;">
                        Der <code>AcChargingController</code> wird durch eine externe Instanz, z. B. durch eine
                        Main-Klasse oder ein Framework-Initializer, instanziiert und diese übergibt die nötigen Ports
                        per Konstruktor (Dependency Injection) und ruft die Methode
                        <code>processChargingCalculation()</code> auf.
                    </p>
                    <p style="text-align: justify;">
                        Somit bleibt der Controller vollständig entkoppelt vom Lebenszyklus und der konkreten
                        Implementierung seiner Abhängigkeiten.
                    </p>
                </section>

                <section>
                    <h3>Geringe Kopplung: <br /> Vorteile der geringen Kopplung</h3>
                    <ul>
                        <li><b>Testbarkeit:</b> Einfaches Mocking der Abhängigkeiten
                            für Unit-Tests
                        </li>
                        <li><b>Wartbarkeit:</b> Änderungen an Implementierungen der
                            Ports haben keinen Einfluss auf den
                            Controller
                        </li>
                        <li><b>Flexibilität:</b> Verschiedene Implementierungen
                            können ohne Änderung am Controller
                            ausgetauscht werden
                        </li>
                        <li><b>Wiederverwendbarkeit:</b> Der Controller kann mit
                            unterschiedlichen Implementierungen
                            genutzt werden
                        </li>
                        <li><b>Verständlichkeit:</b> Klare Verantwortlichkeiten und
                            Abhängigkeiten
                        </li>
                    </ul>
                </section>




                <section>
                    <h3>Analyse GRASP: Polymorphismus (3P)</h3>
                    <p class="subchapter">
                        Eine Klasse als positives Beispiel entweder von Polymorphismus oder von Pure Fabrication; UML
                        Diagramm und Begründung, warum es hier zum Einsatz kommt
                    </p>

                </section>

                <section>
                    <h3 style="margin-bottom: 0; padding-bottom: 0;">RangeCalculationStrategy</h3>
                    <ul style="padding-top: 0; margin-top: 0;">
                        <li><b>Polymorphismus:</b> Verantwortung für das Verhalten wird an ein abstraktes Interface
                            delegiert so dass konkrete Klassen polymorph interagieren können</li>
                        <li><b>Prinzip der Offenheit:</b> System ist offen für neue Strategien, aber geschlossen für
                            Änderungen (OCP).</li>
                        <li><b>Geringe Kopplung:</b> Der aufrufende Code ist nicht abhängig von konkreten
                            Implementierungen, sondern lediglich vom Interface.</li>
                        <li><b>Starke Kohäsion:</b> Jede Strategie kapselt exakt eine konkrete Berechnungslogik.</li>
                    </ul>
                    <img style="scale:1.05" src="assets/UMLs-imgs/Kapitel_4-Aufgabe_2.png"
                        alt="Polymorphismus UML Diagram" class="uml-image" />
                </section>

                <section>
                    <h3>Vorteile des Polymorphismus im Anwendungskontext</h3>
                    <ul>
                        <li><b>Erweiterbarkeit:</b> Neue Strategien können einfach hinzugefügt werden, ohne bestehende
                            Klassen zu verändern.</li>
                        <li><b>Wiederverwendbarkeit:</b> Strategien sind unabhängig voneinander einsetzbar und modular.
                        </li>
                        <li><b>Kapselung:</b> Die Implementierungsdetails der einzelnen Strategien sind vollständig vom
                            aufrufenden Code abgeschirmt.</li>
                        <li><b>Wartbarkeit:</b> Änderungen an einer Strategie beeinflussen keine anderen Klassen, da
                            jede Strategie isoliert ist.</li>
                        <li><b>Testbarkeit:</b> Einzelne Strategien können unabhängig getestet werden, was die
                            Qualitätssicherung vereinfacht.</li>
                        <li><b>Komposition:</b> Die konkrete Strategie kann zur Laufzeit ausgetauscht oder kombiniert
                            werden – ohne Anpassung des Client-Codes.</li>
                    </ul>
                </section>




                <!-- TODO: FEHLT NOCH!!! -->
                <section>
                    <h3>DRY – Don't Repeat Yourself (2P)</h3>
                    <p class="subchapter">Ein Commit angeben, bei dem duplizierter Code/duplizierte Logik aufgelöst wurde; Code-Beispiele (vorher/nachher) einfügen; begründen und Auswirkung beschreiben – ggf. UML zum Verständnis ergänzen</p>
                </section>


                <section>
                    <h3>DRY: CarProfileController</h3>
                    <p>Commit <span style="background-color: whitesmoke; border-radius: 5px; padding: 1px 4px;" class="hljs-string">89f9ea2</span>: <br/> Refactoring von <span style="background-color: whitesmoke; border-radius: 5px; padding: 1px 4px;" class="hljs-string">CarProfileController</span>
                        zur Reduktion der
                        duplizierten Logik
                    </p>
                    <div class="horizontal-spaced-container">
                        <ul style="width: 50%;">
                            <h6>Problem:</h6>
                            <li>Duplizierter Code für ähnliche Operationen</li>
                            <li>Schwer zu erkennendes Muster im Code</li>
                            <li>Business-Logik war mit UI-Logik vermischt</li>
                            <li>Hohe Fehleranfälligkeit bei Änderungen</li>
                            <li>Clean Architecture war nicht erfüllt</li>
                        </ul>
                        <ul style="width: 50%;">
                            <h6>Lösung:</h6>
                            <li>Auslagerung der Business-Logik in einen
                                Service
                            </li>
                            <li>Zusammenfassung ähnlicher Methoden</li>
                            <li>Einführung von Hilfsmethoden für gemeinsame
                                Funktionalität
                            </li>
                            <li>Trennung von UI und Geschäftslogik</li>
                            <li>Folgen von GRASP & SOLID</li>
                        
                        </ul>
                    </div>
                </section>

                <section>
                    <h3>DRY: Altes UML</h3>
                    <img style="scale: 1.1" src="assets/UMLs-imgs/DRY_before.png" alt="DRY Before" />
                </section>

                <section>
                    <h3>DRY – Vorher: Code</h3>
                    <pre><code class="java">public class CarProfileController {
				  private static Scanner scanner;
				  private final LoadingScreenAnimation loadingScreenAnimation;
				  private Thread loadingAnimationThread;
				  private Thread loadingJsonThread;
				  private CarProfileModel carProfile;
				  private ConsumptionProfileModel consumptionProfile;
				  
				  public CarProfileController() throws LoadingException {
					JsonCarProfilesLoader carProfileJsonLoader = SetupService.getCarProfileJsonLoader();
					carProfile = SetupService.getCarProfile();
					consumptionProfile = SetupService.getConsumptionProfile();
					loadingScreenAnimation = SetupService.getLoadingScreenAnimation();
					loadingAnimationThread = new Thread(loadingScreenAnimation);
					loadingJsonThread = new Thread(carProfileJsonLoader);
					scanner = SetupService.getScanner();
					
					System.out.println("Hey! To begin with, let's see if you have any car profiles saved.");
					SleepUtil.waitForFSeconds(1.0);
					
					startLoadingThreads();
					
					SleepUtil.waitForFSeconds(3.0);
					
					stopLoadingThreads();
					
					CarProfileModel[] carProfiles = carProfileJsonLoader.getCarProfiles();
					
					if (carProfiles == null || carProfiles.length <= 1) {
					  System.out.println("→ No car profiles could be found;\n  Continuing with creating a new car profile.");
					  SleepUtil.waitForFSeconds(2.0);
					  createCarProfileDialog();
					} else {
                        howCarProfileSelection();
					}
				  }
				  
				  // Weitere Methoden...
				}</code></pre>
                </section>

                <section>
                    <h3>DRY: Neues UML</h3>
                    <img style="scale: 1" src="assets/UMLs-imgs/DRY_after.png" alt="DRY After" />
                </section>

                <section>
                    <h3>DRY – Nachher: Code</h3>
                    <div class="horizontal-spaced-container">
                        <div>
                            <pre><code class="java">public class CarProfileController {
    public static void startDialog() {
        System.out.println(
            "Hey! To begin with, let's see if you have any car profiles saved.");
        }
        
        public static Double getConsumptionDialog(Scanner scanner) {
        System.out.print("consumption: (in kWh) ");
        String input = scanner.nextLine();
        if (!input.isEmpty()) {
            return Double.valueOf(input);
        }
        return null;
        }
        
        // Weitere UI-Methoden...
    }
    
    


    public class CarProfileService {
        
        private JsonCarProfilesLoader carProfileJsonLoader;
        private CarProfileModel carProfile;
        
        public CarProfileService() throws LoadingException {
        this.carProfileJsonLoader = 
            SetupService.getCarProfileJsonLoader();
        
        // UI-Interaktion über Controller
        CarProfileController.startDialog();
        
        // Laden der Profile
        loadProfiles();
        
        // Weitere Logik...
        }
        
        private void loadProfiles() {
        // Gemeinsame Ladelogik, nicht mehr dupliziert
        CarProfileModel[] profiles = 
            carProfileJsonLoader.getCarProfiles();
        
        if (profiles == null || profiles.length <= 1) {
            createNewProfile();
        } else {
            selectExistingProfile(profiles);
        }
        }
        
        // Weitere Methoden...
    }
// ...

}
</code></pre>
                        </div>
                    </div>
                </section>

                <section>
                    <h3>DRY: Vorteile des Refactorings</h3>
                    <ul>
                        <li><b>Bessere Wartbarkeit:</b> Änderungen an UI oder
                            Logik können unabhängig
                            durchgeführt werden
                        </li>
                        <li><b>Übersichtlichkeit:</b> Kürzere Klassen mit klaren
                            Zuständigkeiten
                        </li>
                        <li><b>Geringere Redundanz:</b> Gemeinsam genutzter Code ist
                            an einer zentralen Stelle definiert
                        </li>
                        <li><b>Bessere Testbarkeit:</b> Service kann unabhängig von
                            UI getestet werden
                        </li>
                        <li><b>Single Responsibility Principle:</b> Klassen haben
                            nur eine Verantwortlichkeit
                        </li>
                        <li><b>Clean Architecture:</b> Klare Trennung der Schichten
                            zwischen Presentation und
                            Application
                        </li>
                    </ul>
                </section>








            </section>
            <!-- Kapitel 5 -->
            <section alt="Kapitel 5">
                <section>
                    <h2 class="chapter-title">Kapitel 5:<br /> Unit Tests (8P)</h2>
                </section>

                <section>
                    <h3>10 Unit Tests (2p)</h3>
                    <p class="subchapter">Zeigen und Beschreiben von 10 Unit-Tests
                        und Beschreibung, was getestet wird
                    </p>
                </section>

                <section>
                    <h3>Unit Tests</h3>
                    <div class="horizontal-spaced-container">
                        <div>
                            <h5>Test-Strategie</h5>
                            <ul>
                                <li>Fokus auf Domain-Logik als kritischen Kern</li>
                                <li>Ignorieren von UI Elementen wie SOUTs</li>
                                <li>ca. 100 automatisierte Tests (JUnit)</li>
                                <li>47% Gesamtabdeckung (laut JaCoCo)</li>
                                <li>Spezielle Tests für Randfälle und
                                    Fehlerbedingungen
                                </li>
                                <li>Mocks für externe Abhängigkeiten</li>
                            </ul>
                        </div>
                        <div>
                            <h5>Testarten in ULRICA</h5>
                            <ul>
                                <li>Unit-Tests für isolierte Klassen</li>
                                <li>Integrationstests für Komponenteninteraktion
                                </li>
                                <li>Parametrisierte Tests für Datenvalidierung</li>
                                <li>Exception-Tests für Fehlerszenarien</li>
                                <li>Stresstest für Berechnung mit großen
                                    Datenmengen
                                </li>
                            </ul>
                        </div>
                    </div>
                </section>

                <section>
                    <h3>Test #1: DC Charging Calculator</h3>
                    <pre><code class="java">@Test
				public void testCalculateChargingTime_WithChargingCurve() {
					// Testwerte definieren
					double startingSoc = 20.0;
					double targetSoc = 80.0;
					double maxStationPower = 250.0;
					double ambientTemperature = 25.0;
					
					// Ladekurve erstellen
					Map<Double, Double> curvePoints = new HashMap<>();
					curvePoints.put(0.0, 150.0);   // 0% SOC -> 150 kW
					curvePoints.put(20.0, 180.0);  // 20% SOC -> 180 kW
					curvePoints.put(50.0, 100.0);  // 50% SOC -> 100 kW
					curvePoints.put(80.0, 50.0);   // 80% SOC -> 50 kW
					curvePoints.put(100.0, 10.0);  // 100% SOC -> 10 kW
					ChargingCurve chargingCurve = new ChargingCurve(curvePoints);
					
					// Car mit Ladekurve erstellen
					CarProfile carWithCurve = new CarProfile.Builder()
						.id("test-id-curve")
						.name("Test EV with Curve")
						.manufacturer("Test Manufacturer")
						.model("Test Model")
						.year(2023)
						.hasHeatPump(true)
						.wltpRangeKm(500)
						.maxDcPowerKw(250.0)
						.maxAcPowerKw(11.0)
						.batteryProfile(batteryProfile)
						.consumptionProfile(consumptionProfile)
						.chargingCurve(chargingCurve)
						.build();
					
					// Service-Methode aufrufen
					DcChargingResult result = calculator.calculateChargingTime(
						carWithCurve, 
						startingSoc, 
						targetSoc, 
						maxStationPower, 
						ambientTemperature
					);
					
					// Validierung der berechneten Werte
					double expectedEnergyToAdd = batteryProfile.getRemainingCapacityKwh() * 0.6;
					assertEquals(expectedEnergyToAdd, result.getEnergyToAddKwh(), 0.01);
					assertTrue(result.getChargingTimeHours() > 0);
					assertTrue(result.getEffectivePowerKw() > 0);
				}</code></pre>
                    <p>Testet komplexe Ladeberechnungen mit dynamischer Ladekurve
                        und verschiedenen SOC-Bereichen</p>
                </section>

                <section>
                    <h3>Test #2: Range Calculator Service - Strategy Pattern</h3>
                    <pre><code class="java">@Test
				public void testAddStrategy() {
					// Ausgangssituation dokumentieren
					int initialCount = rangeCalculatorService.getAvailableStrategies().size();
					
					// Mock-Strategie erstellen 
					RangeCalculationStrategyInterface mockStrategy = new RangeCalculationStrategyInterface() {
						@Override
						public RangeResult calculateRange(CarProfile carProfile, RangeParameters params) {
							return new RangeResult(
								300.0, 
								20.0,  
								"No weather impact",
								"No terrain impact",
								"No environment impact",
								"Battery in good condition"
							);
						}
						
						@Override
						public String getName() {
							return "MockStrategy";
						}
						
						@Override
						public String getDescription() {
							return "A mock strategy for testing";
						}
					};
					
					// Strategie hinzufügen
					rangeCalculatorService.addStrategy(mockStrategy);
					
					// Validierung: Strategien-Anzahl ist um 1 erhöht
					assertEquals(initialCount + 1, rangeCalculatorService.getAvailableStrategies().size());
				}</code></pre>
                    <p>Testet die dynamische Erweiterbarkeit durch das
                        Strategy-Pattern im RangeCalculatorService</p>
                </section>

                <section>
                    <h3>Test #3: ChargingCurve Interpolation</h3>
                    <pre><code class="java">@Test
				public void testGetChargingPowerAt_Interpolation() {
					// Testdaten mit drei Kurven-Punkten erstellen
					Map<Double, Double> curvePoints = new HashMap<>();
					curvePoints.put(0.0, 150.0);    // 0% -> 150 kW
					curvePoints.put(50.0, 100.0);   // 50% -> 100 kW
					curvePoints.put(100.0, 10.0);   // 100% -> 10 kW
					ChargingCurve chargingCurve = new ChargingCurve(curvePoints);
					
					// Test der linearen Interpolation zwischen Punkten
					
					// Test Punkt zwischen 0% und 50%
					assertEquals(125.0, chargingCurve.getChargingPowerAt(25.0), 0.001);
					
					// Test Punkt zwischen 50% und 100%
					assertEquals(55.0, chargingCurve.getChargingPowerAt(75.0), 0.001);
				}</code></pre>
                    <p>Testet die korrekte lineare Interpolation bei der Ladekurve
                        zwischen definierten Punkten</p>
                </section>

                <section>
                    <h3>Test #4: ExecuteAction - Komplexe UI-Interaktion</h3>
                    <pre><code class="java">@Test
				public void testExecuteAction_NoProfileSelected() {
					// Profil-Auswahl leeren
					profileSelectionService.clearSelection();
					
					// Action ausführen (DC-Ladung starten)
					boolean result = executeActionInteractor.executeAction(1);
					
					// Validieren des erwarteten Verhaltens
					assertFalse(result);
					assertEquals(1, actionResultView.getErrorCount());
					assertEquals(0, actionResultView.getSuccessCount());
					assertEquals(0, dcChargingController.getProcessCallCount());
					assertEquals(0, acChargingController.getProcessCallCount());
					assertEquals(0, rangeCalculationController.getProcessCallCount());
					assertTrue(actionResultView.lastErrorContains("No car profile selected"));
				}</code></pre>
                    <p>Testet das komplexe Zusammenspiel zwischen UI-Controller,
                        Views und Geschäftslogik mit
                        Mock-Objekten</p>
                </section>

                <section>
                    <h3>Test #5: DC Charging - Temperatureinfluss</h3>
                    <pre><code class="java">@Test
				public void testCalculateChargingTime_LowTemperature() {
					// Kalte Umgebungstemperatur als Testbedingung
					double startingSoc = 20.0;
					double targetSoc = 60.0;
					double maxStationPower = 250.0;
					double ambientTemperature = -10.0; // Sehr kalter Tag
					
					// Service-Methode mit Testwerten aufrufen
					DcChargingResult result = calculator.calculateChargingTime(
						mockCarProfile, 
						startingSoc, 
						targetSoc, 
						maxStationPower, 
						ambientTemperature
					);
					
					// Temperatureinfluss auf Batterie validieren
					double expectedBatteryTemp = ambientTemperature + 5.9;
					assertEquals(expectedBatteryTemp, result.getEndTemperatureCelsius(), 0.01);
					
					// Leistungsreduktion aufgrund der Temperatur validieren
					assertTrue("Bei kalter Temperatur sollte Ladeleistung reduziert sein", 
						result.getEffectivePowerKw() < maxStationPower);
					assertTrue("Bei kalten Temperaturen sollte Ladezeit länger sein", 
						result.getChargingTimeHours() > 0.5);
				}</code></pre>
                    <p>Testet die realistische Simulation von Temperatureinflüssen
                        auf das Ladeverhalten</p>
                </section>

                <section>
                    <h3>Test #6: Validierung der Eingabeparameter</h3>
                    <pre><code class="java">@Test
				public void testValidateInputParameters_InvalidTargetSoc() {
					// Ungültiger SOC-Wert (über 100%)
					double startingSoc = 20.0;
					double invalidTargetSoc = 110.0;
					
					// Service-Methode aufrufen mit Erwartung auf Exception
					assertThrows(IllegalArgumentException.class, () -> {
						calculator.calculateChargingTime(
							mockCarProfile, 
							startingSoc, 
							invalidTargetSoc, 
							250.0, 
							25.0
						);
					});
				}
				
				@Test
				public void testValidateInputParameters_TargetLessThanStarting() {
					// Fehlerhafter Case: Ziel-SOC niedriger als Start-SOC
					double startingSoc = 80.0;
					double targetSoc = 70.0; 
					
					// Validierung dass die API korrekterweise eine Exception wirft
					assertThrows(IllegalArgumentException.class, () -> {
						calculator.calculateChargingTime(
							mockCarProfile, 
							startingSoc, 
							targetSoc, 
							250.0, 
							25.0
						);
					});
				}</code></pre>
                    <p>Testet die robuste Validierung von Eingabeparametern in der
                        Domain-Logik</p>
                </section>

                <section>
                    <h3>Test #7: DI mit Mock-Objekten</h3>
                    <pre><code class="java">@Test
				public void testExecuteAction_DcCharging() {
					// Setup mit Mock-Objekten und Dependency Injection
					profileSelectionService.selectProfile(testProfile);
					dcChargingController.setProcessDcChargingResult(true);
					
					// Aktion ausführen
					boolean result = executeActionInteractor.executeAction(1);
					
					// Validieren des Verhaltens und der Interaktionen
					assertTrue(result);
					assertEquals(0, actionResultView.getErrorCount());
					assertEquals(1, dcChargingController.getProcessCallCount());
					assertEquals(0, acChargingController.getProcessCallCount());
					assertEquals(0, rangeCalculationController.getProcessCallCount());
				}</code></pre>
                    <p>Testet die korrekte Implementierung von Dependency Injection
                        und das Zusammenspiel von
                        Komponenten</p>
                </section>

                <section>
                    <h3>Test #8: ChargingCurve - Robustheit</h3>
                    <pre><code class="java">@Test
				public void testInvalidConstructorArguments() {
					// Test mit null-Wert
					assertThrows(IllegalArgumentException.class, () -> {
						new ChargingCurve(null);
					});
					
					// Test mit leerer Map
					assertThrows(IllegalArgumentException.class, () -> {
						new ChargingCurve(new HashMap<>());
					});
					
					// Test mit fehlenden Schlüsselpunkten
					Map<Double, Double> incompletePoints = new HashMap<>();
					incompletePoints.put(50.0, 100.0);
					assertThrows(IllegalArgumentException.class, () -> {
						new ChargingCurve(incompletePoints);
					});
				}</code></pre>
                    <p>Testet die Robustheit und Fehlerbehandlung bei ungültigen
                        Eingabedaten</p>
                </section>

                <section>
                    <h3>Test #9: ProfileSelectionService - Statusverwaltung</h3>
                    <pre><code class="java">@Test
				public void testProfileSelection() {
					// Initial kein Profil ausgewählt
					assertFalse(profileSelectionService.hasSelectedProfile());
					
					// Profil auswählen
					CarProfile testProfile = new CarProfile.Builder()
						.id("test-id")
						.name("Test Car")
						.build();
					profileSelectionService.selectProfile(testProfile);
					
					// Status und ausgewähltes Profil validieren
					assertTrue(profileSelectionService.hasSelectedProfile());
					assertEquals(testProfile, profileSelectionService.getSelectedProfile());
					
					// Auswahl zurücksetzen
					profileSelectionService.clearSelection();
					
					// Validieren dass kein Profil mehr ausgewählt ist
					assertFalse(profileSelectionService.hasSelectedProfile());
					assertThrows(IllegalStateException.class, () -> {
						profileSelectionService.getSelectedProfile();
					});
				}</code></pre>
                    <p>Testet die korrekte Statusverwaltung und Fehlerfälle im
                        ProfileSelectionService</p>
                </section>

                <section>
                    <h3>Test #10: Validierung von Value Objects</h3>
                    <pre><code class="java">@Test
				public void testValueObjectValidation() {
					// Gültige Werte
					BatteryProfile validProfile = new BatteryProfile(
						BatteryType.LFP, 
						80.0,         // Kapazität in kWh
						5.0,          // Degradation in Prozent
						150.0,        // Max DC Ladeleistung
						11.0          // Max AC Ladeleistung
					);
					
					// Eigenschaften validieren
					assertEquals(BatteryType.LFP, validProfile.getType());
					assertEquals(80.0, validProfile.getCapacityKwh(), 0.001);
					assertEquals(5.0, validProfile.getDegradationPercent(), 0.001);
					assertEquals(76.0, validProfile.getRemainingCapacityKwh(), 0.001); // 80 - 5%
					
					// Ungültige Werte
					assertThrows(IllegalArgumentException.class, () -> {
						new BatteryProfile(
							BatteryType.LFP, 
							-10.0,      // Negative Kapazität
							5.0, 
							150.0, 
							11.0
						);
					});
					
					assertThrows(IllegalArgumentException.class, () -> {
						new BatteryProfile(
							BatteryType.LFP, 
							80.0, 
							110.0,      // Degradation > 100%
							150.0, 
							11.0
						);
					});
				}</code></pre>
                    <p>Testet die Validierung und Fehlerbehandlung bei der
                        Erstellung von Value Objects</p>
                </section>


                <section>
                    <h3>ATRIP: Automatic, Thorough und Professional (2P)</h3>
                    <p class="subchapter">je Begründung/Erläuterung, wie
                        'Automatic', 'Thorough' und 'Professional'
                        realisiert wurde – bei
                        'Thorough' zusätzlich Analyse und Bewertung zur
                        Testabdeckung]</p>
                </section>


                <section>
                    <h3>ATRIP: Automatic</h3>
                    <div class="horizontal-spaced-container">
                        <div>
                            <h5>Automatisierung durch CI/CD</h5>
                            <ul>
                                <li>GitHub Actions Workflow für automatische
                                    Builds
                                </li>
                                <li>Automatische Testausführung bei jedem Push/PR
                                </li>
                                <li>Maven-basierte Build-Pipeline</li>
                                <li>Automatische Code-Coverage-Analyse mit JaCoCo
                                </li>
                                <li>Automatische E-Mail-Benachrichtigungen über
                                    Testergebnisse
                                </li>
                            </ul>
                        </div>
                        <div>
                            <h5>Automatische Test-Tools</h5>
                            <ul>
                                <li>JUnit 4 für Unit Tests</li>
                                <li>Maven Surefire für Testausführung</li>
                                <li>CLOC für automatische Code-Analyse</li>
                                <li>Automatische Validierung von Eingabeparametern
                                </li>
                                <li>Selbstvalidierung von Value Objects</li>
                            </ul>
                        </div>
                    </div>
                </section>

                <section>
                    <h3>ATRIP: Thorough</h3>
                    <div class="horizontal-spaced-container">
                        <div>
                            <h5>Testabdeckung (Coverage)</h5>
                            <ul>
                                <li>Gesamtabdeckung: 47%</li>
                                <li>Domain Layer: 68%</li>
                                <li>Application Layer: 53%</li>
                                <li>Presentation Layer: 42%</li>
                                <li>Infrastructure Layer: 36%</li>
                                <li>Core-Komponenten: 75%</li>
                            </ul>
                        </div>
                        <div>
                            <h5>Testarten</h5>
                            <ul>
                                <li>Unit Tests für isolierte Komponenten</li>
                                <li>Integrationstests für Zusammenspiel</li>
                                <li>Parametrisierte Tests für Randfälle</li>
                                <li>Exception Tests für Fehlerszenarien</li>
                                <li>Mock-Tests für externe Abhängigkeiten</li>
                            </ul>
                        </div>
                    </div>
                </section>

                <section>
                    <h3>ATRIP: Professional</h3>
                    <div class="horizontal-spaced-container">
                        <div>
                            <h5>Testorganisation</h5>
                            <ul>
                                <li>Klare Teststruktur nach Clean Architecture</li>
                                <li>Aussagekräftige Testbenennungen</li>
                                <li>Separation of Concerns in Tests</li>
                                <li>Wiederverwendbare Test-Utilities</li>
                                <li>Dokumentierte Testfälle</li>
                            </ul>
                        </div>
                        <div>
                            <h5>Best Practices</h5>
                            <ul>
                                <li>Arrange-Act-Assert Pattern</li>
                                <li>Given-When-Then Struktur</li>
                                <li>Isolierte Testumgebungen</li>
                                <li>Deterministische Tests</li>
                                <li>Keine Test-Abhängigkeiten</li>
                            </ul>
                        </div>
                    </div>
                </section>

                <section>
                    <h3>Kleines Add-On zu ATRP: Mails</h3>
                    <div style="display: flex; flex-direction: row; justify-content: space-evenly;">
                        <img src="./assets/imgs/Screenshot 2025-04-27 at 12.41.23.jpeg"
                            style="height: 580px; margin: 0; border-radius: 20px;" />
                        <div style="display: flex; flex-direction: column; justify-content: space-between;">
                            <img src="./assets/imgs/IMG_1931.PNG"
                                style="height: 280px; margin: 0; border-radius: 20px;" />
                            <img src="./assets/imgs/IMG_1932.PNG"
                                style="height: 280px; margin: 0; border-radius: 20px;" />
                        </div>
                    </div>
                </section>


                <section>
                    <h3>Fakes und Mocks (4P)</h3>
                    <p class="subchapter">Analyse und Begründung des Einsatzes von 2
                        Fake/Mock-Objekten (die Fake/Mocks
                        sind ohne
                        Dritthersteller-Bibliothek/Framework zu implementieren);
                        zusätzlich jeweils UML Diagramm mit
                        Beziehungen zwischen Mock, zu mockender Klasse und Aufrufer
                        des Mocks</p>
                </section>

                <section>
                    <h3>Mock #1: MockProfileSelectionService</h3>
                    <h5 style="margin-top: 20px; text-align: start;">Zweck,
                        Funktionalität & Implementierung</h5>
                    <ul>
                        <li>Wird in Tests für Profilauswahl verwendet</li>
                        <li>Simuliert die Auswahl eines Fahrzeugprofils ohne echte
                            Persistenz
                        </li>
                        <li>Erlaubt gezielte Testszenarien für Abbruchbedingungen
                        </li>
                        <li>Trackt Aufrufe via Zählermethoden</li>
                        <li>Implementiert das Interface <code>ProfileSelectionService</code>
                        </li>
                        <li>Erweitert um test-spezifische Hilfsmethoden</li>
                    </ul>
                    <h5 style="margin-top: 20px; text-align: start;">Kritik
                        vorab:</h5>
                    <ul>
                        <li>Keine Validierung der Profilobjekte</li>
                        <li>Kein Event-System für Änderungen → eingeschränkte
                            Integrationstest-Fähigkeit
                        </li>
                    </ul>
                </section>

                <section>
                    <h3>Mock #1: Code</h3>
                    <pre><code class="java">public class MockProfileSelectionService implements ProfileSelectionService {
    
    private CarProfile selectedProfile;
    private int selectionCount = 0;
    private int clearCount = 0;
    
    public MockProfileSelectionService() {
        this.selectedProfile = null;
    }
    
    public MockProfileSelectionService(CarProfile initialProfile) {
        this.selectedProfile = initialProfile;
    }

    @Override
    public CarProfile getSelectedProfile() {
        return selectedProfile;
    }

    @Override
    public void selectProfile(CarProfile profile) {
        this.selectedProfile = profile;
        this.selectionCount++;
    }

    @Override
    public void clearSelection() {
        this.selectedProfile = null;
        this.clearCount++;
    }
    
    public int getSelectionCount() {
        return selectionCount;
    }
    
    public int getClearCount() {
        return clearCount;
    }
    
    public boolean hasSelectedProfile() {
        return selectedProfile != null;
    }
} 
</code></pre>
                </section>


                <section>
                    <h3 style="margin-bottom: 0; padding-bottom: 0;">Mock #1:
                        UML-Diagramm</h3>
                    <img style="scale: 0.7; position: relative; bottom: 30px; margin-top: 0; padding-top: 0;"
                        src="assets/UMLs-imgs/mock1.png" alt="Mock Profile Selection Service UML" class="uml-image">
                </section>


                <section>
                    <h3>Mock #2: MockUserInputAdapter</h3>
                    <h5 style="margin-top: 20px; text-align: start;">Funktionen &
                        Implementierung:</h5>
                    <ul>
                        <li>Unterstützt verschiedene Eingabetypen</li>
                        <li>Ermöglicht vordefinierte Eingabesequenzen</li>
                        <li>Ermöglicht deterministische Testszenarien</li>
                        <li>Ersetzt Benutzereingabe zur UI-Interaktion</li>
                        <li>Bietet Fallback-Werte für leere Eingaben</li>
                        <li>Implementiert <code>UserInputPortInterface</code></li>
                    </ul>
                    <h5 style="margin-top: 20px; text-align: start;">Kritik
                        vorab:</h5>
                    <ul>
                        <li>Komplexität für einfache Tests relativ hoch</li>
                        <li>Fehlendes Verhalten bei Fehleingaben (z.B.
                            Exceptionhandling)
                        </li>
                    </ul>
                </section>

                <section>
                    <h3>Mock #2: Code</h3>
                    <pre><code class="java">
public class MockUserInputAdapter implements UserInputPortInterface {
	
	private final Queue<String> stringInputs = new ArrayDeque<>();
	private final Queue<Integer> intInputs = new ArrayDeque<>();
	private final Queue<Double> doubleInputs = new ArrayDeque<>();
	private final Queue<Boolean> booleanInputs = new ArrayDeque<>();
	
	private String defaultStringInput = "";
	private int defaultIntInput = 0;
	private double defaultDoubleInput = 0.0;
	private boolean defaultBooleanInput = false;
	
	public void addStringInput(String input) {
		stringInputs.add(input);
	}
	
	public void addStringInputs(String... inputs) {
		for (String input : inputs) {
			stringInputs.add(input);
		}
	}
	
	public void addIntInput(int input) {
		intInputs.add(input);
	}
	
	public void addIntInputs(int... inputs) {
		for (int input : inputs) {
			intInputs.add(input);
		}
	}
	
	public void addDoubleInput(double input) {
		doubleInputs.add(input);
	}
	
	public void addDoubleInputs(double... inputs) {
		for (double input : inputs) {
			doubleInputs.add(input);
		}
	}
	
	public void addBooleanInput(boolean input) {
		booleanInputs.add(input);
	}
	
	public void addBooleanInputs(boolean... inputs) {
		for (boolean input : inputs) {
			booleanInputs.add(input);
		}
	}

	@Override
	public String readLine() {
		return stringInputs.isEmpty() ? defaultStringInput : stringInputs.poll();
	}

	@Override
	public int readInt() {
		return intInputs.isEmpty() ? defaultIntInput : intInputs.poll();
	}

	@Override
	public double readDouble() {
		return doubleInputs.isEmpty() ? defaultDoubleInput : doubleInputs.poll();
	}
	
	@Override
	public boolean readBoolean(String yesOption, String noOption) {
		return booleanInputs.isEmpty() ? defaultBooleanInput : booleanInputs.poll();
	}
	
	public void setDefaultStringInput(String defaultInput) {
		this.defaultStringInput = defaultInput;
	}
	
	public void setDefaultIntInput(int defaultInput) {
		this.defaultIntInput = defaultInput;
	}
	
	public void setDefaultDoubleInput(double defaultInput) {
		this.defaultDoubleInput = defaultInput;
	}
	
	public void setDefaultBooleanInput(boolean defaultInput) {
		this.defaultBooleanInput = defaultInput;
	}
	
	public boolean hasStringInputs() {
		return !stringInputs.isEmpty();
	}
	
	public boolean hasIntInputs() {
		return !intInputs.isEmpty();
	}
	
	public boolean hasDoubleInputs() {
		return !doubleInputs.isEmpty();
	}
	
	public boolean hasBooleanInputs() {
		return !booleanInputs.isEmpty();
	}
	
	public void clearInputs() {
		stringInputs.clear();
		intInputs.clear();
		doubleInputs.clear();
		booleanInputs.clear();
	}
} 
					</code></pre>
                </section>

                <section>
                    <h3>Mock #2: UML</h3>
                    <img style="scale: 0.8;" src="assets/UMLs-imgs/mock2.png" alt="Mock User Input Adapter UML"
                        class="uml-image">
                </section>

                <section>
                    <h3>Vergleich der Mock-Implementierungen</h3>
                    <table>
                        <thead>
                            <tr>
                                <th>Aspekt</th>
                                <th>MockProfileSelectionService</th>
                                <th>MockUserInputAdapter</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Zweck</td>
                                <td>Verhaltensverifikation (Methodenzähler)</td>
                                <td>Simulation von Eingabesequenzen</td>
                            </tr>
                            <tr>
                                <td>Komplexität</td>
                                <td>Niedrig (Status basiert)</td>
                                <td>Hoch (Typ-Queue-Handling)</td>
                            </tr>
                            <tr>
                                <td>Architektur-Schicht</td>
                                <td>Application / Domain</td>
                                <td>Infrastructure</td>
                            </tr>
                            <tr>
                                <td>Kritik</td>
                                <td>Keine Validierung, keine Events</td>
                                <td>Kein Fehlerverhalten, hoher Overhead</td>
                            </tr>
                        </tbody>
                    </table>
                </section>
            </section>
            <!-- Kapitel 6 -->
            <section alt="Kapitel 6">
                <section>
                    <h2 class="chapter-title">Kapitel 6: <br /> Domain Driven Design
                     (8P)</h2>
                </section>

                <section>
                    <h3 style="margin-bottom: 20px;" class="subchapter">Inhalt des
                        Kapitels</h3>
                    <div class="horizontal-spaced-container"
                        style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
                        <div>
                            <h6>1. Ubiquitous Language (2P)</h6>
                            <ul>
                                <li>4 Beispiele für die Ubiquitous Language</li>
                                <li>Bezeichnung und Bedeutung</li>
                                <li>Begründung der Zugehörigkeit</li>
                            </ul>
                        </div>
                        <div>
                            <h6>2. Repositories (1.5P)</h6>
                            <ul>
                                <li>Beschreibung des Repositories</li>
                                <li>Code</li>
                                <li>UML-Diagramm</li>
                                <li>Begründung & Vorteile des Einsatzes</li>
                            </ul>
                        </div>
                        <div>
                            <h6>3. Aggregates (1.5P)</h6>
                            <ul>
                                <li>Beschreibung des Aggregates</li>
                                <li>Code</li>
                                <li>UML-Diagramm</li>
                                <li>Begründung & Vorteile des Einsatzes</li>
                            </ul>
                        </div>
                        <div>
                            <h6>4. Entities & Value Objects (1.5p + 1.5p)</h6>
                            <ul>
                                <li>Beschreibung der Komponenten</li>
                                <li>Code</li>
                                <li>UML-Diagramme</li>
                                <li>Begründung & Vorteile des Einsatzes</li>
                            </ul>
                        </div>
                    </div>
                </section>


                <section>
                    <h3>Ubiquitous Language (2p)</h3>
                    <p class="subchapter">Vier Beispiele für die Ubiquitous
                        Language; jeweils Bezeichnung, Bedeutung und
                        kurze Begründung, warum es zur Ubiquitous Language
                        gehört</p>
                </section>

                <section>
                    <h3>Ubiquitous Language</h3>
                    <table>
                        <thead>
                            <tr>
                                <th>Begriff</th>
                                <th>Bedeutung</th>
                                <th>Verwendung</th>
                                <th>Ubiquitous Language</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><b>SoC (State of Charge)</b></td>
                                <td>Prozentualer Ladezustand der Batterie (0-100%)</td>
                                <td>Parameter für Reichweitenberechnung und Ladezeit
                                </td>
                                <td>Fachbegriff aus dem E-Mobility-Bereich, der die
                                    gemeinsame Sprache zwischen
                                    Technikern und Anwendern bildet
                                </td>
                            </tr>
                            <tr>
                                <td><b>WLTP-Range</b></td>
                                <td>Standardisierte Reichweite nach <span
                                        style="font-style: italic; background-color: whitesmoke; border-radius: 5px; padding: 1px 2px;">Worldwide
                                        Harmonized Light Vehicles Test Procedure</span>
                                </td>
                                <td>Basis für realistische Reichweitenberechnung</td>
                                <td>Regulatorischer Begriff, der eine einheitliche
                                    Verständnisgrundlage für
                                    Fahrzeugleistung bietet
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </section>

                <section>
                    <h3>Ubiquitous Language (Fortsetzung)</h3>
                    <table>
                        <thead>
                            <tr>
                                <th>Begriff</th>
                                <th>Bedeutung</th>
                                <th>Verwendung</th>
                                <th>Ubiquitous Language</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><b>Charging Curve</b></td>
                                <td>Verlauf der Ladeleistung in Abhängig vom SoC</td>
                                <td>Berechnung von Ladezeiten an DC-Ladestationen</td>
                                <td>Technisches Konzept, das sowohl für Entwickler als
                                    auch Benutzer die
                                    Ladeeigenschaften beschreibt
                                </td>
                            </tr>
                            <tr>
                                <td><b>Battery Type (LFP, NMC, NCA)</b></td>
                                <td>Chemische Zusammensetzung der Batterie
                                    (Lithium-Eisenphosphat, Nickel-Mangan-Cobalt,
                                    Nickel-Cobalt-Aluminium)
                                </td>
                                <td>Berechnung von Degradation und Ladegeschwindigkeit
                                </td>
                                <td>Chemische Klassifikation, die technische
                                    Eigenschaften für das gesamte Team
                                    eindeutig kommunizierbar macht
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </section>

                <section>
                    <h3>Repositories (1.5P)</h3>
                    <p class="subchapter">UML, Beschreibung und Begründung des
                        Einsatzes eines Repositories; falls kein
                        Repository vorhanden: ausführliche Begründung, warum es
                        keines geben kann/hier nicht sinnvoll
                        ist – NICHT, warum es nicht implementiert wurde</p>
                </section>

                <section>
                    <h3>Repository: <br /> CarProfileRepository</h3>
                    <div class="horizontal-spaced-container">
                        <div>
                            <ul>
                                <li>Persistenz von Fahrzeugprofilen ohne Offenlegung
                                    der Speichermechanismen
                                </li>
                                <li>Domain Entities können unabhängig von der
                                    Persistenz modelliert werden
                                </li>
                                <li>Unterstützt die "Illusion" einer <span
                                        style="font-style: italic;">In-Memory-Sammlung</span>
                                </li>
                                <li>Ermöglicht einfachen Austausch der
                                    Persistenztechnologie im Falle von Refactoring
                                </li>
                            </ul>
                        </div>
                    </div>
                </section>

                <section>
                    <h3>Repository: Code</h3>
                    <div>
                        <pre style="width: 900px; height: 500px; overflow: hidden;"><code
                                class="java"> //CarProfileInterface
public interface CarProfilePersistencePortInterface {
    Optional<CarProfile> findById(String id);
    List<CarProfile> findAll();
    CarProfile save(CarProfile carProfile);
    void delete(String id);
} 
	
// Implementation
public class JsonCarProfileRepository implements CarProfilePersistencePortInterface {
    private static final String STORAGE_DIR = "data";
    private static final String FILE_NAME = "car_profiles.json";
    private final Gson gson;
    private final Path filePath;

    public JsonCarProfileRepository() {
        this(STORAGE_DIR, FILE_NAME);
    }
    
    protected JsonCarProfileRepository(String storageDir, String fileName) {
        this.gson = new GsonBuilder()
                .setPrettyPrinting()
                .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())
                .create();
        this.filePath = Paths.get(storageDir, fileName);
        ensureStorageDirectoryExists();
    }

    private void ensureStorageDirectoryExists() {
        try {
            Files.createDirectories(filePath.getParent());
            if (!Files.exists(filePath)) {
                Files.createFile(filePath);
                saveProfiles(new ArrayList<>());
            }
        } catch (IOException e) {
            throw new RuntimeException("Failed to initialize storage", e);
        }
    }

    @Override
    public Optional<CarProfile> findById(String id) {
        return findAll().stream()
                .filter(profile -> profile.getId().equals(id))
                .findFirst();
    }

    @Override
    public List<CarProfile> findAll() {
        try (FileReader reader = new FileReader(filePath.toFile())) {
            Type listType = new TypeToken<List<CarProfile>>() {}.getType();
            List<CarProfile> profiles = gson.fromJson(reader, listType);
            return profiles != null ? profiles : new ArrayList<>();
        } catch (IOException e) {
            throw new RuntimeException("Failed to read car profiles", e);
        }
    }

    @Override
    public CarProfile save(CarProfile carProfile) {
        List<CarProfile> profiles = findAll();
        
        
        boolean found = false;
        for (int i = 0; i < profiles.size(); i++) {
            if (profiles.get(i).getId().equals(carProfile.getId())) {
                profiles.set(i, carProfile);
                found = true;
                break;
            }
        }
        
        if (!found) {
            profiles.add(carProfile);
        }
        
        saveProfiles(profiles);
        return carProfile;
    }

    @Override
    public void delete(String id) {
        List<CarProfile> profiles = findAll();
        profiles.removeIf(profile -> profile.getId().equals(id));
        saveProfiles(profiles);
    }

    private void saveProfiles(List<CarProfile> profiles) {
        try (FileWriter writer = new FileWriter(filePath.toFile())) {
            gson.toJson(profiles, writer);
        } catch (IOException e) {
            throw new RuntimeException("Failed to save car profiles", e);
        }
    }
}</code></pre>
                    </div>
                </section>

                <section>
                    <h3>Repository: UML</h3>
                    <div>
                        <img src="assets/UMLs-imgs/Kapitel_6-Aufgabe_2.png" alt="Repository Pattern UML Diagram"
                            class="uml-image">
                    </div>
                </section>

                <section>
                    <h3>Repository: <br /> Begründung & Vorteile</h3>
                    <ul>
                        <li>Klare Trennung zwischen Domänenlogik und
                            Persistenzmechanismus
                        </li>
                        <li>Vereinfachung des Domain Model durch Abstraktion der
                            Persistenz
                        </li>
                        <li>Ermöglicht die Anwendung von Clean Architecture
                            Prinzipien
                        </li>
                        <li>Erleichtert das Testen durch Mocking der
                            Repository-Implementierung
                        </li>
                        <li>Entscheidung für Datenspeicherung in JSON-Dateien bleibt
                            flexibel änderbar
                        </li>
                    </ul>
                </section>

                <section>
                    <h3>Aggregates (1.5p)</h3>
                    <p class="subchapter">UML, Beschreibung und Begründung des
                        Einsatzes eines Aggregates; falls kein
                        Aggregate vorhanden: ausführliche Begründung, warum es
                        keines geben kann/hier nicht sinnvoll ist
                        – NICHT, warum es nicht implementiert wurde</p>
                </section>

                <section>
                    <h3>Aggregates: <br /> CarProfile Aggregate Root</h3>
                    <ul>
                        <li>Koordiniert mehrere Value Objects (BatteryProfile,
                            ConsumptionProfile,
                            ChargingCurve)
                        </li>
                        <li>Stellt die Konsistenz zwischen den Value Objects
                            sicher
                        </li>
                        <li>Bildet eine sogenannte "transaktionale Einheit" für
                            Änderungen
                        </li>
                        <li>Einziger Zugriffspunkt für enthaltene Value Objects</li>
                        <li>Hat eine eigene Identität (ID) (-> Aggregate Root)</li>
                    </ul>
                </section>

                <section>
                    <h3>Aggregates: Code</h3>
                    <pre style="width: 900px; height: 500px; overflow: hidden;"><code
                        class="java">public class CarProfile {
	private final String id;
	private final String name;
	private final String manufacturer;
	private final String model;
	private final int year;
	private final boolean hasHeatPump;
	private final double wltpRangeKm;
	private final double maxDcPowerKw;
	private final double maxAcPowerKw;
	private final BatteryProfile batteryProfile;
	private final ConsumptionProfile consumptionProfile;
	private final Optional<ChargingCurve> chargingCurve;

	private CarProfile(Builder builder) {
		this.id = builder.id;
		this.name = Objects.requireNonNull(builder.name, "Name cannot be null");
		this.manufacturer = Objects.requireNonNull(builder.manufacturer, "Manufacturer cannot be null");
		this.model = Objects.requireNonNull(builder.model, "Model cannot be null");
		this.year = builder.year;
		this.hasHeatPump = builder.hasHeatPump;
		this.wltpRangeKm = builder.wltpRangeKm;
		this.maxDcPowerKw = builder.maxDcPowerKw;
		this.maxAcPowerKw = builder.maxAcPowerKw;
		this.batteryProfile = Objects.requireNonNull(builder.batteryProfile, "Battery profile cannot be null");
		this.consumptionProfile = Objects.requireNonNull(builder.consumptionProfile, "Consumption profile cannot be null");
		this.chargingCurve = Optional.ofNullable(builder.chargingCurve);
	}


	@Override
	public boolean equals(Object o) {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;
		CarProfile that = (CarProfile) o;
		return year == that.year &&
				hasHeatPump == that.hasHeatPump &&
				Double.compare(that.wltpRangeKm, wltpRangeKm) == 0 &&
				Double.compare(that.maxDcPowerKw, maxDcPowerKw) == 0 &&
				Double.compare(that.maxAcPowerKw, maxAcPowerKw) == 0 &&
				Objects.equals(id, that.id) &&
				Objects.equals(name, that.name) &&
				Objects.equals(manufacturer, that.manufacturer) &&
				Objects.equals(model, that.model) &&
				Objects.equals(batteryProfile, that.batteryProfile) &&
				Objects.equals(consumptionProfile, that.consumptionProfile) &&
				Objects.equals(chargingCurve, that.chargingCurve);
	}

	@Override
	public int hashCode() {
		return Objects.hash(id, name, manufacturer, model, year, hasHeatPump, wltpRangeKm, maxDcPowerKw, maxAcPowerKw, batteryProfile, consumptionProfile, chargingCurve);
	}

	@Override
	public String toString() {
		return "Car Profile: Test EV, Manufacturer: Test Manufacturer, " +
				"Model: Test Model, Year: 2023, Heat Pump: Yes, " +
				"WLTP Range: 500.0 km, Max DC Power: 250.0 kW, Max AC Power: 11.0 kW";
	}

	public static class Builder {
		private String id;
		private String name;
		private String manufacturer;
		private String model;
		private int year;
		private boolean hasHeatPump;
		private double wltpRangeKm;
		private double maxDcPowerKw;
		private double maxAcPowerKw;
		private BatteryProfile batteryProfile;
		private ConsumptionProfile consumptionProfile;
		private ChargingCurve chargingCurve;

		public Builder id(String id) {
			this.id = id;
			return this;
		}

		public Builder name(String name) {
			this.name = name;
			return this;
		}

		public Builder manufacturer(String manufacturer) {
			this.manufacturer = manufacturer;
			return this;
		}

		public Builder model(String model) {
			this.model = model;
			return this;
		}

		public Builder year(int year) {
			this.year = year;
			return this;
		}

		public Builder hasHeatPump(boolean hasHeatPump) {
			this.hasHeatPump = hasHeatPump;
			return this;
		}

		public Builder wltpRangeKm(double wltpRangeKm) {
			this.wltpRangeKm = wltpRangeKm;
			return this;
		}

		public Builder maxDcPowerKw(double maxDcPowerKw) {
			this.maxDcPowerKw = maxDcPowerKw;
			return this;
		}

		public Builder maxAcPowerKw(double maxAcPowerKw) {
			this.maxAcPowerKw = maxAcPowerKw;
			return this;
		}

		public Builder batteryProfile(BatteryProfile batteryProfile) {
			this.batteryProfile = batteryProfile;
			return this;
		}

		public Builder consumptionProfile(ConsumptionProfile consumptionProfile) {
			this.consumptionProfile = consumptionProfile;
			return this;
		}

		public Builder chargingCurve(ChargingCurve chargingCurve) {
			this.chargingCurve = chargingCurve;
			return this;
		}

		public CarProfile build() {
			if (this.id == null) {
				this.id = generateUniqueId();
			}
			return new CarProfile(this);
		}
		
		private String generateUniqueId() {
			return java.util.UUID.randomUUID().toString();
		}

		
	}

	public String getId() {
		return id;
	}

	public String getName() {
		return name;
	}

	public String getManufacturer() {
		return manufacturer;
	}

	public String getModel() {
		return model;
	}

	public int getYear() {
		return year;
	}

	public boolean hasHeatPump() {
		return hasHeatPump;
	}

	public double getWltpRangeKm() {
		return wltpRangeKm;
	}

	public double getMaxDcPowerKw() {
		return maxDcPowerKw;
	}

	public double getMaxAcPowerKw() {
		return maxAcPowerKw;
	}

	public BatteryProfile getBatteryProfile() {
		return batteryProfile;
	}

	public ConsumptionProfile getConsumptionProfile() {
		return consumptionProfile;
	}

	public Optional<ChargingCurve> getChargingCurve() {
		return chargingCurve;
	}
} 

</code></pre>
                </section>

                <section>
                    <h3>Aggregate: UML</h3>
                    <div class="horizontal-spaced-container">
                        <div>
                            <img src="assets/UMLs-imgs/Kapitel_6-Aufgabe_3.png" alt="Aggregate Pattern UML Diagram"
                                class="uml-image">
                        </div>
                </section>

                <section>
                    <h3>Aggregates: Vorteile & Begründung</h3>
                    <ul>
                        <li>CarProfile als Aggregate Root koordiniert die Konsistenz
                            seiner Value Objects
                        </li>
                        <li>Stellt sicher, dass BatteryProfile, ConsumptionProfile
                            und ChargingCurve immer konsistent
                            sind
                        </li>
                        <li>Vereinfacht die Persistenz, da nur der Aggregate Root
                            direkt gespeichert werden muss
                        </li>
                        <li>Schützt die Value Objects vor unerlaubten Änderungen von
                            außen
                        </li>
                        <li>Modelliert die natürliche Gruppierung von Fahrzeugdaten
                            und deren Komponenten
                        </li>
                    </ul>
                </section>


                <section>
                    <h3>Entities (1.5P)</h3>
                    <p class="subchapter">UML, Beschreibung und Begründung des
                        Einsatzes einer Entity; falls keine
                        Entity vorhanden: ausführliche Begründung, warum es keine
                        geben kann/hier nicht sinnvoll ist –
                        NICHT, warum es nicht implementiert wurde</p>
                </section>


                <section>
                    <h3>Entities:<br /> CarProfile als Entity</h3>
                    <ul>
                        <li>Besitzt eine eindeutige Identität (UUID)</li>
                        <li>Identität bleibt über den gesamten Lebenszyklus
                            erhalten
                        </li>
                        <li>Kann verändert und weiterentwickelt werden (auch wenn in
                            ULRICA immutable)
                        </li>
                        <li>Wird über die Identität verglichen, nicht über
                            Attributwerte
                        </li>
                        <li>Repräsentiert ein reales Objekt (Elektrofahrzeug) mit
                            eigenem Lebenszyklus
                        </li>
                    </ul>
                </section>

                <section>
                    <h3 style="margin-bottom: 0; padding-bottom: 0;">Entity:
                        UML</h3>
                    <img style="scale: 0.9; position: relative; bottom: 50px;"
                        src="assets/UMLs-imgs/Kapitel_6-Aufgabe_4.png" alt="Entity Pattern UML Diagram"
                        class="uml-image">
                </section>

                <section>
                    <h3>Entity: Begründung & Vorteile</h3>
                    <ul>
                        <li>Eindeutige Identifikation von Objekten unabhängig von
                            ihren Attributen
                        </li>
                        <li>Möglichkeit, Entitäten über ihren Lebenszyklus hinweg zu
                            verfolgen
                        </li>
                        <li>Konsistente Identifikation in verschiedenen Kontexten
                            des Systems
                        </li>
                        <li>Klare Unterscheidung zwischen Identität und Attributen
                        </li>
                        <li>Natürliche Abbildung von realen Objekten mit eigener
                            Identität
                        </li>
                    </ul>
                </section>

                <section>
                    <h3>Value Objects (1.5P)</h3>
                    <p class="subchapter">UML, Beschreibung und Begründung des
                        Einsatzes eines Value Objects; falls kein
                        Value Object vorhanden: ausführliche Begründung, warum es
                        keines geben kann/hier nicht sinnvoll
                        ist – NICHT, warum es nicht implementiert wurde</p>
                </section>

                <section>
                    <h3>Value Objects: BatteryProfile als ValueObject</h3>
                    <ul>
                        <li>Keine eigene Identität</li>
                        <li>Immutable (unveränderlich) nach Erstellung</li>
                        <li>Vergleich basiert auf allen Attributwerten</li>
                        <li>Beschreibt eine Messung oder ein Konzept</li>
                        <li>Kann problemlos ersetzt werden</li>
                        <li>Validiert sich selbst bei der Erstellung</li>
                    </ul>
                </section>

                <section>
                    <h3>Value Object: Code</h3>
                    <pre><code class="java">public final class BatteryProfile {
	private final BatteryType type;
	private final double capacityKwh;
	private final double degradationPercent;
	private final double maxDcPowerKw;
	private final double maxAcPowerKw;

	public BatteryProfile(BatteryType type, double capacityKwh, double degradationPercent, double maxDcPowerKw, double maxAcPowerKw) {
		if (capacityKwh <= 0) {
			throw new IllegalArgumentException("Battery capacity must be positive");
		}
		if (degradationPercent < 0 || degradationPercent > 100) {
			throw new IllegalArgumentException("Degradation must be between 0 and 100 percent");
		}
		if (maxDcPowerKw <= 0) {
			throw new IllegalArgumentException("Max DC power must be positive");
		}
		if (maxAcPowerKw <= 0) {
			throw new IllegalArgumentException("Max AC power must be positive");
		}
		this.type = Objects.requireNonNull(type, "Battery type cannot be null");
		this.capacityKwh = capacityKwh;
		this.degradationPercent = degradationPercent;
		this.maxDcPowerKw = maxDcPowerKw;
		this.maxAcPowerKw = maxAcPowerKw;
	}

	public BatteryType getType() {
		return type;
	}

	public double getCapacityKwh() {
		return capacityKwh;
	}

	public double getDegradationPercent() {
		return degradationPercent;
	}

	public double getRemainingCapacityKwh() {
		return capacityKwh * (1 - degradationPercent / 100);
	}

	public double getMaxDcPowerKw() {
		return maxDcPowerKw;
	}

	public double getMaxAcPowerKw() {
		return maxAcPowerKw;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;
		BatteryProfile that = (BatteryProfile) o;
		return Double.compare(that.capacityKwh, capacityKwh) == 0 &&
				Double.compare(that.degradationPercent, degradationPercent) == 0 &&
				Double.compare(that.maxDcPowerKw, maxDcPowerKw) == 0 &&
				Double.compare(that.maxAcPowerKw, maxAcPowerKw) == 0 &&
				type == that.type;
	}

	@Override
	public int hashCode() {
		return Objects.hash(type, capacityKwh, degradationPercent, maxDcPowerKw, maxAcPowerKw);
	}

	@Override
	public String toString() {
		return String.format(
			"Type: %s (%s)%n" +
			"Capacity: %.1f kWh%n" +
			"Degradation: %.1f%%%n" +
			"Remaining Capacity: %.1f kWh%n" +
			"Max DC Power: %.1f kW%n" +
			"Max AC Power: %.1f kW",
			type.name(), type.getDescription(),
			capacityKwh, degradationPercent,
			getRemainingCapacityKwh(),
			maxDcPowerKw, maxAcPowerKw
		);
	}
} </code></pre>
                </section>

                <section>
                    <h3>Value Objects: UML</h3>
                    <img style="scale: 1.1" src="assets/UMLs-imgs/Kapitel_6-Aufgabe_5.png"
                        alt="Value Objects UML Diagram" class="uml-image">
                </section>

                <section>
                    <h3>Value Objects: Begründung & Vorteile</h3>
                    <ul>
                        <li>Batteryprofile und ConsumptionProfile sind immutable und
                            damit thread-safe
                        </li>
                        <li>Vereinfachte Validierung durch Konstruktor basierte
                            Erstellung
                        </li>
                        <li>Natürliche Modellierung von Messwerten und Konzepten
                            ohne Identität
                        </li>
                        <li>Einfache Vergleichbarkeit durch attribut-basierte
                            equals-Implementierung
                        </li>
                        <li>Können problemlos ausgetauscht werden, da sie keine
                            Identität haben
                        </li>
                    </ul>
                </section>

            </section>
            <!-- Kapitel 7 -->
            <section alt="Kapitel 7">
                <section>
                    <h2 class="chapter-title">Kapitel 7:<br />Refactoring (8P)</h2>
                </section>

                <section>
                    <h3 class="subchapter">Inhalt des Kapitels</h3>
                    <div class="horizontal-spaced-container"
                        style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin-top: 50px;">
                        <div>
                            <h4>1. Code Smells (2P)</h4>
                            <ul>
                                <li>Lange Methode in "RangeCalculationController"
                                </li>
                                <li>Duplizierter Code in "Charging Calculators"</li>
                            </ul>
                        </div>
                        <div>
                            <h4>2. Refactorings (6P)</h4>
                            <ul>
                                <li>"Extract Method"</li>
                                <li>Ersetzen von Conditionals mit Polymorphism</li>
                            </ul>
                        </div>
                    </div>
                </section>

                <section>
                    <h3>Code Smells (2p)</h3>
                    <p class="subchapter">Jeweils 1 Code-Beispiel zu 2
                        unterschiedlichen Code Smells (die benannt werden
                        müssen) aus der
                        Vorlesung; jeweils Code-Beispiel und einen möglichen
                        Lösungsweg bzw. den genommen Lösungsweg
                        beschreiben (inkl.
                        (Pseudo-)Code)</p>
                </section>

                <section>
                    <h4>Code Smell 1: Lange Methode</h4>
                    <pre style="width: 1000px; height: 500px; overflow: hidden;"><code
                        class="java">/* public class RangeCalculationController {
			private final CalculateRangeUseCaseInterface calculateRangeUseCase;
			private final UserInputPortInterface userInputPort;
			private final RangeCalculationOutputPortInterface outputPort;
			
			public RangeCalculationController(
					CalculateRangeUseCaseInterface calculateRangeUseCase,
					UserInputPortInterface userInputPort,
					RangeCalculationOutputPortInterface outputPort) {
				this.calculateRangeUseCase = Objects.requireNonNull(calculateRangeUseCase, "Calculate range use case cannot be null");
				this.userInputPort = Objects.requireNonNull(userInputPort, "User input port cannot be null");
				this.outputPort = Objects.requireNonNull(outputPort, "Output port cannot be null");
			} */
			
			public boolean processRangeCalculation() {
				try {
					outputPort.showRangeCalculationHeader();
					
					TerrainType terrain = getTerrainType();
					WeatherType weather = getWeatherType();
					double temperature = getTemperature();
					DrivingEnvironment environment = getDrivingEnvironment();
					double stateOfCharge = getStateOfCharge();
					EfficiencyMode efficiencyMode = getEfficiencyMode();
					
					return calculateRangeUseCase.calculateRange(
							terrain,
							weather,
							temperature,
							environment,
							efficiencyMode,
							stateOfCharge
					);
				} catch (Exception e) {
					outputPort.showError("An error occurred: " + e.getMessage());
					return false;
				}
	}
/*...</code></pre>
                </section>

                <section>
                    <h3>Code Smell 1: Analyse</h3>
                    <ul>
                        <li>Die Methode ist zu lang und komplex -> Unübersichtlich
                        </li>
                        <li>Viele verschiedene Verantwortlichkeiten in einer
                            Methode
                        </li>
                        <li>Schlechte Lesbarkeit und Wartbarkeit</li>
                        <li>Schwer zu testen</li>
                        <li>Verletzt das Single Responsibility Principle</li>
                    </ul>
                </section>

                <section>
                    <h3>Code Smell 1: Lösungsvorschlag</h3>
                    <pre style="width: 1000px; height: 500px; overflow: hidden;"><code
                        class="java">public boolean processRangeCalculation() {
	try {
		outputPort.showRangeCalculationHeader(); // Ausgabe eines Headers vor der Berechnung

		RangeParameters parameters = collectRangeParameters(); // Sammeln aller Eingabewerte in ein Objekt
		return calculateRangeUseCase.calculateRange(parameters); // Aufruf der Reichweitenberechnung mit Parametern

	} catch (InvalidInputException e) {
		outputPort.showError("Invalid input: " + e.getMessage()); // Ausgabe eines Fehlers bei ungültiger Eingabe
		return false;
	} catch (Exception e) {
		outputPort.showError("Unexpected error: " + e.getMessage()); // Allgemeine Fehlerbehandlung
		return false;
	}
}

private RangeParameters collectRangeParameters() {
	return new RangeParameters(
		getTerrainType(),          // Ermittlung des Geländetyps
		getWeatherType(),          // Ermittlung der Wetterbedingungen
		getTemperature(),          // Abfrage der aktuellen Temperatur
		getDrivingEnvironment(),   // Ermittlung der Fahrumgebung
		getEfficiencyMode(),       // Auswahl des Effizienzmodus
		getStateOfCharge()         // Abfrage des aktuellen Ladezustands
	);
}
</code></pre>
                </section>


                <section>
                    <h3>Code Smell 2: Duplicate Code</h3>
                    <div class="horizontal-spaced-container">
                        <div>
                            <pre style="width: 1000px; height: 500px; overflow: hidden;"><code
                                    class="java">// DcChargingCalculator
private double calculateTemperatureEfficiencyFactor(double batteryTemperatureCelsius) {
	if (batteryTemperatureCelsius < MIN_BATTERY_TEMPERATURE || 
		batteryTemperatureCelsius > MAX_BATTERY_TEMPERATURE) {
		return 0.0;
	}
	
	if (batteryTemperatureCelsius >= OPTIMAL_TEMPERATURE_MIN && 
		batteryTemperatureCelsius <= OPTIMAL_TEMPERATURE_MAX) {
		return 1.0;
	}
	
	if (batteryTemperatureCelsius < OPTIMAL_TEMPERATURE_MIN) {
		return 0.5 + 0.5 * (batteryTemperatureCelsius - MIN_BATTERY_TEMPERATURE) / 
			(OPTIMAL_TEMPERATURE_MIN - MIN_BATTERY_TEMPERATURE);
	} else {
		return 0.5 + 0.5 * (MAX_BATTERY_TEMPERATURE - batteryTemperatureCelsius) / 
			(MAX_BATTERY_TEMPERATURE - OPTIMAL_TEMPERATURE_MAX);
	}
}

// AcChargingCalculator
private double calculateTemperatureEfficiency(double ambientTemperatureCelsius) {
	if (ambientTemperatureCelsius < MIN_BATTERY_TEMPERATURE || 
		ambientTemperatureCelsius > MAX_BATTERY_TEMPERATURE) {
		return 0.0;
	}
	
	if (ambientTemperatureCelsius >= OPTIMAL_TEMPERATURE_MIN && 
		ambientTemperatureCelsius <= OPTIMAL_TEMPERATURE_MAX) {
		return 1.0;
	}
	
	if (ambientTemperatureCelsius < OPTIMAL_TEMPERATURE_MIN) {
		return 0.7 + 0.3 * (ambientTemperatureCelsius - MIN_BATTERY_TEMPERATURE) / 
			(OPTIMAL_TEMPERATURE_MIN - MIN_BATTERY_TEMPERATURE);
	} else {
		return 0.7 + 0.3 * (MAX_BATTERY_TEMPERATURE - ambientTemperatureCelsius) / 
			(MAX_BATTERY_TEMPERATURE - OPTIMAL_TEMPERATURE_MAX);
	}
}</code></pre>
                        </div>
                    </div>
                </section>

                <section>
                    <h3>Code Smell 2: Analyse</h3>
                    <ul>
                        <li>Fast identischer Code in beiden Klassen (DC & AC
                            Charging Calculators)
                        </li>
                        <li>Nur minimale Unterschiede in den Konstanten (0.5 vs
                            0.7)
                        </li>
                        <li>Verletzt das DRY-Prinzip (Don't Repeat Yourself)</li>
                        <li>Schwer zu warten bei Änderungen</li>
                        <li>Fehleranfällig bei Updates</li>
                    </ul>
                </section>

                <section>
                    <h3>Code Smell 2: Lösungsvorschlag</h3>
                    <p class="subchapter">Logik kombinieren durch Berechnung</p>
                    <pre><code class="java">public class TemperatureEfficiencyCalculator {
	private final double minEfficiency;
	private final double maxEfficiency;
	
	public TemperatureEfficiencyCalculator(double minEfficiency, double maxEfficiency) {
		this.minEfficiency = minEfficiency;
		this.maxEfficiency = maxEfficiency;
	}
	
	public double calculateEfficiency(double temperature) {
		if (temperature < MIN_BATTERY_TEMPERATURE || 
			temperature > MAX_BATTERY_TEMPERATURE) {
			return 0.0;
		}
		
		if (temperature >= OPTIMAL_TEMPERATURE_MIN && 
			temperature <= OPTIMAL_TEMPERATURE_MAX) {
			return 1.0;
		}
		
		if (temperature < OPTIMAL_TEMPERATURE_MIN) {
			return minEfficiency + (maxEfficiency - minEfficiency) * 
				(temperature - MIN_BATTERY_TEMPERATURE) / 
				(OPTIMAL_TEMPERATURE_MIN - MIN_BATTERY_TEMPERATURE);
		} else {
			return minEfficiency + (maxEfficiency - minEfficiency) * 
				(MAX_BATTERY_TEMPERATURE - temperature) / 
				(MAX_BATTERY_TEMPERATURE - OPTIMAL_TEMPERATURE_MAX);
		}
	}
}</code></pre>
                </section>


                <section>
                    <h3>Refactorings (2p)</h3>
                    <p class="subchapter">2 unterschiedliche Refactorings aus der
                        Vorlesung jeweils benennen, anwenden,
                        begründen, sowie UML vorher/nachher liefern; jeweils auf die
                        Commits verweisen – die
                        Refactorings dürfen sich nicht mit den Beispielen der Code
                        Smells überschneiden</p>
                </section>


                <section>
                    <h3>Refactoring 1: Code</h3>
                    <p class="subchapter">Extrahieren der Parameter-Erfassung in
                        eine separate Methode (commit a5638e0)
                    </p>
                    <div class="horizontal-spaced-container" style="gap: 20px;">
                        <div style="width: 50%;">
                            <h5>Vorher</h5>
                            <pre
                                style="width: 550px; height: 450px; overflow: hidden; position: relative; right: 80px;"><code
                                class="java">public boolean processRangeCalculation() {
					try {
						outputPort.showRangeCalculationHeader();
						
						TerrainType terrain = getTerrainType();
						WeatherType weather = getWeatherType();
						double temperature = getTemperature();
						DrivingEnvironment environment = getDrivingEnvironment();
						double stateOfCharge = getStateOfCharge();
						EfficiencyMode efficiencyMode = getEfficiencyMode();
						
						return calculateRangeUseCase.calculateRange(
								terrain,
								weather,
								temperature,
								environment,
								efficiencyMode,
								stateOfCharge
						);
					} catch (Exception e) {
						outputPort.showError("An error occurred: " + e.getMessage());
						return false;
					}
				}</code></pre>
                        </div>
                        <div style="width: 50%;">
                            <h5>Nachher</h5>
                            <pre style="width: 550px; height: 450px; overflow: hidden;"><code
                                class="java">public boolean processRangeCalculation() {
					try {
						outputPort.showRangeCalculationHeader();
						RangeParameters parameters = collectRangeParameters();
						return calculateRangeUseCase.calculateRange(parameters);
					} catch (Exception e) {
						outputPort.showError("An error occurred: " + e.getMessage());
						return false;
					}
				}
				
				private RangeParameters collectRangeParameters() {
					TerrainType terrain = getTerrainType();
					WeatherType weather = getWeatherType();
					double temperature = getTemperature();
					DrivingEnvironment environment = getDrivingEnvironment();
					double stateOfCharge = getStateOfCharge();
					EfficiencyMode efficiencyMode = getEfficiencyMode();
					
					return new RangeParameters(
						terrain,
						weather,
						temperature,
						environment,
						efficiencyMode,
						stateOfCharge
					);
				}</code></pre>
                        </div>
                    </div>
                </section>


                <section>
                    <h3>Refactoring 1: Erklärung</h3>
                    <div class="horizontal-spaced-container">
                        <div style="width: 50%;">
                            <h4>Vorteile</h4>
                            <ul>
                                <li>Bessere Wartbarkeit durch modularen Code</li>
                                <li>Einfachere Testbarkeit durch isolierte
                                    Funktionalität
                                </li>
                                <li>Reduzierte Komplexität in der Hauptmethode</li>
                                <li>Einhaltung des <strong>Single Responsibility
                                        Principle (SRP)</strong> durch klare
                                    Trennung
                                    der Verantwortlichkeiten
                                </li>
                                <li>Einhaltung des <strong>Don't Repeat Yourself
                                        (DRY)</strong> Prinzips durch
                                    Vermeidung von
                                    Code-Duplikation
                                </li>
                            </ul>
                        </div>
                        <div style="width: 50%;">
                            <h4>Änderungen</h4>
                            <ul>
                                <li>Extraktion der Parameter-Erfassung in separate
                                    Methode
                                    <code>collectRangeParameters()</code>
                                </li>
                                <li>Einführung einer neuen Klasse <code>RangeParameters</code>
                                    zur Kapselung der
                                    Parameter
                                </li>
                                <li>Vereinfachung der Hauptmethode <code>processRangeCalculation()</code>
                                </li>
                                <li>Reduzierung der Parameteranzahl im Use Case
                                    Interface
                                </li>
                                <li>Verbesserte Lesbarkeit durch klare Trennung von
                                    Parameter-Erfassung und
                                    Geschäftslogik
                                </li>
                            </ul>
                        </div>
                    </div>
                </section>

                <section>
                    <h3>Refactoring 1: UML-Diagramme</h3>
                    <div class="horizontal-spaced-container">
                        <div>
                            <h5>Vorher</h5>
                            <img style="scale: 1.35; position:  relative; right: 55px;"
                                src="assets/UMLs-imgs/refactoring1_before.puml.png" alt="Extract Method UML Before"
                                class="uml-image">
                        </div>
                        <div>
                            <h5>Nachher</h5>
                            <img style="scale: 1.35; position:  relative; left: 50px;"
                                src="assets/UMLs-imgs/refactoring1_after.puml.png" alt="Extract Method UML After"
                                class="uml-image">
                        </div>
                    </div>
                </section>


                <section>
                    <h3>Refactoring 2: Code</h3>
                    <p class="subchapter">Ersetzen der Logik in den
                        ChargingCalculators durch Polymorphie
                        (943b4c7)</p>
                    <div class="horizontal-spaced-container">
                        <div style="width: 50%;">
                            <h5>Vorher</h5>
                            <pre
                                style="width: 550px; height: 450px; overflow: hidden; position: relative; right: 80px;"><code
                                class="java">public class DcChargingCalculator {
					private double calculatePowerReductionPercent(double startingSocPercent, double targetSocPercent) {
						if (targetSocPercent > 80) {
							return 60.0;
						} else if (targetSocPercent > 60) {
							return 30.0;
						} else {
							return 5.0;
						}
					}
				}
				
				public class AcChargingCalculator {
					private double calculateEfficiencyLoss(int connectorType) {
						switch (connectorType) {
							case HOUSEHOLD_SOCKET:
								return 0.1;
							case CAMPING_SOCKET:
								return 0.07;
							case WALLBOX:
								return 0.05;
							default:
								throw new IllegalArgumentException("Invalid connector type: " + connectorType);
						}
					}
				}</code></pre>
                        </div>
                        <div style="width: 50%;">
                            <h5>Nachher</h5>
                            <pre style="width: 550px; height: 450px; overflow: hidden;"><code
                                class="java">public interface ChargingStrategy {
					double calculateEfficiency();
				}
				
				public class HouseholdSocketStrategy implements ChargingStrategy {
					@Override
					public double calculateEfficiency() {
						return 0.1;
					}
				}
				
				public class CampingSocketStrategy implements ChargingStrategy {
					@Override
					public double calculateEfficiency() {
						return 0.07;
					}
				}
				
				public class WallboxStrategy implements ChargingStrategy {
					@Override
					public double calculateEfficiency() {
						return 0.05;
					}
				}
				
				public class DcChargingStrategy implements ChargingStrategy {
					private final double targetSocPercent;
					
					public DcChargingStrategy(double targetSocPercent) {
						this.targetSocPercent = targetSocPercent;
					}
					
					@Override
					public double calculateEfficiency() {
						if (targetSocPercent > 80) {
							return 0.4; // 60% reduction
						} else if (targetSocPercent > 60) {
							return 0.7; // 30% reduction
						} else {
							return 0.95; // 5% reduction
						}
					}
				}</code></pre>
                        </div>
                    </div>
                </section>

                <section>
                    <h3>Refactoring 2: Erklärung</h3>
                    <div class="horizontal-spaced-container">
                        <div style="width: 50%;">
                            <h4>Vorteile</h4>
                            <ul>
                                <li>Bessere Wartbarkeit durch klare Trennung der
                                    Verantwortlichkeiten
                                </li>
                                <li>Einfache Erweiterbarkeit durch neue Strategien
                                </li>
                                <li>Bessere Testbarkeit durch isolierte
                                    Komponenten
                                </li>
                                <li>Einhaltung des <strong>Open/Closed
                                        Principle</strong></li>
                                <li>Reduzierte Komplexität in den Charging
                                    Calculators
                                </li>
                            </ul>
                        </div>
                        <div style="width: 50%;">
                            <h4>Änderungen</h4>
                            <ul>
                                <li>Einführung des <code>ChargingStrategy</code>
                                    Interfaces
                                </li>
                                <li>Implementierung konkreter Strategien: <code>HouseholdSocketStrategy</code>,
                                    <code>CampingSocketStrategy</code>, <code>WallboxStrategy</code>,
                                    <code>DcChargingStrategy</code>
                                </li>
                                <li>Ersetzung der Logik durch polymorphe
                                    Methodenaufrufe
                                </li>
                                <li>Kapselung der Effizienzberechnung in den
                                    jeweiligen Strategieklassen
                                </li>
                                <li>Einführung von Konstruktoren für
                                    kontextabhängige Strategien
                                </li>
                            </ul>
                        </div>
                    </div>
                </section>


                <section>
                    <h3>Refactoring 2: UML-Diagramme</h3>
                    <div class="horizontal-spaced-container">
                        <div>
                            <h5>Vorher</h5>
                            <img style="scale: 1.3; position: relative; right: 60px;"
                                src="assets/UMLs-imgs/refactoring2_before.puml.png"
                                alt="Replace Conditional with Polymorphism UML Before" class="uml-image">
                        </div>
                        <div>
                            <h5>Nachher</h5>
                            <img style="scale: 1.3;  position: relative; left: 50px;"
                                src="assets/UMLs-imgs/refactoring2_after.puml.png"
                                alt="Replace Conditional with Polymorphism UML After" class="uml-image">
                        </div>
                    </div>
                </section>

            </section>
            <!-- Kapitel 8 -->
            <section alt="Kapitel 8">
                <section>
                    <h2 class="chapter-title">Kapitel 8: <br /> Entwurfsmuster (8P)
                    </h2>
                    <p class="subchapter">Zwei unterschiedliche Entwurfsmuster aus
                        der Vorlesung (oder nach Absprache
                        auch andere) jeweils benennen, sinnvoll einsetzen, begründen
                        und UML-Diagramm</p>
                </section>

                <section>
                    <h3>Entwurfsmuster 1: <br /> Strategy Pattern (4P)</h3>
                    <div class="horizontal-spaced-container">
                        <div style="width: 50%;">
                            <h4>Überblick</h4>
                            <ul>
                                <li><b>Kategorie/Art:</b> Behavioral Pattern</li>
                                <li><b>Zweck:</b> Definiert eine Familie von
                                    Algorithmen, kapselt sie ab und macht sie
                                    austauschbar (Laufzeit u. Compilezeit)
                                </li>
                                <li><b>Verwendung:</b> Implementierung verschiedener
                                    Berechnungsstrategien für die
                                    Reichweite von Elektrofahrzeugen
                                </li>
                            </ul>
                        </div>
                        <div style="width: 50%;">
                            <h4>Vorteile</h4>
                            <ul>
                                <li>Kapselung von unterschiedlichen Algorithmen in
                                    getrennten Klassen
                                </li>
                                <li>Laufzeitentscheidung über zu verwendende
                                    Strategie
                                </li>
                                <li>Leichte Erweiterbarkeit um neue Strategien (Auch
                                    gut für OCP)
                                </li>
                                <li>Einhaltung des <strong>Open/Closed
                                        Principles</strong></li>
                                <li>Vermeidung von bedingten Verzweigungen durch
                                    Polymorphie
                                </li>
                            </ul>
                        </div>
                    </div>
                </section>


                <section>
                    <h3 style="padding: 0; margin-top: 0;">Entwurfsmuster 1: <br />
                        Strategy Pattern (Forsetzung)</h3>
                    <div style="width: 100%;">
                        <h4 style="margin-top: 50px; padding: 0; margin-bottom: 0;">
                            Nachteile</h4>
                        <ul>
                            <li>Erhöhte Komplexität durch viele kleine Klassen</li>
                            <li>Client/Klasse muss die verschiedenen Strategien
                                kennen
                            </li>
                            <li>Möglicher Overhead durch zusätzliche Erstellung von
                                Objekten
                            </li>
                            <li>Strategie-Auswahl kann komplex werden</li>
                            <li>Schwieriger zu debuggen durch verteilte Logik</li>
                        </ul>
                    </div>
                </section>


                <section>
                    <h3>Strategy Pattern: Interface</h3>
                    <div class="horizontal-spaced-container">
                        <div>
                            <pre style="width: 1000px; height: 500px; overflow: hidden;"><code
                                    class="java">// Das Strategy Interface
public interface RangeCalculationStrategyInterface {
	RangeResult calculateRange(CarProfile carProfile, RangeParameters parameters);
	
	String getName();
	
	String getDescription();
}

</code></pre>
                        </div>
                    </div>
                </section>

                <section>
                    <h3>Strategy Pattern: Erste Implementierung</h3>
                    <div class="horizontal-spaced-container">
                        <div>
                            <pre style="width: 1000px; height: 500px; overflow: hidden;"><code
                                    class="java">// Erste Strategie-Implementierung
public class WltpBasedRangeCalculationStrategy implements RangeCalculationStrategyInterface {

	@Override
	public RangeResult calculateRange(CarProfile carProfile, RangeParameters parameters) {
		Objects.requireNonNull(carProfile, "Car profile cannot be null!!!");
		Objects.requireNonNull(parameters, "Range parameters cannot be null");
		
		double baseWltpRange = carProfile.getWltpRangeKm();
		double batteryCapacity = carProfile.getBatteryProfile().getRemainingCapacityKwh();
		double currentSoC = parameters.getStateOfChargePercent();
		
		double baseConsumption = (batteryCapacity * 100.0) / baseWltpRange;
		
		double modeConsumption = baseConsumption * parameters.getEfficiencyMode().getConsumptionFactor();
		
		double terrainFactor = calculateTerrainFactor(parameters.getTerrain());
		double terrainConsumption = modeConsumption * terrainFactor;
		
		double weatherFactor = calculateWeatherFactor(parameters.getWeather(), parameters.getTemperatureCelsius());
		double weatherConsumption = terrainConsumption * weatherFactor;
		
		double environmentFactor = calculateEnvironmentFactor(parameters.getEnvironment());
		double finalConsumption = weatherConsumption * environmentFactor;
		
		double availableEnergy = batteryCapacity * (currentSoC / 100.0);
		double estimatedRange = (availableEnergy * 100.0) / finalConsumption;
		
		String weatherImpact = generateWeatherImpactDescription(parameters.getWeather(), parameters.getTemperatureCelsius());
		String terrainImpact = generateTerrainImpactDescription(parameters.getTerrain());
		String environmentImpact = generateEnvironmentImpactDescription(parameters.getEnvironment());
		String batteryCondition = generateBatteryConditionDescription(parameters.getStateOfChargePercent(), parameters.getTemperatureCelsius());
		
		return new RangeResult(
				estimatedRange,
				finalConsumption,
				weatherImpact,
				terrainImpact,
				environmentImpact,
				batteryCondition
		);
	}
	
	private double calculateTerrainFactor(TerrainType terrain) {
		return switch(terrain) {
			case FLAT -> 1.0;
			case HILLY -> 1.15;
			case MOUNTAINOUS -> 1.35;
		};
	}
	
	private double calculateWeatherFactor(WeatherType weather, double temperature) {
		double weatherMultiplier = switch(weather) {
			case SUNNY -> 0.9;
			case CLOUDY -> 0.95;
			case RAIN -> 1.1;
			case SNOW -> 1.3;
			case STRONG_WIND -> 1.2;
		};
		
		double tempFactor;
		if (temperature < -10) {
			tempFactor = 1.4;
		} else if (temperature < 0) {
			tempFactor = 1.2;
		} else if (temperature < 10) {
			tempFactor = 1.0;
		} else if (temperature <= 25) {
			tempFactor = 0.9;
		} else if (temperature <= 35) {
			tempFactor = 0.95;
		} else {
			tempFactor = 1.1;
		}
		
		return weatherMultiplier * tempFactor;
	}
	
	private double calculateEnvironmentFactor(DrivingEnvironment environment) {
		return switch(environment) {
			case CITY -> 0.8;     
			case RURAL -> 1.0;    
			case HIGHWAY -> 1.1; 
		};
	}
	
	private String generateWeatherImpactDescription(WeatherType weather, double temperature) {
		StringBuilder impact = new StringBuilder();
		
		switch(weather) {
			case SUNNY:
				impact.append("Minimal impact - Ideal weather conditions");
				break;
			case CLOUDY:
				impact.append("Slight impact - Cloud cover has minimal effect on efficiency");
				break;
			case RAIN:
				impact.append("Moderate impact - Rain increases rolling resistance");
				break;
			case SNOW:
				impact.append("Severe impact - Snow conditions significantly reduce range");
				break;
			case STRONG_WIND:
				impact.append("Significant impact - Strong winds increase air resistance");
				break;
		}
		
		if (temperature < 0) {
			impact.append(", Cold temperature reduces battery efficiency");
		} else if (temperature > 30) {
			impact.append(", High temperature requires additional cooling");
		}
		
		return impact.toString();
	}
	
	private String generateTerrainImpactDescription(TerrainType terrain) {
		return switch(terrain) {
			case FLAT -> "Minimal impact - Flat terrain optimal for efficiency";
			case HILLY -> "Moderate impact - Hills affect energy consumption";
			case MOUNTAINOUS -> "Significant impact - Mountainous terrain substantially increases consumption";
		};
	}
	
	private String generateEnvironmentImpactDescription(DrivingEnvironment environment) {
		return switch(environment) {
			case CITY -> "Stop-and-go traffic at " + environment.getAvgSpeedKmh() + " km/h - Benefits from regenerative braking";
			case RURAL -> "Medium speed driving at " + environment.getAvgSpeedKmh() + " km/h - Moderate air resistance";
			case HIGHWAY -> "Constant high speed at " + environment.getAvgSpeedKmh() + " km/h - Increased air resistance";
		};
	}
	
	private String generateBatteryConditionDescription(double soc, double temperature) {
		StringBuilder condition = new StringBuilder();
		
		if (soc > 80) {
			condition.append("High SoC (").append(soc).append("%) - Optimal operating range");
		} else if (soc > 40) {
			condition.append("Medium SoC (").append(soc).append("%) - Good operating range");
		} else if (soc > 20) {
			condition.append("Low SoC (").append(soc).append("%) - Consider charging soon");
		} else {
			condition.append("Very low SoC (").append(soc).append("%) - Critical level, charge immediately");
		}
		
		condition.append(", ");
		
		if (temperature < -10) {
			condition.append("Battery temperature very cold (").append(temperature).append("°C) - Severely reduced efficiency");
		} else if (temperature < 0) {
			condition.append("Battery temperature cold (").append(temperature).append("°C) - Reduced efficiency");
		} else if (temperature < 10) {
			condition.append("Battery temperature cool (").append(temperature).append("°C) - Slightly reduced efficiency");
		} else if (temperature <= 30) {
			condition.append("Battery temperature optimal (").append(temperature).append("°C) - Maximum efficiency");
		} else if (temperature <= 40) {
			condition.append("Battery temperature warm (").append(temperature).append("°C) - Slightly reduced efficiency");
		} else {
			condition.append("Battery temperature hot (").append(temperature).append("°C) - Reduced efficiency, potential for degradation");
		}
		
		return condition.toString();
	}

	@Override
	public String getName() {
		return "WLTP-based Range Calculation";
	}

	@Override
	public String getDescription() {
		return "Calculates range based on the car's WLTP rating adjusted for external conditions";
	}
} 
</code></pre>
                        </div>
                    </div>
                </section>

                <section>
                    <h3>Strategy Pattern: Zweite Implementierung</h3>
                    <div class="horizontal-spaced-container">
                        <div>
                            <pre style="width: 1000px; height: 500px; overflow: hidden;"><code
                                    class="java">// Zweite Strategie-Implementierung

public class ConsumptionBasedRangeCalculationStrategy implements RangeCalculationStrategyInterface {

    @Override
    public RangeResult calculateRange(CarProfile carProfile, RangeParameters parameters) {
        Objects.requireNonNull(carProfile, "Car profile cannot be null");
        Objects.requireNonNull(parameters, "Range parameters cannot be null");
        
        ConsumptionProfile consumptionProfile = carProfile.getConsumptionProfile();
        double baseConsumption = getBaseConsumption(consumptionProfile, parameters.getEnvironment());
        
        double modeConsumption = baseConsumption * parameters.getEfficiencyMode().getConsumptionFactor();
        
        double terrainFactor = calculateTerrainFactor(parameters.getTerrain());
        double terrainConsumption = modeConsumption * terrainFactor;
        
        double weatherFactor = calculateWeatherFactor(parameters.getWeather(), parameters.getTemperatureCelsius());
        double finalConsumption = terrainConsumption * weatherFactor;
        
        double availableEnergy = carProfile.getBatteryProfile().getRemainingCapacityKwh() *
                (parameters.getStateOfChargePercent() / 100.0);
        double estimatedRange = (availableEnergy * 100.0) / finalConsumption;
        
        String weatherImpact = generateWeatherImpactDescription(parameters.getWeather(), parameters.getTemperatureCelsius());
        String terrainImpact = generateTerrainImpactDescription(parameters.getTerrain());
        String environmentImpact = generateEnvironmentImpactDescription(parameters.getEnvironment());
        String batteryCondition = generateBatteryConditionDescription(parameters.getStateOfChargePercent(), parameters.getTemperatureCelsius());
        
        return new RangeResult(
                estimatedRange,
                finalConsumption,
                weatherImpact,
                terrainImpact,
                environmentImpact,
                batteryCondition
        );
    }
    
    private double getBaseConsumption(ConsumptionProfile profile, DrivingEnvironment environment) {
        return switch(environment) {
            case CITY -> profile.getConsumptionAt50Kmh();
            case RURAL -> profile.getConsumptionAt100Kmh();
            case HIGHWAY -> profile.getConsumptionAt130Kmh();
        };
    }
    
    private double calculateTerrainFactor(TerrainType terrain) {
        return switch(terrain) {
            case FLAT -> 1.0;
            case HILLY -> 1.05;
            case MOUNTAINOUS -> 1.1;
        };
    }
    
    private double calculateWeatherFactor(WeatherType weather, double temperature) {
        double weatherMultiplier = switch(weather) {
            case SUNNY -> 0.9;
            case CLOUDY -> 1.0;
            case RAIN -> 1.2;
            case SNOW -> 1.3;
            case STRONG_WIND -> 1.1;
        };
        
        double tempFactor;
        if (temperature < -10) {
            tempFactor = 1.4;
        } else if (temperature < 0) {
            tempFactor = 1.15;
        } else if (temperature < 10) {
            tempFactor = 1.0;
        } else if (temperature <= 25) {
            tempFactor = 0.9;
        } else if (temperature <= 35) {
            tempFactor = 1.1;
        } else {
            tempFactor = 1.2;
        }
        
        return weatherMultiplier * tempFactor;
    }
    
    private String generateWeatherImpactDescription(WeatherType weather, double temperature) {
        StringBuilder impact = new StringBuilder();
        
        switch(weather) {
            case SUNNY:
                impact.append("Minimal impact -> Ideal weather conditions");
                break;
            case CLOUDY:
                impact.append("Slight impact -> Cloud cover has minimal effect on efficiency");
                break;
            case RAIN:
                impact.append("Moderate impact -> Rain increases rolling resistance");
                break;
            case SNOW:
                impact.append("Severe impact - Snow conditions significantly reduce range");
                break;
            case STRONG_WIND:
                impact.append("Significant impact - Strong winds increase air resistance");
                break;
        }
        
        if (temperature < 0) {
            impact.append(", Cold temperature reduces battery efficiency!");
        } else if (temperature > 30) {
            impact.append(", High temperature requires additional cooling!");
        }
        
        return impact.toString();
    }
    
    private String generateTerrainImpactDescription(TerrainType terrain) {
        return switch(terrain) {
            case FLAT -> "Minimal impact - Flat terrain optimal for efficiency";
            case HILLY -> "Moderate impact - Hills affect energy consumption";
            case MOUNTAINOUS -> "Significant impact - Mountainous terrain substantially increases consumption";
        };
    }
    
    private String generateEnvironmentImpactDescription(DrivingEnvironment environment) {
        return switch(environment) {
            case CITY -> "Stop-and-go traffic at " + environment.getAvgSpeedKmh() + " kmh - Benefits from regenerative braking";
            case RURAL -> "Medium speed driving at " + environment.getAvgSpeedKmh() + " km/h - Moderate air resistance!";
            case HIGHWAY -> "Constant high speed at " + environment.getAvgSpeedKmh() + " km/h - Increased air resistance!";
        };
    }
    
    private String generateBatteryConditionDescription(double soc, double temperature) {
        StringBuilder condition = new StringBuilder();
        
        if (soc > 80) {
            condition.append("High SoC (").append(soc).append("%) -> Optimal operating range.");
        } else if (soc > 40) {
            condition.append("Medium SoC (").append(soc).append("%) -> Good operating range.");
        } else if (soc > 20) {
            condition.append("Low SoC (").append(soc).append("%) - Consider charging soon.");
        } else {
            condition.append("Very low SoC (").append(soc).append("%) - Critical level!!! charge immediately.");
        }
        
        condition.append(", ");
        
        if (temperature < -10) {
            condition.append("Battery temperature tooo cold!!! (").append(temperature).append("°C) -> Severely reduced efficiency");
        } else if (temperature < 0) {
            condition.append("Battery temperature cold (").append(temperature).append("°C) -> Reduced efficiency");
        } else if (temperature < 10) {
            condition.append("Battery temperature cool (").append(temperature).append("°C) -> Slightly reduced efficiency");
        } else if (temperature <= 30) {
            condition.append("Battery temperature optimal (").append(temperature).append("°C) -> Maximum efficiency");
        } else if (temperature <= 40) {
            condition.append("Battery temperature warm (perfectly fine) (").append(temperature).append("°C) -> Slightly reduced efficiency");
        } else {
            condition.append("Battery temperature too hot!!! (").append(temperature).append("°C) - Reduced efficiency! potential for degradation!!!");
        }
        
        return condition.toString();
    }

    @Override
    public String getName() {
        return "Consumption-based Range Calculation";
    }

    @Override
    public String getDescription() {
        return "Calculates range based on the car's consumption profile adjusted for external conditions";
    }
} 

			</code></pre>
                        </div>
                    </div>
                </section>

                <section>
                    <h3>Strategy Pattern: Verwendung im Client</h3>
                    <div class="horizontal-spaced-container">
                        <div>
                            <pre style="width: 1000px; height: 500px; overflow: hidden;"><code
                                    class="java">// Client-Klasse, die die Strategien verwendet
public class RangeCalculatorService {
    private final List<RangeCalculationStrategyInterface> strategies;
    private RangeCalculationStrategyInterface defaultStrategy;

    public RangeCalculatorService() {
        this.strategies = new ArrayList<>();
        
        WltpBasedRangeCalculationStrategy wltpStrategy = new WltpBasedRangeCalculationStrategy();
        ConsumptionBasedRangeCalculationStrategy consumptionStrategy = new ConsumptionBasedRangeCalculationStrategy();
        
        this.strategies.add(wltpStrategy);
        this.strategies.add(consumptionStrategy);
        
        this.defaultStrategy = consumptionStrategy;
    }
    
    public void addStrategy(RangeCalculationStrategyInterface strategy) {
        Objects.requireNonNull(strategy, "Strategy cannot be null");
        strategies.add(strategy);
    }
    
    public void setDefaultStrategy(RangeCalculationStrategyInterface strategy) {
        Objects.requireNonNull(strategy, "Strategy cannot be null");
        if (!strategies.contains(strategy)) {
            strategies.add(strategy);
        }
        this.defaultStrategy = strategy;
    }
    
    public List<RangeCalculationStrategyInterface> getAvailableStrategies() {
        return new ArrayList<>(strategies);
    }
    
    public RangeCalculationStrategyInterface getDefaultStrategy() {
        return defaultStrategy;
    }
    
    public RangeResult calculateRange(CarProfile carProfile, RangeParameters parameters) {
        Objects.requireNonNull(carProfile, "Car profile cannot be null");
        Objects.requireNonNull(parameters, "Range parameters cannot be null");
        
        return defaultStrategy.calculateRange(carProfile, parameters);
    }
    
    public RangeResult calculateRangeWithStrategy(CarProfile carProfile, RangeParameters parameters, RangeCalculationStrategyInterface strategy) {
        Objects.requireNonNull(carProfile, "Car profile cannot be null");
        Objects.requireNonNull(parameters, "Range parameters cannot be null");
        Objects.requireNonNull(strategy, "Strategy cannot be null");
        
        return strategy.calculateRange(carProfile, parameters);
    }
} 
</code></pre>
                        </div>
                    </div>
                </section>

                <section>
                    <h4>Strategie Pattern: Vergleich</h4>
                    <table style="margin: 0 auto; margin-top: 30px; padding: 0;">
                        <thead>
                            <tr>
                                <th>Aspekt</th>
                                <th>ConsumptionBasedRangeCalculationStrategy</th>
                                <th>WltpBasedRangeCalculationStrategy</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Basis für Berechnung</td>
                                <td>Verbrauchsprofile des Fahrzeugs bei verschiedenen
                                    Geschwindigkeiten (50, 100, 130
                                    km/h)
                                </td>
                                <td>WLTP-Reichweite des Fahrzeugs als Fixwert</td>
                            </tr>
                            <tr>
                                <td>Kalkulation Grundverbrauch</td>
                                <td>Basierend auf dem aktuellen Fahrumfeld
                                    (DrivingEnvironment) wird ein Verbrauchswert
                                    (kWh/100km) gewählt
                                </td>
                                <td>Es wird ein durchschnittlicher Verbrauch aus der
                                    WLTP-Reichweite und
                                    Batteriekapazität berechnet
                                </td>
                            </tr>
                            <tr>
                                <td>Berücksichtigte Faktoren</td>
                                <td>Effizienzmodus, Geländeart, Wetterbedingungen,
                                    Temperatur, Batterieladestand
                                </td>
                                <td>Effizienzmodus, Geländeart, Wetterbedingungen,
                                    Temperatur, Batterieladestand,
                                    zusätzlich ein Fahrumgebungsfaktor
                                    (EnvironmentFactor)
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </section>

                <section>
                    <h3>Strategy Pattern: UML-Diagramm</h3>
                    <img style="scale: 1.25; margin: 0; padding: 0; margin-top: 50px;"
                        src="assets/UMLs-imgs/Kapitel_8-Aufgabe_1.png" alt="Strategy Pattern UML Diagram"
                        class="uml-image">
                </section>


                <section>
                    <h3>Entwurfsmuster 2: Adapter Pattern (4P)</h3>
                    <div class="horizontal-spaced-container">
                        <div style="width: 50%;">
                            <h4>Überblick</h4>
                            <ul>
                                <li><b>Art/Kategorie:</b> Strukturmuster (Structural
                                    Pattern)
                                </li>
                                <li><b>Zweck:</b> Konvertiert die Schnittstelle
                                    einer Klasse in eine andere, die vom
                                    Client erwartet wird
                                </li>
                                <li><b>Verwendung:</b> Integration von
                                    I/O-Operationen in die Clean Architecture
                                </li>
                            </ul>
                        </div>
                        <div style="width: 50%;">
                            <h4>Vorteile</h4>
                            <ul>
                                <li>Flexibilität durch lose Kopplung</li>
                                <li>Einfach zu erweitern</li>
                                <li>Trennt Geschäftslogik von externen Ressourcen u.
                                    Komponenten
                                </li>
                                <li>Ermöglicht Zusammenarbeit nicht-kompatibler
                                    Schnittstellen
                                </li>
                            </ul>
                        </div>
                    </div>
                </section>

                <section>
                    <h3 style="padding: 0; margin-top: 0;">Entwurfsmuster 2: <br />
                        Adapter Pattern (Fortsetzung)</h3>
                    <div style="width: 100%;">
                        <h4 style="margin-top: 50px; padding: 0; margin-bottom: 0;">
                            Nachteile</h4>
                        <ul>
                            <li>Zusätzliche Komplexität durch zusätzliche
                                Abstraktionsebene
                            </li>
                            <li>Möglicher Overhead durch zusätzliche
                                Methodenaufrufe
                            </li>
                            <li>Erhöhte Anzahl von Klassen und Interfaces</li>
                            <li>Externe können abrupt aufrufen</li>
                        </ul>
                    </div>
                </section>

                <section>
                    <h3>Adapter Pattern: Port-Interfaces</h3>
                    <div class="horizontal-spaced-container">
                        <div>
                            <pre style="width: 1000px; height: 500px; overflow: hidden;"><code
                                    class="java">// Port Interface für Benutzereingaben
public interface UserInputPortInterface {
    String readLine();
    int readInt();
    double readDouble();
    boolean readBoolean(String yesOption, String noOption);
    String readStringWithValidation(String prompt, String errorMessage, java.util.function.Predicate<String> validator);
    int readIntInRange(String prompt, int min, int max);
    double readDoubleInRange(String prompt, double min, double max);
}

// Port Interface für Benutzerausgaben
public interface UserOutputPortInterface {
    void display(String message);
    void displayLine(String message);
    void displayPrompt(String prompt);
    void displayError(String errorMessage);
    void displaySuccess(String successMessage);
    void displayWarning(String warningMessage);
    void displayTable(String[] headers, String[][] data);
    void clearScreen();
    void displayProgressBar(int current, int total);
}</code></pre>
                        </div>
                    </div>
                </section>

                <section>
                    <h3>Adapter Pattern: ConsoleUserInputAdapter</h3>
                    <div class="horizontal-spaced-container">
                        <div>
                            <pre style="width: 1000px; height: 500px; overflow: hidden;"><code
                                    class="java">
public class ConsoleUserInputAdapter implements UserInputPortInterface {
    private final Scanner scanner;
    
    public ConsoleUserInputAdapter(Scanner scanner) {
        this.scanner = Objects.requireNonNull(scanner, "Scanner cannot be null");
    }
    
    @Override
    public String readLine() {
        return scanner.nextLine();
    }
    
    @Override
    public int readInt() {
        while (true) {
            try {
                return Integer.parseInt(scanner.nextLine());
            } catch (NumberFormatException e) {
                System.out.println("Invalid input. Please enter a valid integer.");
            }
        }
    }
    
    @Override
    public double readDouble() {
        while (true) {
            try {
                return Double.parseDouble(scanner.nextLine());
            } catch (NumberFormatException e) {
                System.out.println("Invalid input. Please enter a valid number.");
            }
        }
    }
    
    @Override
    public boolean readBoolean(String yesOption, String noOption) {
        while (true) {
            String input = scanner.nextLine().toLowerCase();
            if (input.equals(yesOption.toLowerCase())) {
                return true;
            } else if (input.equals(noOption.toLowerCase())) {
                return false;
            }
            System.out.println("Invalid input. Please enter '" + yesOption + "' or '" + noOption + "'.");
        }
    }
    
    @Override
    public String readStringWithValidation(String prompt, String errorMessage, Predicate<String> validator) {
        while (true) {
            System.out.print(prompt);
            String input = scanner.nextLine();
            if (validator.test(input)) {
                return input;
            }
            System.out.println(errorMessage);
        }
    }
    
    @Override
    public int readIntInRange(String prompt, int min, int max) {
        while (true) {
            System.out.print(prompt);
            try {
                int value = Integer.parseInt(scanner.nextLine());
                if (value >= min && value <= max) {
                    return value;
                }
                System.out.println("Please enter a number between " + min + " and " + max);
            } catch (NumberFormatException e) {
                System.out.println("Invalid input. Please enter a valid integer.");
            }
        }
    }
    
    @Override
    public double readDoubleInRange(String prompt, double min, double max) {
        while (true) {
            System.out.print(prompt);
            try {
                double value = Double.parseDouble(scanner.nextLine());
                if (value >= min && value <= max) {
                    return value;
                }
                System.out.println("Please enter a number between " + min + " and " + max);
            } catch (NumberFormatException e) {
                System.out.println("Invalid input. Please enter a valid number.");
            }
        }
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section>
                    <h3>Adapter Pattern: ConsoleUserOutputAdapter</h3>
                    <div class="horizontal-spaced-container">
                        <div>
                            <pre style="width: 1000px; height: 500px; overflow: hidden;"><code
                                    class="java">
public class ConsoleUserOutputAdapter implements UserOutputPortInterface {
    private static final String ANSI_RESET = "\u001B[0m";
    private static final String ANSI_RED = "\u001B[31m";
    private static final String ANSI_GREEN = "\u001B[32m";
    private static final String ANSI_YELLOW = "\u001B[33m";
    private static final String ANSI_CLEAR = "\033[H\033[2J";
    
    @Override
    public void display(String message) {
        System.out.print(message);
    }
    
    @Override
    public void displayLine(String message) {
        System.out.println(message);
    }
    
    @Override
    public void displayPrompt(String prompt) {
        System.out.print(prompt + ": ");
    }
    
    @Override
    public void displayError(String errorMessage) {
        System.out.println(ANSI_RED + "Error: " + errorMessage + ANSI_RESET);
    }
    
    @Override
    public void displaySuccess(String successMessage) {
        System.out.println(ANSI_GREEN + "Success: " + successMessage + ANSI_RESET);
    }
    
    @Override
    public void displayWarning(String warningMessage) {
        System.out.println(ANSI_YELLOW + "Warning: " + warningMessage + ANSI_RESET);
    }
    
    @Override
    public void displayTable(String[] headers, String[][] data) {
        // Calculate column widths
        int[] columnWidths = new int[headers.length];
        for (int i = 0; i < headers.length; i++) {
            columnWidths[i] = headers[i].length();
            for (String[] row : data) {
                if (row[i].length() > columnWidths[i]) {
                    columnWidths[i] = row[i].length();
                }
            }
        }
        
        // Print headers
        StringBuilder format = new StringBuilder("|");
        for (int width : columnWidths) {
            format.append(" %-").append(width).append("s |");
        }
        format.append("\n");
        
        System.out.println(format.toString().formatted((Object[]) headers));
        
        // Print separator
        System.out.println("-".repeat(Arrays.stream(columnWidths).sum() + headers.length * 3 + 1));
        
        // Print data
        for (String[] row : data) {
            System.out.println(format.toString().formatted((Object[]) row));
        }
    }
    
    @Override
    public void clearScreen() {
        System.out.print(ANSI_CLEAR);
        System.out.flush();
    }
    
    @Override
    public void displayProgressBar(int current, int total) {
        int width = 50;
        int progress = (int) ((double) current / total * width);
        
        StringBuilder bar = new StringBuilder("[");
        for (int i = 0; i < width; i++) {
            if (i < progress) {
                bar.append("=");
            } else {
                bar.append(" ");
            }
        }
        bar.append("] ").append(current).append("/").append(total);
        
        System.out.print("\r" + bar.toString());
        if (current == total) {
            System.out.println();
        }
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section>
                    <h3>Adapter Pattern: Verwendung im Controller</h3>
                    <div class="horizontal-spaced-container">
                        <div>
                            <pre style="width: 1000px; height: 500px; overflow: hidden;"><code
                                    class="java">
public class RangeCalculationController {
    private final UserInputPortInterface userInputPort;
    private final UserOutputPortInterface userOutputPort;
    private final CalculateRangeUseCaseInterface calculateRangeUseCase;
    
    public RangeCalculationController(
            UserInputPortInterface userInputPort,
            UserOutputPortInterface userOutputPort,
            CalculateRangeUseCaseInterface calculateRangeUseCase) {
        this.userInputPort = Objects.requireNonNull(userInputPort, "UserInputPort cannot be null");
        this.userOutputPort = Objects.requireNonNull(userOutputPort, "UserOutputPort cannot be null");
        this.calculateRangeUseCase = Objects.requireNonNull(calculateRangeUseCase, "CalculateRangeUseCase cannot be null");
    }
    
    public void processRangeCalculation() {
        try {
            // Benutzereingaben über Port sammeln
            userOutputPort.displayPrompt("Enter temperature (°C)");
            double temperature = userInputPort.readDoubleInRange("", -50, 50);
            
            userOutputPort.displayPrompt("Enter state of charge (%)");
            double soc = userInputPort.readDoubleInRange("", 0, 100);
            
            userOutputPort.displayPrompt("Select weather condition (SUNNY, CLOUDY, RAIN, SNOW, STRONG_WIND)");
            WeatherType weather = WeatherType.valueOf(userInputPort.readStringWithValidation(
                "",
                "Invalid weather condition. Please enter one of: SUNNY, CLOUDY, RAIN, SNOW, STRONG_WIND",
                input -> Arrays.stream(WeatherType.values())
                    .map(Enum::name)
                    .anyMatch(name -> name.equalsIgnoreCase(input))
            ).toUpperCase());
            
            userOutputPort.displayPrompt("Select terrain type (FLAT, HILLY, MOUNTAINOUS)");
            TerrainType terrain = TerrainType.valueOf(userInputPort.readStringWithValidation(
                "",
                "Invalid terrain type. Please enter one of: FLAT, HILLY, MOUNTAINOUS",
                input -> Arrays.stream(TerrainType.values())
                    .map(Enum::name)
                    .anyMatch(name -> name.equalsIgnoreCase(input))
            ).toUpperCase());
            
            userOutputPort.displayPrompt("Select driving environment (CITY, RURAL, HIGHWAY)");
            DrivingEnvironment environment = DrivingEnvironment.valueOf(userInputPort.readStringWithValidation(
                "",
                "Invalid driving environment. Please enter one of: CITY, RURAL, HIGHWAY",
                input -> Arrays.stream(DrivingEnvironment.values())
                    .map(Enum::name)
                    .anyMatch(name -> name.equalsIgnoreCase(input))
            ).toUpperCase());
            
            userOutputPort.displayPrompt("Select efficiency mode (NORMAL, ECO, SPORT)");
            EfficiencyMode mode = EfficiencyMode.valueOf(userInputPort.readStringWithValidation(
                "",
                "Invalid efficiency mode. Please enter one of: NORMAL, ECO, SPORT",
                input -> Arrays.stream(EfficiencyMode.values())
                    .map(Enum::name)
                    .anyMatch(name -> name.equalsIgnoreCase(input))
            ).toUpperCase());
            
            // Use Case über Interface ausführen
            RangeParameters parameters = new RangeParameters(
                temperature,
                soc,
                weather,
                terrain,
                environment,
                mode
            );
            
            calculateRangeUseCase.calculateRange(parameters);
            
        } catch (Exception e) {
            userOutputPort.displayError("An error occurred during range calculation: " + e.getMessage());
        }
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section>
                    <h3>Adapter Pattern: UML-Diagramm</h3>
                    <img style="scale: 1.3" src="assets/UMLs-imgs/Kapitel_8-Aufgabe_2.png"
                        alt="Adapter Pattern UML Diagram" class="uml-image">
                </section>
            </section>

            <section>
                <h1 style="font-size: 20rem !important; background-color: whitesmoke; border-radius: 50px; box-shadow: 15px 15px 0 5px rgba(0, 167, 206, 1.0), 0 0 1000px 0 rgba(0,0,0, 0.3); padding: 0; margin: 0; border: solid rgba(0,0,0, 0.1) 0.5px;" class="hljs-string">ENDE</h1>
            </section>

        </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
        // Debug logging
        console.log('RevealHighlight plugin:', typeof RevealHighlight);
        console.log('hljs global:', typeof window.hljs);

        // More info about initialization & config:
        // - https://revealjs.com/initialization/
        // - https://revealjs.com/config/
        Reveal.initialize({
            hash: true,
            slideNumber: true,

            // Explicit highlight config
            highlight: {
                highlightOnLoad: true,
                escapeHTML: false
            },

            // Learn about plugins: https://revealjs.com/plugins/
            plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
        });

        // Load all slide content, then initialize highlight.js
        const loadSlidesPromises = [];
        document.querySelectorAll('[data-include]').forEach((section) => {
            const url = section.getAttribute('data-include');
            const promise = fetch(url)
                .then(response => response.text())
                .then(html => {
                    section.html = ""
                    section.innerHTML = html;
                });
            loadSlidesPromises.push(promise);
        });

        // After all slides are loaded, re-initialize highlight.js
        Promise.all(loadSlidesPromises).then(() => {
            // Force Reveal to update
            Reveal.sync();

            // Try multiple ways to initialize highlighting

            // 1. Through Reveal plugin
            const highlight = Reveal.getPlugin('highlight');
            if (highlight) {
                document.querySelectorAll('code').forEach(block => {
                    highlight.highlightBlock(block);
                });
            }

            // 2. Direct hljs initialization if available
            if (window.hljs) {
                window.hljs.configure({
                    languages: ['bash', 'javascript', 'html', 'xml', 'css']
                });
                document.querySelectorAll('code.bash, code.hljs.bash').forEach(block => {
                    window.hljs.highlightElement(block);
                });
            }
        });
    </script>
</body>

</html>