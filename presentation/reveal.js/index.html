<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>ULRICA - Programmentwurf Protokoll</title>

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/white.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/lightfair.css">
</head>
<style>
	code:not(.hljs) {
		font-size: 1.25rem;
	}

	pre {
		border-radius: 5px;
	}

	code {
		border-radius: 5px;
		font-size: 0.9rem !important;
	}


	/* Syntax highlighting styles similar to the screenshot */
	.hljs-keyword {
		color: blue;
		/* softer green */
		font-weight: 500;
	}

	.hljs-built_in {
		color: darkblue;
		font-weight: normal;
	}

	.hljs-string {
		color: rgb(0, 167, 206);
		/* softer yellow/orange */
		font-weight: normal;
	}

	.hljs {
		font-size: 1.25rem;
		background: transparent;
		display: inline;
	}

	h1 {
		font-size: 4rem;
	}

	h2 {
		font-size: 3rem;
	}

	h3 {
		font-size: 2.5rem;
	}

	h4 {
		font-size: 2.25rem;
		font-weight: semibold;
	}

	h5 {
		font-size: 2rem;
		font-weight: semibold;
	}

	h6 {
		font-size: 1.75rem;
		font-weight: semibold;
	}

	p {
		font-size: 1.75rem;
	}

	li {
		font-size: 1.75rem;
		margin: 5px 0;
	}

	ul {
		text-align: start;
		align-self: start;
	}

	ol {
		text-align: start;
		align-self: start;
	}

	.primary-color {
		color: rgb(0, 167, 206) !important;
	}


	.horizontal-container {
		display: flex;
		gap: 2rem;
		justify-content: center;
	}

	.horizontal-spaced-container {
		display: flex;
		gap: 2rem;
		justify-content: space-evenly;
	}

	.gray {
		color: #808080;
	}

	.slide-number {
		font-size: 16px !important;
		color: #333 !important;
		background-color: rgba(255, 255, 255, 0.7);
		padding: 3px 8px !important;
		border-radius: 10px;
	}

	.chapter-title {
		font-size: 3.5rem;
		margin-bottom: 2rem;
		color: #333;
		text-align: center;
	}

	.uml-image {
		max-width: 90%;
		max-height: 70vh;
		margin: 0 auto;
	}

	.center {
		text-align: center;
	}

	.acronym-letter {
		font-weight: 900;
		font-size: 120%;
	}

	.name-explanation {
		font-size: 2.5rem;
		text-align: center;
		margin: 2rem 0;
	}

	.subchapter {
		color: #666;
		font-size: 1.8rem;
		margin-top: 1rem;
		font-style: italic;
	}
</style>

<body>
	<div class="reveal">
		<div class="slides">

			<section alt="Anfang/Einleitung">
				<h3>Programmentwurf - Protokoll</h3>
				<p class="gray center">zu</p>
				<img style="margin: 50px 0;" src="./assets/imgs/ulrica-blue.png" alt="ULRICA Logo" class="logo">
				<div class="horizontal-container gray">
					<p>Robin Schwenzfeier</p>
					<p>-</p>
					<p>4868455</p>
					<p>-</p>
					<p>TINF21CS1</p>
				</div>
			</section>
			<section alt="Kapitel 1">
				<section>
					<h2 class="chapter-title">Kapitel 1: Einleitung (4P)</h2>
				</section>

				<section>
					<h3 class="subchapter">Inhalt des Kapitels</h3>
					<div class="horizontal-spaced-container"
						style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
						<div>
							<h6>1. Übersicht über die Applikation (1P)</h6>
							<ul>
								<li>Name und Bedeutung</li>
								<li>Features und Funktionen</li>
								<li>Probleme, die sie löst</li>
							</ul>
						</div>
						<div>
							<h6>2. Starten der Applikation (1P)</h6>
							<ul>
								<li>Voraussetzungen</li>
								<li>Schritte zum Starten</li>
								<li>Alternative zum Starten</li>
							</ul>
						</div>
						<div>
							<h6>3. Technischer Überblick (2P)</h6>
							<ul>
								<li>Java (JDK 17)</li>
								<li>Maven</li>
								<li>JSON & GSON</li>
								<li>JUnit & JaCoCo</li>
								<li>Clean Architecture</li>
							</ul>
						</div>
						<div>
						</div>
					</div>
				</section>

				<section>
					<h3>Übersicht über die Applikation (1P)</h3>
					<p class="subchapter">Was macht die Applikation? Wie funktioniert sie? Welches Problem löst sie/welchen Zweck hat sie?</p>
				</section>

				<section>
					<h3><strong>ULRICA</strong>: Name erklärt</h3>
					<p class="subchapter">Ein Acronym.</p>
					<p class="name-explanation">
						<span class="acronym-letter primary-color">U</span>niversa<span
							class="acronym-letter primary-color">L</span>
						<span class="acronym-letter primary-color">R</span>ange and dest<span
							class="acronym-letter primary-color">I</span>nation
						<span class="acronym-letter primary-color">CA</span>lculator
					</p>
				</section>

				<section>
					<h3>Features der Applikation</h3>
					<p class="subchapter">Probleme, die sie löst.</p>
					<ul>
						<li><span class="primary-color">1.</span> Erstellt und verwaltet Fahrzeugprofile für
							Elektrofahrzeuge</li>
						<li><span class="primary-color">2.</span> Berechnet verbleibende Reichweite von
							Elektrofahrzeugen</li>
						<li><span class="primary-color">3. + 4.</span> Berechnet Ladezeiten an DC- und AC-Ladestationen
						</li>
						<li><s><span class="primary-color">5.</span> Berechnet und simmuliert eine Route</s></li>
					</ul>
				</section>

				<section>
					<h3>Features der Applikation</h3>
					<div class="horizontal-spaced-container">
						<div>
							<h5><span class="primary-color">1.</span> Fahrzeugprofil-Management</h5>
							<ul>
								<li>Erstellung, Anzeige und Löschung von Fahrzeugprofilen</li>
								<li>Konfiguration von Batteriedaten (Typ, Kapazität, Degradation, etc.)</li>
								<li>Definition von Verbrauchsprofilen (bei 50km/h, 100km/h, 130km/h)</li>
							</ul>
						</div>
						<div>
							<h5><span class="primary-color">2.</span> Reichweitenberechnung</h5>
							<ul>
								<li>Strategie-Pattern für verschiedene Berechnungsmethoden</li>
								<li>WLTP-basierte Berechnung mit "echten" Bedingungen</li>
								<li>Temperatureinflüsse</li>
								<li>Geländebedingungen</li>
								<li>etc.</li>
							</ul>
						</div>
					</div>
				</section>

				<section>
					<h3>Features der Applikation</h3>
					<div class="horizontal-spaced-container">
						<div>
							<h5><span class="primary-color">3.</span> DC (Schnelles) Laden</h5>
							<ul>
								<li>SoC-basierte Berechnungen</li>
								<li>Temperatureinflüsse beim Laden</li>
								<li>Leistungsreduktion basierend auf Batteriezustand</li>
								<li>Detaillierte Ladezeitschätzungen</li>
								<li>Berücksichtigung von Batterie-Typ</li>
							</ul>
						</div>
						<div>
							<h5><span class="primary-color">4.</span> AC (Langsames) Laden</h5>
							<ul>
								<li>Verschiedene Anschlusstypen (Haushalt, Camping, Wallbox)</li>
								<li>Berechnung von Effizienzverlusten</li>
								<li>Temperatur-Effizenzfaktoren</li>
								<li>Ladezeitprognosen</li>
							</ul>
						</div>
					</div>
				</section>


				<section>
					<h3>Starten der Applikation (1P)</h3>
					<p class="subchapter">Wie startet man die Applikation? Was für Voraussetzungen werden benötigt? Schritt-für-Schritt-Anleitung</p>
				</section>
				<section>
					<h3>Voraussetzungen:</h3>
					<ul>
						<li>Java 17 oder höher</li>
						<li>Maven</li>
						<li>Git</li>
					</ul>
				</section>
				<section>
					<h3>Schritte zum Starten:</h3>
					<ol>
						<li>
							Repository klonen: <span
								style="background-color: whitesmoke; padding: 2px; border-radius: 5px;"><span
									class="hljs-keyword">git</span> <span class="hljs-built_in">clone</span>
								https://github.com/mausio/ULRICA</span>
						</li>
						<li style="text-align: start;">In Projektverzeichnis wechseln: <span
								style="background-color: whitesmoke; padding: 2px; border-radius: 5px;"><span
									class="hljs-keyword">cd </span>/path/to/ULRICA</span></li>
						<li>Projekt kompilieren: <span
								style="background-color: whitesmoke; padding: 2px; border-radius: 5px;"><span
									class="hljs-keyword">mvn</span> <span class="hljs-built_in">clean</span> <span
									class="hljs-built_in">compile</span></span>
						</li>
						<li>ULRICA starten: <span
								style="background-color: whitesmoke; padding: 2px; border-radius: 5px;"><span
									class="hljs-keyword">mvn</span> <span class="hljs-built_in">exec:java</span>
								-Dexec.mainClass="org.ulrica.App"</span>
						</li>
					</ol>
				</section>
				<section>
					<h3>Alternative zum Starten:</h3>
					<ol>
						<li>JAR-Datei erstellen: <span
								style="background-color: whitesmoke; padding: 2px; border-radius: 5px;"><span
									class="hljs-keyword">mvn</span> <span class="hljs-built_in">clean</span> <span
									class="hljs-built_in">package</span></span>
							<ul>
								<li>Dieser Befehl kompiliert den Code und erstellt eine ausführbare JAR-Datei im
									Verzeichnis <span>target/</span></li>
								<li>Die JAR-Datei wird als <span
										style="background-color: whitesmoke; padding: 2px; border-radius: 5px;"
										class="primary-color">ULRICA-1.0-SNAPSHOT.jar</span> gespeichert</li>
							</ul>
						</li>
						<li>JAR-Datei ausführen: <span
								style="background-color: whitesmoke; padding: 2px; border-radius: 5px;"><span
									class="hljs-keyword">java</span> <span class="hljs-built_in">-jar</span>
								target/ULRICA-1.0-SNAPSHOT.jar</span>
							<ul>
								<li>Stellt sicher, dass Java 17 oder höher installiert ist</li>
								<li>Die JAR-Datei enthält alle notwendigen Abhängigkeiten</li>
								<li>Kann auf jedem System mit Java 17+ ausgeführt werden</li>
							</ul>
						</li>
					</ol>
				</section>

				<section>
					<h3>Technischer Überblick (2P)</h3>
					<p class="subchapter">Nennung und Erläuterung der Technologien (z.B. Java, MySQL, …), jeweils Begründung für den Einsatz der Technologien</p>
				</section>
				<section>
					<h3>Technologien: Überblick</h3>
					<ul>
						<li><strong>Java (JDK 17):</strong> Objektorientierte Programmiersprache</li>
						<li><strong>Maven:</strong> Build-Management-Tool</li>
						<li><strong>JSON/GSON:</strong> Datenaustauschformat und Java-Bibliothek für Persistenz</li>
						<li><strong>JUnit 4:</strong> Test-Framework für automatisierten Tests</li>
						<li><strong>JaCoCo:</strong> Code-Coverage-Tool</li>
						<li><strong>Github Workflow:</strong>CI/CD Pipeline-Tool mit Maven Build</li>
					</ul>
				</section>

				<section>
					<h3>Java (JDK 17)</h3>
					<div class="horizontal-spaced-container">
						<div>
							<h5>Vorteile:</h5>
							<ul>
								<li>Plattformunabhängigkeit durch Java Virtual Machine</li>
								<li>Starke objektorientierte Programmierung</li>
								<li>Typ-Sicherheit bei Laufzeit</li>
								<li>LongTermSupport</li>
								<li>Umfangreiche Bibliotheken verfügbar -> GSON</li>
								<li>Ideale Grundlage für Clean Architecture und Implementierung von Prinzipien</li>
							</ul>
						</div>
						<div>
							<h5>Alternativen:</h5>
							<ul>
								<li><strong>Kotlin</strong>:<br>Eleganter, aber weniger etabliert (auch nicht erlaubt)
								</li>
								<li><strong>Python</strong>: <br>Einfacher, aber weniger performant und relativ
									unbekannt für mich</li>
								<li><strong>JavaScript</strong>:<br>Mir sehr bekannt, aber schwierig
									Architekturprinzipien zu implementieren (auch nicht erlaubt)</li>
							</ul>
						</div>
					</div>
				</section>

				<section>
					<h3>Maven</h3>
					<div class="horizontal-spaced-container">
						<div>
							<h5>Vorteile</h5>
							<ul>
								<li>"Plug&Play" für Nutzer:innen</li>
								<li>Konsistente Projektstruktur</li>
								<li>Automatisiertes Abhängigkeitsmanagement</li>
								<li>Standardisierte Build-Lebenszyklen</li>
								<li>Integration mit JUnit und JaCoCo</li>
								<li>Plugin-Ökosystem für erweiterte Funktionen</li>
							</ul>
						</div>
						<div>
							<h5>Konfiguration in ULRICA</h5>
							<pre><code class="xml">&lt;dependencies&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;junit&lt;/groupId&gt;
		&lt;artifactId&gt;junit&lt;/artifactId&gt;
		&lt;version&gt;4.13.2&lt;/version&gt;
		&lt;scope&gt;test&lt;/scope&gt;
	&lt;/dependency&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;
		&lt;artifactId&gt;gson&lt;/artifactId&gt;
		&lt;version&gt;2.10.1&lt;/version&gt;  
	&lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
						</div>
					</div>
				</section>

				<section>
					<h3>JSON & GSON</h3>
					<div class="horizontal-spaced-container">
						<div>
							<h5>Vorteile</h5>
							<ul>
								<li>Leichtgewichtiges Datenformat</li>
								<li>Für Menschen lesbar und einfach zu bearbeiten</li>
								<li>Ideal für Konfigurationsdaten, e.g. Fahrzeugprofile</li>
								<li>Weit verbreitet und unterstützt</li>
								<li>GSON bietet einfache Java-Integration</li>
								<li>TypeAdapter für komplexe Datentypen</li>
							</ul>
						</div>
						<div>
							<h5>Implementierung</h5>
							<pre style="width: 500px"><code class="java">public class JsonCarProfileRepository 

implements CarProfilePersistencePortInterface { // Implementierung des Persistenz-Ports für Fahrzeugprofile
	private final Gson gson; // Gson-Instanz für JSON-Serialisierung/Deserialisierung
	private final Path filePath; // Pfad zur JSON-Datei

	public JsonCarProfileRepository() {
		this.gson = new GsonBuilder() 
			.setPrettyPrinting() // Formatiert die JSON-Ausgabe lesbar
			.registerTypeAdapterFactory( // Ermöglicht die Serialisierung von Optional-Werten
				new OptionalTypeAdapterFactory())  // Registriert eine Factory zur Unterstützung von "Optional<T>"-Typen
			.create(); // Factory: Entwurfsmuster (Design Pattern) für die Erstellung von bestimmten Objekten
		this.filePath = Paths.get(
			STORAGE_DIR, FILE_NAME); // Definiert den Speicherort der JSON-Datei
	}
	// ...
}</code></pre>
						</div>
					</div>
				</section>

				<section>
					<h3>Test-Framework: JUnit</h3>
					<div class="horizontal-spaced-container">
						<div>
							<h5>Vorteile</h5>
							<ul>
								<li>De-facto Standard für Java-Tests</li>
								<li>Umfangreiche Assertions-Bibliothek</li>
								<li>Integration mit Build-Tools und JaCoCo</li>
								<li>Test-getriebene Entwicklung (TDD) wird unterstützt</li>
							</ul>
						</div>
						<div>
						</div>
					</div>
				</section>

				<section>
					<h3>Code-Coverage: JaCoCo</h3>
					<p class="subchapter">Fokus auf qualitative Tests u. kritische Komponenten, statt bloßer Maximierung
					</p>
					<div class="horizontal-spaced-container">
						<div>
							<h5>Vorteile</h5>
							<ul>
								<li>Detaillierte Abdeckungsmetriken</li>
								<li>Integration mit Maven und CI/CD</li>
								<li>Identifikation von ungetesteten Codebereichen</li>
								<li>Visualisierung der Testabdeckung</li>
								<li>Qualitätssicherung während der Entwicklung</li>
								<li>Motivation zur Erhöhung der Testabdeckung</li>
							</ul>
						</div>
						<div>
							<h5>Ergebnisse</h5>
							<ul>
								<li>Gesamtabdeckung: 47%</li>
								<li>Domain Layer: 68%</li>
								<li>Application Layer: 53%</li>
								<li>Presentation Layer: 42%</li>
								<li>Infrastructure Layer: 36%</li>
								<li>Core-Komponenten: 75%</li>
							</ul>

						</div>
					</div>
				</section>

				<section>
					<h3>Github Workflow</h3>
					<p class="subchapter">Kontinuierliche Integration und automatische Qualitätssicherung</p>
					<div class="horizontal-spaced-container">
						<div>
							<h5>Vorteile</h5>
							<ul>
								<li>Automatisierte Builds bei jedem Commit</li>
								<li>Kontinuierliche Ausführung der Tests</li>
								<li>Automatische Code-Coverage-Analyse</li>
								<li>Codequalitätsmessung mit CLOC</li>
								<li>E-Mail-Benachrichtigungen über Build-Status</li>
								<li>Früherkennung von Fehlern und Qualitätsproblemen</li>
							</ul>
						</div>
						<div>
							<h5>Implementierung</h5>
							<pre style="width: 400px"><code class="yaml">name: Java CI with Maven

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3
    
    - name: Set up JDK 17
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'temurin'
    
    - name: Build, test and check coverage
      run: mvn -B verify
    
    - name: Install CLOC
      run: sudo apt-get install -y cloc

    - name: Count Java lines of code
      run: cloc --include-lang=Java ./src/main/java/org/ulrica

    # E-Mail-Benachrichtigung über Ergebnisse
    - name: Send Email with Results
      uses: dawidd6/action-send-mail@v3
      # ...</code></pre>
						</div>
					</div>
				</section>

				<section>
					<h3>Kleines Add-On: Mails</h3>
					<div style="display: flex; flex-direction: row; justify-content: space-evenly;">
						<img src="./assets/imgs/Screenshot 2025-04-27 at 12.41.23.jpeg"
							style="height: 580px; margin: 0; border-radius: 20px;" />
						<div style="display: flex; flex-direction: column; justify-content: space-between;">
							<img src="./assets/imgs/IMG_1931.PNG"
								style="height: 280px; margin: 0; border-radius: 20px;" />
							<img src="./assets/imgs/IMG_1932.PNG"
								style="height: 280px; margin: 0; border-radius: 20px;" />
						</div>
					</div>
				</section>

				<!-- <section>
					<h3>Clean Architecture</h3>
					<div class="horizontal-spaced-container">
						<div>
							<h5>Vorteile für ULRICA</h5>
							<ul>
								<li>Separation of Concerns</li>
								<li>Unabhängige Domänenlogik</li>
								<li>Dependency Inversion Principle</li>
								<li>Testbarkeit durch lose Kopplung</li>
								<li>Austauschbarkeit von Infrastruktur</li>
								<li>Strukturierte Codebasis</li>
							</ul>
						</div>
						<div>
							<h5>Schichten in ULRICA</h5>
							<ul>
								<li><strong>Domain:</strong> 3 Packages, 23 Klassen</li>
								<li><strong>Application:</strong> 3 Packages, 26 Klassen</li>
								<li><strong>Infrastructure:</strong> 3 Packages, 7 Klassen</li>
								<li><strong>Presentation:</strong> 3 Packages, 16 Klassen</li>
							</ul>
							<p>Details in Kapitel 2: Softwarearchitektur</p>
						</div>
					</div>
				</section>

				<section>
					<h3>Architekturübersicht</h3>
					<img src="./assets/architecture.png" alt="ULRICA Architecture" style="max-height: 500px;">
					<p>Clean Architecture mit klarer Trennung der Schichten</p>
				</section> -->
			</section>
			<section alt="Kapitel 2">
				<section>
					<h2 class="chapter-title">Kapitel 2: Softwarearchitektur (8P)</h2>
				</section>

				<section>
					<h3 class="subchapter">Inhalt des Kapitels</h3>
					<div class="horizontal-spaced-container"
						style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
						<div>
							<h6>1. Gewählte Architektur (4P)</h6>
							<ul>
								<li>Clean Architecture</li>
								<li>Architekturschichten</li>
								<li>Analyse und Begründung</li>
								<li>UML der wichtigsten Klassen</li>
							</ul>
						</div>
						<div>
							<h6>2. Domain Code (1P)</h6>
							<ul>
								<li>Definition von Domain Code</li>
								<li>Code-Beispiel aus ULRICA</li>
								<li>Analyse der Domain-Schicht</li>
							</ul>
						</div>
						<div>
							<h6>3. Analyse der Dependency Rule (3P)</h6>
							<ul>
								<li>Positives Beispiel</li>
								<li>Negatives Beispiel</li>
								<li>UML der Abhängigkeiten</li>
								<li>Lösungsansätze</li>
							</ul>
						</div>
						<div>
						</div>
					</div>
				</section>


				<section>
					<h3>Gewählte Architektur (4P)</h3>
					<p class="subchapter">In der Vorlesung wurden Softwarearchitekturen vorgestellt. Welche Architektur wurde davon umgesetzt? Analyse und Begründung inkl. UML der wichtigsten Klassen, sowie Einordnung dieser Klassen in die gewählte Architektur</p>
				</section>

				<section>
					<h3>Clean Architecture</h3>
					<div class="horizontal-spaced-container">
						<ul>
							<li><b>Application Layer:</b> <br /> Implementiert Use Cases (Interfaces) über Interaktoren
								und Ports für Kommunikation</li>
							<li><b>Domain Layer:</b> <br /> Enthält die Entität, Value Objects, Services (z.B.
								Kalkulation) und Application State</li>
							<li><b>Infrastructure Layer:</b> <br /> Konkrete Implementierungen von Repositories und
								Adaptern und Utils
							</li>
							<li><b>Presentation Layer:</b> <br /> Steuert die Benutzerinteraktion über Controller und
								Views und Utils</li>
						</ul>
						<pre
							style="overflow: hidden; height: 580px; width: 700px; position: relative; margin-left: 50px; bottom: 20px; right: 20px;"><code class="">➜  ulrica git:(main) ✗ tree -d
			.
			├── application
			│   ├── port
			│   │   ├── in
			│   │   └── out
			│   ├── service
			│   └── usecase
			├── domain
			│   ├── entity
			│   ├── service
			│   └── valueobject
			├── infrastructure
			│   ├── adapter
			│   ├── persistence
			│   └── util
			└── presentation
				├── controller
				├── util
				└── view

			19 directories
	</code></pre>
					</div>
				</section>

				<section>
					<h3>Clean Architecture: UML</h3>
					<div style="display: flex; flex-direction: column;" class="horizontal-spaced-container">
						<div>
							<ul>
								<li>Domänenlogik ist unabhängig von externen Frameworks/Bibliotheken</li>
								<li>Application Layer enthält anwendungsspezifische Regeln</li>
								<li>Ports definieren Schnittstellen zwischen Schichten</li>
								<li>Adapters verbinden externe Systeme mit inneren Schichten</li>
								<li>Abhängigkeiten zeigen immer nach innen</li>
							</ul>
						</div>
						<img style="overflow: scroll; scale: 1.1; justify-self: center; align-self: center;"
							src="./assets/UMLs-imgs/clean_arch.svg" alt="ULRICA Clean Architecture" class="uml-image">
					</div>
				</section>

				<section>
					<div style="display: flex; flex-direction: column; justify-content: space-around; gap: 0;">
						<img style="margin: 0; padding: 0;" src="assets/UMLs-imgs/2-1-1.png">
						<img style="margin: 0; padding: 0;" src="assets/UMLs-imgs/2-1-2.png">
						<img style="margin: 0; padding: 0;" src="assets/UMLs-imgs/2-1-3.png">
					</div>
				</section>

				<section>
					<h3>
						Clean Architecture: <br /> Analyse u. Begründung
					</h3>
				</section>

				<section>
					<h3>Domain Layer</h3>
					<p class="subchapter">Der Domain Layer ist das <strong>Herzstück der Clean Architecture</strong> und
						enthält die gesamte Geschäftslogik ohne externe Abhängigkeiten</p>
					<ul>
						<li><strong>CarProfile</strong> (Entity): Kernentität, die ein Car mit seinen Eigenschaften
							repräsentiert</li>
						<li><strong>BatteryProfile</strong> (Value Object): Immutable Objekt, das die
							Batterieeigenschaften eines Fahrzeugs beschreibt</li>
						<li><strong>ConsumptionProfile</strong> (Value Object): Kapselt Verbrauchsdaten und
							Verbrauchfaktoren des Fahrzeugs ab</li>
						<li><strong>RangeCalculatorService</strong> (Service): Berechnet die Reichweite basierend auf
							verschiedenen Strategien</li>
						<li><strong>RangeCalculationStrategyInterface</strong>: Definiert die Schnittstelle für
							verschiedene Berechnungsalgorithmen</li>
					</ul>
				</section>

				<section>
					<h3>Application Layer</h3>
					<p class="subchapter">Der Application Layer implementiert <strong>Use Cases</strong> und definiert
						<strong>Ports</strong>. Die Klassen orchestrieren Domänenobjekte, ohne direkten Zugriff auf die
						Infrastruktur, was dadurch die <strong>Dependency Rule</strong> einhäl
					</p>
					<ul>
						<li><strong>CalculateRangeUseCaseInterface</strong> (Port): Definiert die Schnittstelle für den
							Anwendungsfall der Reichweitenberechnung</li>
						<li><strong>CalculateRangeInteractor</strong> (Use Case): Implementiert die Geschäftslogik für
							die Reichweitenberechnung</li>
						<li><strong>CarProfilePersistencePortInterface</strong> (Port): Abstrahiert die Datenpersistenz
							für Fahrzeugprofile</li>
						<li><strong>NavigationUseCase</strong> (Use Case): Steuert die Navigationslogik und
							Routenplanung</li>
					</ul>
				</section>

				<section>
					<h3>Infrastructure Layer</h3>
					<p class="subchapter">Der Infrastructure Layer implementiert <strong>konkrete Adapter</strong> für
						externe Systeme. Diese Klassen sind austauschbar ohne Änderungen an inneren Schichten, was
						wichtig für e.g. <strong>OCP</strong> wichtig ist.</p>
					<ul>
						<li><strong>JsonCarProfileRepository</strong>: Implementiert die Persistenz von Fahrzeugprofilen
							als JSON-Dateien</li>
						<li><strong>ConsoleUserInputAdapter</strong>: Verarbeitet Benutzereingaben über die Konsole</li>
						<li><strong>ConsoleUserOutputAdapter</strong>: Zeigt Ausgaben und Ergebnisse in der Konsole an
						</li>
						<li><strong>ValidationUtils</strong>: Hilfsmethoden zur Validierung von Eingabedaten</li>
					</ul>
				</section>

				<section>
					<h3>Presentation Layer</h3>
					<p class="subchapter">Der Presentation Layer kapselt die Benutzerinteraktion. Diese Klassen
						kommunizieren nur über definierte Schnittstellen mit inneren Schichten, was eine <strong>klare
							Trennung von UI und Geschäftslogik</strong> gewährleistet</p>
					<ul>
						<li><strong>ApplicationControllerWithActionMenu</strong>: Hauptcontroller, der die verschiedenen
							Aktionen der Anwendung steuert</li>
						<li><strong>RangeCalculationController</strong>: Spezialisierter Controller für die
							Reichweitenberechnung</li>
						<li><strong>ActionMenuView</strong>: Stellt das Hauptmenü der Anwendung dar</li>
						<li><strong>CarProfileView</strong>: Visualisiert die Fahrzeugprofile und deren Details</li>
					</ul>
				</section>

				<section>
					<h3>Domain Code (1P)</h3>
					<p class="subchapter">Kurze Erläuterung in eigenen Worten, was Domain Code ist – 1 Beispiel im Code zeigen, das bisher noch nicht gezeigt wurde.</p>
					<ul>
						<li>Bildet die Fachlogik der Domäne (Geschäftsregeln) ab</li>
						<li>Modelliert Prozesse, Regeln und Datenstrukturen</li>
						<li>Unabhängig von externen Systemen (Datenbank, UI, Frameworks,...)</li>
						<li>Bleibt Stabil bei Änderung (an Technologien)</li>
						<li>Domäne orientiert (Entity, Valueobject, Aggregate)</li>
						<li>Bleibt fachlich und ist frei von Presentation- und Persistenzlogik (siehe Domainlayer)</li>
					</ul>
				</section>

				<section>
					<h3>Beispiel Domain Code: RangeCalculatorService</h3>
					<pre><code class="java" >public class RangeCalculatorService { // Reichweitenberechnung innerhalb der Domäne
	private final List<RangeCalculationStrategyInterface> strategies; // Hält verschiedene fachliche Berechnungsstrategien
	private RangeCalculationStrategyInterface defaultStrategy; // Definiert, welche Strategie standardmäßig verwendet wird

	public RangeCalculatorService() { // wird direkt mit zwei vordefinierten Strategien gestartet
		this.strategies = new ArrayList<>();
		
		WltpBasedRangeCalculationStrategy wltpStrategy = new WltpBasedRangeCalculationStrategy(); // Strategie basierend auf WLTP-Standard
		ConsumptionBasedRangeCalculationStrategy consumptionStrategy = new ConsumptionBasedRangeCalculationStrategy(); // Strategie basierend auf realem Verbrauch

		this.strategies.add(wltpStrategy); // Beide Strategien werden in die Domain-intern verfügbare Liste aufgenommen
		this.strategies.add(consumptionStrategy);

		this.defaultStrategy = consumptionStrategy; // Standardmäßig wird die Verbrauchsstrategie für Berechnungen genutzt
	}
	
	public void addStrategy(RangeCalculationStrategyInterface strategy) { // neue Strategien werden fachlich verfügbar gemacht
		Objects.requireNonNull(strategy, "Strategy cannot be null"); // Eine Strategie muss immer gültig sein
		strategies.add(strategy); // Neue Strategie wird der Liste hinzugefügt
	}
	
	public void setDefaultStrategy(RangeCalculationStrategyInterface strategy) { // Hier kann eine andere Standardstrategie gesetzt werden
		Objects.requireNonNull(strategy, "Strategy cannot be null"); // Die Strategie darf nicht null sein
		if (!strategies.contains(strategy)) { // Falls sie noch nicht bekannt ist, wird sie aufgenommen
			strategies.add(strategy);
		}
		this.defaultStrategy = strategy; // Danach wird sie als neue Standardstrategie gespeichert
	}
	
	public List<RangeCalculationStrategyInterface> getAvailableStrategies() { // Gibt alle aktuell verfügbaren Strategien der Domäne zurück
		return new ArrayList<>(strategies); // Liefert eine Kopie, damit die interne Liste geschützt bleibt
	}
	
	public RangeCalculationStrategyInterface getDefaultStrategy() { // Gibt die aktuelle Standardstrategie zurück
		return defaultStrategy;
	}
	
	public RangeResult calculateRange(CarProfile carProfile, RangeParameters parameters) { // Berechnet die Reichweite basierend auf dem Fahrzeugprofil und Standardstrategie
		Objects.requireNonNull(carProfile, "Car profile cannot be null"); // Ein Fahrzeugprofil ist zwingend notwendig
		Objects.requireNonNull(parameters, "Range parameters cannot be null"); // Auch die Parameter müssen angegeben sein
		
		return defaultStrategy.calculateRange(carProfile, parameters); // Übergibt die Berechnung an die Standardstrategie
	}
	
	public RangeResult calculateRangeWithStrategy(CarProfile carProfile, RangeParameters parameters, RangeCalculationStrategyInterface strategy) { // Alternativ kann eine konkrete Strategie verwendet werden
		Objects.requireNonNull(carProfile, "Car profile cannot be null"); // Fahrzeugprofil darf nicht fehlen
		Objects.requireNonNull(parameters, "Range parameters cannot be null"); // Parameter dürfen nicht fehlen
		Objects.requireNonNull(strategy, "Strategy cannot be null"); // Auch die Strategie muss vorhanden sein
		
		return strategy.calculateRange(carProfile, parameters); // Übergibt die Berechnung an die angegebene Strategie
	}
}</code></pre>
				</section>

				<section>
					<h3>Analyse des Domain Codes</h3>
					<ul>
						<li>Service kapselt reine Fachlogik zur Reichweitenberechnung</li>
						<li>Strategien sind fachliche Varianten zur Reichweitenermittlung</li>
						<li>Keine technische Infrastruktur wie DB, API oder UI enthalten</li>
						<li>Arbeitet nur mit Domain-spezifischen Typen (CarProfile, RangeParameters)</li>
						<li>Erweiterbarkeit durch neue Strategien innerhalb der Domäne möglich</li>
						<li>Berechnungen (calculateRange) folgen direkt fachlichen Regeln</li>
					</ul>
				</section>

				<section>
					<h3>Analyse der Dependency Rule (3P)</h3>
					<p class="subchapter">In der Vorlesung wurde im Rahmen der ‘Clean Architecture’ die s.g. Dependency
						Rule vorgestellt. Je 1 Klasse zeigen, die die Dependency Rule einhält und 1 Klasse, die die
						Dependency Rule verletzt; jeweils UML (mind. die betreffende Klasse inkl. der Klassen, die von
						ihr abhängen bzw. von der sie abhängt) und Analyse der Abhängigkeiten in beide Richtungen (d.h.,
						von wem hängt die Klasse ab und wer hängt von der Klasse ab) in Bezug auf die Dependency Rule
					</p>
				</section>

				

				<section>
					<h3>Analyse der Dependency Rule </h3>
					<ul>
						<li>Die Abhängigkeiten zeigen nur zum Zentrum der Architektur (größtenteils)</li>
						<li>Innere Schichten (Domain) dürfen nichts über äußere Schichten wissen</li>
						<li>Äußere Schichten (Infrastruktur) dürfen von inneren abhängen</li>
						<li>Die Abstraktionen (Interfaces) gehören zur inneren Schicht</li>
						<li>Die Implementierungen gehören zur äußeren Schicht</li>
					</ul>
					<img src="assets/UMLs-imgs/Kapitel_2-Aufgabe_3.png" alt="Dependency Rule UML" class="uml-image">
				</section>

				<section>
					<h3>Positives Beispiel: CalculateRangeInteractor</h3>
					<pre><code class="java">public class CalculateRangeInteractor implements CalculateRangeUseCaseInterface {
					
					private final RangeCalculatorService rangeCalculatorService;
					private final RangeCalculationOutputPortInterface outputPort;
					private final ProfileSelectionService profileSelectionService;
					
					public CalculateRangeInteractor(
							RangeCalculatorService rangeCalculatorService,
							RangeCalculationOutputPortInterface outputPort,
							ProfileSelectionService profileSelectionService) {
						this.rangeCalculatorService = Objects.requireNonNull(rangeCalculatorService);
						this.outputPort = Objects.requireNonNull(outputPort);
						this.profileSelectionService = Objects.requireNonNull(profileSelectionService);
					}
					
					@Override
					public void calculateRange(CalculateRangeCommand command) {
						CarProfile profile = profileSelectionService.getSelectedProfile();
						// Weitere Implementierung...
						
						RangeResult result = rangeCalculatorService.calculateRange(profile, parameters);
						outputPort.displayRangeResult(result);
					}
				}</code></pre>
				</section>

				<section>
					<h3>UML: Positives Beispiel</h3>
					<img src="assets/UMLs-imgs/Kapitel_2-Aufgabe_3-Dependency_Rule_Positiv.png" alt="Positive Dependency Rule Example UML" class="uml-image">
				</section>

				<section>
					<h3>Analyse des positiven Beispiels</h3>
					<ul>
						<li>Implementiert ein Interface aus der Application-Schicht</li>
						<li>Abhängigkeiten werden über Konstruktor-Injection bereitgestellt</li>
						<li>Abhängigkeiten sind alle Interfaces oder Domain-Services</li>
						<li>Keine Abhängigkeit zu konkreten Implementierungen der äußeren Schichten</li>
						<li>Ausgabe erfolgt über ein Port-Interface (RangeCalculationOutputPortInterface)</li>
						<li>Strikte Validierung mit Objects.requireNonNull()</li>
					</ul>
				</section>

				<section>
					<h3>Negatives Beispiel: JsonCarProfileRepository</h3>
					<pre><code class="java">public class JsonCarProfileRepository implements CarProfilePersistencePortInterface {
					private static final String STORAGE_DIR = "data";
					private static final String FILE_NAME = "car_profiles.json";
					private final Gson gson;
					private final Path filePath;
				
					public JsonCarProfileRepository() {
						this.gson = new GsonBuilder()
								.setPrettyPrinting()
								.registerTypeAdapterFactory(new OptionalTypeAdapterFactory())
								.create();
						this.filePath = Paths.get(STORAGE_DIR, FILE_NAME);
						ensureStorageDirectoryExists();
					}
					
					@Override
					public List<CarProfile> findAll() {
						try (FileReader reader = new FileReader(filePath.toFile())) {
							Type listType = new TypeToken<List<CarProfile>>() {}.getType();
							List<CarProfile> profiles = gson.fromJson(reader, listType);
							return profiles != null ? profiles : new ArrayList<>();
						} catch (IOException e) {
							throw new RuntimeException("Failed to read car profiles", e);
						}
					}
				}</code></pre>
				</section>

				<section>
					<h3>UML: Negatives Beispiel</h3>
					<img src="assets/UMLs-imgs/Kapitel_2-Aufgabe_3-Dependency_Rule_Negative.png" alt="Negative Dependency Rule Example UML" class="uml-image">
				</section>

				<section>
					<h3>Analyse des negativen Beispiels</h3>
					<div class="horizontal-spaced-container">
						<div>
							<p>Verstöße gegen die Dependency Rule:</p>
							<ul>
								<li>Direkte Abhängigkeit zu externen Bibliotheken (Gson)</li>
								<li>Direkter Zugriff auf das Dateisystem (java.io, java.nio)</li>
								<li>Hartcodierte Pfade (STORAGE_DIR, FILE_NAME)</li>
								<li>Ausnahmebehandlung mit generischen Exceptions</li>
								<li>Direkte Implementierung der Dateioperationen</li>
							</ul>
						</div>
						<div>
							<p>Verbesserungsvorschlag:</p>
							<ul>
								<li>Einführung eines FileStoragePortInterface</li>
								<li>Auslagerung der JSON-Serialisierung</li>
								<li>Konfigurierbare Pfade (z.B. über Umgebungsvariablen)</li>
								<li>Fachliche Exceptions wie ProfileNotFoundException</li>
								<li>Strikte Trennung von Persistenz und Domänenmodell</li>
							</ul>
						</div>
					</div>
				</section>
			</section>
			<!-- <section data-include="slides/kapitel-3.html"></section>
			<section data-include="slides/kapitel-4.html"></section>
			<section data-include="slides/kapitel-5.html"></section>
			<section data-include="slides/kapitel-6.html"></section>
			<section data-include="slides/kapitel-7.html"></section>
			<section data-include="slides/kapitel-8.html"></section> -->
		</div>
	</div>

	<script src="dist/reveal.js"></script>
	<script src="plugin/notes/notes.js"></script>
	<script src="plugin/markdown/markdown.js"></script>
	<script src="plugin/highlight/highlight.js"></script>
	<script>
		// Debug logging
		console.log('RevealHighlight plugin:', typeof RevealHighlight);
		console.log('hljs global:', typeof window.hljs);

		// More info about initialization & config:
		// - https://revealjs.com/initialization/
		// - https://revealjs.com/config/
		Reveal.initialize({
			hash: true,
			slideNumber: true,

			// Explicit highlight config
			highlight: {
				highlightOnLoad: true,
				escapeHTML: false
			},

			// Learn about plugins: https://revealjs.com/plugins/
			plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
		});

		// Load all slide content, then initialize highlight.js
		const loadSlidesPromises = [];
		document.querySelectorAll('[data-include]').forEach((section) => {
			const url = section.getAttribute('data-include');
			const promise = fetch(url)
				.then(response => response.text())
				.then(html => {
					section.html = ""
					section.innerHTML = html;
				});
			loadSlidesPromises.push(promise);
		});

		// After all slides are loaded, re-initialize highlight.js
		Promise.all(loadSlidesPromises).then(() => {
			// Force Reveal to update
			Reveal.sync();

			// Try multiple ways to initialize highlighting

			// 1. Through Reveal plugin
			const highlight = Reveal.getPlugin('highlight');
			if (highlight) {
				document.querySelectorAll('code').forEach(block => {
					highlight.highlightBlock(block);
				});
			}

			// 2. Direct hljs initialization if available
			if (window.hljs) {
				window.hljs.configure({
					languages: ['bash', 'javascript', 'html', 'xml', 'css']
				});
				document.querySelectorAll('code.bash, code.hljs.bash').forEach(block => {
					window.hljs.highlightElement(block);
				});
			}
		});
	</script>
</body>

</html>