<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>ULRICA - Programmentwurf Protokoll</title>

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/white.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/lightfair.css">
</head>
<style>
	code:not(.hljs) {
		font-size: 1.25rem;
	}

	pre {
		border-radius: 5px;
	}

	code {
		border-radius: 5px;
		font-size: 0.9rem !important;
	}


	/* Syntax highlighting styles similar to the screenshot */
	.hljs-keyword {
		color: blue;
		/* softer green */
		font-weight: 500;
	}

	.hljs-built_in {
		color: darkblue;
		font-weight: normal;
	}

	.hljs-string {
		color: rgb(0, 167, 206);
		/* softer yellow/orange */
		font-weight: normal;
	}

	.hljs {
		font-size: 1.25rem;
		background: transparent;
		display: inline;
	}

	h1 {
		font-size: 4rem;
	}

	h2 {
		font-size: 3rem;
	}

	h3 {
		font-size: 2.5rem;
	}

	h4 {
		font-size: 2.25rem;
		font-weight: semibold;
	}

	h5 {
		font-size: 2rem;
		font-weight: semibold;
	}

	h6 {
		font-size: 1.75rem;
		font-weight: semibold;
	}

	p {
		font-size: 1.75rem;
	}

	li {
		font-size: 1.75rem;
		margin: 5px 0;
	}

	ul {
		text-align: start;
		align-self: start;
	}

	ol {
		text-align: start;
		align-self: start;
	}

	thead {
		font-size: 1.4rem;
	}

	tr {
		font-size: 1.3rem;
	}

	th {
		font-size: 1.4rem;
	}




	.primary-color {
		color: rgb(0, 167, 206) !important;
	}


	.horizontal-container {
		display: flex;
		gap: 2rem;
		justify-content: center;
	}

	.horizontal-spaced-container {
		display: flex;
		gap: 2rem;
		justify-content: space-evenly;
	}

	.gray {
		color: #808080;
	}

	.slide-number {
		font-size: 16px !important;
		color: #333 !important;
		background-color: rgba(255, 255, 255, 0.7);
		padding: 3px 8px !important;
		border-radius: 10px;
	}

	.chapter-title {
		font-size: 3.5rem;
		margin-bottom: 2rem;
		color: #333;
		text-align: center;
	}

	.uml-image {
		max-width: 90%;
		max-height: 70vh;
		margin: 0 auto;
	}

	.center {
		text-align: center;
	}

	.acronym-letter {
		font-weight: 900;
		font-size: 120%;
	}

	.name-explanation {
		font-size: 2.5rem;
		text-align: center;
		margin: 2rem 0;
	}

	.subchapter {
		color: #666;
		font-size: 1.8rem;
		margin-top: 1rem;
		font-style: italic;
	}
</style>

<body>
	<div class="reveal">
		<div class="slides">

			<section alt="Anfang/Einleitung">
				<h3>Programmentwurf - Protokoll</h3>
				<p class="gray center">zu</p>
				<img style="margin: 50px 0;" src="./assets/imgs/ulrica-blue.png" alt="ULRICA Logo" class="logo">
				<div class="horizontal-container gray">
					<p>Robin Schwenzfeier</p>
					<p>-</p>
					<p>4868455</p>
					<p>-</p>
					<p>TINF21CS1</p>
				</div>
			</section>
			<section alt="Kapitel 1">
				<section>
					<h2 class="chapter-title">Kapitel 1:<br /> Einleitung (4P)</h2>
				</section>

				<section>
					<h3 class="subchapter">Inhalt des Kapitels</h3>
					<div class="horizontal-spaced-container"
						style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
						<div>
							<h6>1. Übersicht über die Applikation (1P)</h6>
							<ul>
								<li>Name und Bedeutung</li>
								<li>Features und Funktionen</li>
								<li>Probleme, die sie löst</li>
							</ul>
						</div>
						<div>
							<h6>2. Starten der Applikation (1P)</h6>
							<ul>
								<li>Voraussetzungen</li>
								<li>Schritte zum Starten</li>
								<li>Alternative zum Starten</li>
							</ul>
						</div>
						<div>
							<h6>3. Technischer Überblick (2P)</h6>
							<ul>
								<li>Java (JDK 17)</li>
								<li>Maven</li>
								<li>JSON & GSON</li>
								<li>JUnit & JaCoCo</li>
								<li>Clean Architecture</li>
							</ul>
						</div>
						<div>
						</div>
					</div>
				</section>

				<section>
					<h3>Übersicht über die Applikation (1P)</h3>
					<p class="subchapter">Was macht die Applikation? Wie funktioniert sie? Welches Problem löst
						sie/welchen Zweck hat sie?</p>
				</section>

				<section>
					<h3><strong>ULRICA</strong>: Name erklärt</h3>
					<p class="subchapter">Ein Acronym.</p>
					<p class="name-explanation">
						<span class="acronym-letter primary-color">U</span>niversa<span
							class="acronym-letter primary-color">L</span>
						<span class="acronym-letter primary-color">R</span>ange and dest<span
							class="acronym-letter primary-color">I</span>nation
						<span class="acronym-letter primary-color">CA</span>lculator
					</p>
				</section>

				<section>
					<h3>Features der Applikation</h3>
					<p class="subchapter">Probleme, die sie löst.</p>
					<ul>
						<li><span class="primary-color">1.</span> Erstellt und verwaltet Fahrzeugprofile für
							Elektrofahrzeuge</li>
						<li><span class="primary-color">2.</span> Berechnet verbleibende Reichweite von
							Elektrofahrzeugen</li>
						<li><span class="primary-color">3. + 4.</span> Berechnet Ladezeiten an DC- und AC-Ladestationen
						</li>
						<li><s><span class="primary-color">5.</span> Berechnet und simmuliert eine Route</s></li>
					</ul>
				</section>

				<section>
					<h3>Features der Applikation</h3>
					<div class="horizontal-spaced-container">
						<div>
							<h5><span class="primary-color">1.</span> Fahrzeugprofil-Management</h5>
							<ul>
								<li>Erstellung, Anzeige und Löschung von Fahrzeugprofilen</li>
								<li>Konfiguration von Batteriedaten (Typ, Kapazität, Degradation, etc.)</li>
								<li>Definition von Verbrauchsprofilen (bei 50km/h, 100km/h, 130km/h)</li>
							</ul>
						</div>
						<div>
							<h5><span class="primary-color">2.</span> Reichweitenberechnung</h5>
							<ul>
								<li>Strategie-Pattern für verschiedene Berechnungsmethoden</li>
								<li>WLTP-basierte Berechnung mit "echten" Bedingungen</li>
								<li>Temperatureinflüsse</li>
								<li>Geländebedingungen</li>
								<li>etc.</li>
							</ul>
						</div>
					</div>
				</section>

				<section>
					<h3>Features der Applikation</h3>
					<div class="horizontal-spaced-container">
						<div>
							<h5><span class="primary-color">3.</span> DC (Schnelles) Laden</h5>
							<ul>
								<li>SoC-basierte Berechnungen</li>
								<li>Temperatureinflüsse beim Laden</li>
								<li>Leistungsreduktion basierend auf Batteriezustand</li>
								<li>Detaillierte Ladezeitschätzungen</li>
								<li>Berücksichtigung von Batterie-Typ</li>
							</ul>
						</div>
						<div>
							<h5><span class="primary-color">4.</span> AC (Langsames) Laden</h5>
							<ul>
								<li>Verschiedene Anschlusstypen (Haushalt, Camping, Wallbox)</li>
								<li>Berechnung von Effizienzverlusten</li>
								<li>Temperatur-Effizenzfaktoren</li>
								<li>Ladezeitprognosen</li>
							</ul>
						</div>
					</div>
				</section>


				<section>
					<h3>Starten der Applikation (1P)</h3>
					<p class="subchapter">Wie startet man die Applikation? Was für Voraussetzungen werden benötigt?
						Schritt-für-Schritt-Anleitung</p>
				</section>
				<section>
					<h3>Voraussetzungen:</h3>
					<ul>
						<li>Java 17 oder höher</li>
						<li>Maven</li>
						<li>Git</li>
					</ul>
				</section>
				<section>
					<h3>Schritte zum Starten:</h3>
					<ol>
						<li>
							Repository klonen: <span
								style="background-color: whitesmoke; padding: 2px; border-radius: 5px;"><span
									class="hljs-keyword">git</span> <span class="hljs-built_in">clone</span>
								https://github.com/mausio/ULRICA</span>
						</li>
						<li style="text-align: start;">In Projektverzeichnis wechseln: <span
								style="background-color: whitesmoke; padding: 2px; border-radius: 5px;"><span
									class="hljs-keyword">cd </span>/path/to/ULRICA</span></li>
						<li>Projekt kompilieren: <span
								style="background-color: whitesmoke; padding: 2px; border-radius: 5px;"><span
									class="hljs-keyword">mvn</span> <span class="hljs-built_in">clean</span> <span
									class="hljs-built_in">compile</span></span>
						</li>
						<li>ULRICA starten: <span
								style="background-color: whitesmoke; padding: 2px; border-radius: 5px;"><span
									class="hljs-keyword">mvn</span> <span class="hljs-built_in">exec:java</span>
								-Dexec.mainClass="org.ulrica.App"</span>
						</li>
					</ol>
				</section>
				<section>
					<h3>Alternative zum Starten:</h3>
					<ol>
						<li>JAR-Datei erstellen: <span
								style="background-color: whitesmoke; padding: 2px; border-radius: 5px;"><span
									class="hljs-keyword">mvn</span> <span class="hljs-built_in">clean</span> <span
									class="hljs-built_in">package</span></span>
							<ul>
								<li>Dieser Befehl kompiliert den Code und erstellt eine ausführbare JAR-Datei im
									Verzeichnis <span>target/</span></li>
								<li>Die JAR-Datei wird als <span
										style="background-color: whitesmoke; padding: 2px; border-radius: 5px;"
										class="primary-color">ULRICA-1.0-SNAPSHOT.jar</span> gespeichert</li>
							</ul>
						</li>
						<li>JAR-Datei ausführen: <span
								style="background-color: whitesmoke; padding: 2px; border-radius: 5px;"><span
									class="hljs-keyword">java</span> <span class="hljs-built_in">-jar</span>
								target/ULRICA-1.0-SNAPSHOT.jar</span>
							<ul>
								<li>Stellt sicher, dass Java 17 oder höher installiert ist</li>
								<li>Die JAR-Datei enthält alle notwendigen Abhängigkeiten</li>
								<li>Kann auf jedem System mit Java 17+ ausgeführt werden</li>
							</ul>
						</li>
					</ol>
				</section>

				<section>
					<h3>Technischer Überblick (2P)</h3>
					<p class="subchapter">Nennung und Erläuterung der Technologien (z.B. Java, MySQL, …), jeweils
						Begründung für den Einsatz der Technologien</p>
				</section>
				<section>
					<h3>Technologien: Überblick</h3>
					<ul>
						<li><strong>Java (JDK 17):</strong> Objektorientierte Programmiersprache</li>
						<li><strong>Maven:</strong> Build-Management-Tool</li>
						<li><strong>JSON/GSON:</strong> Datenaustauschformat und Java-Bibliothek für Persistenz</li>
						<li><strong>JUnit 4:</strong> Test-Framework für automatisierten Tests</li>
						<li><strong>JaCoCo:</strong> Code-Coverage-Tool</li>
						<li><strong>Github Workflow:</strong>CI/CD Pipeline-Tool mit Maven Build</li>
					</ul>
				</section>

				<section>
					<h3>Java (JDK 17)</h3>
					<div class="horizontal-spaced-container">
						<div>
							<h5>Vorteile:</h5>
							<ul>
								<li>Plattformunabhängigkeit durch Java Virtual Machine</li>
								<li>Starke objektorientierte Programmierung</li>
								<li>Typ-Sicherheit bei Laufzeit</li>
								<li>LongTermSupport</li>
								<li>Umfangreiche Bibliotheken verfügbar -> GSON</li>
								<li>Ideale Grundlage für Clean Architecture und Implementierung von Prinzipien</li>
							</ul>
						</div>
						<div>
							<h5>Alternativen:</h5>
							<ul>
								<li><strong>Kotlin</strong>:<br>Eleganter, aber weniger etabliert (auch nicht erlaubt)
								</li>
								<li><strong>Python</strong>: <br>Einfacher, aber weniger performant und relativ
									unbekannt für mich</li>
								<li><strong>JavaScript</strong>:<br>Mir sehr bekannt, aber schwierig
									Architekturprinzipien zu implementieren (auch nicht erlaubt)</li>
							</ul>
						</div>
					</div>
				</section>

				<section>
					<h3>Maven</h3>
					<div class="horizontal-spaced-container">
						<div>
							<h5>Vorteile</h5>
							<ul>
								<li>"Plug&Play" für Nutzer:innen</li>
								<li>Konsistente Projektstruktur</li>
								<li>Automatisiertes Abhängigkeitsmanagement</li>
								<li>Standardisierte Build-Lebenszyklen</li>
								<li>Integration mit JUnit und JaCoCo</li>
								<li>Plugin-Ökosystem für erweiterte Funktionen</li>
							</ul>
						</div>
						<div>
							<h5>Konfiguration in ULRICA</h5>
							<pre><code class="xml">&lt;dependencies&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;junit&lt;/groupId&gt;
		&lt;artifactId&gt;junit&lt;/artifactId&gt;
		&lt;version&gt;4.13.2&lt;/version&gt;
		&lt;scope&gt;test&lt;/scope&gt;
	&lt;/dependency&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;
		&lt;artifactId&gt;gson&lt;/artifactId&gt;
		&lt;version&gt;2.10.1&lt;/version&gt;  
	&lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
						</div>
					</div>
				</section>

				<section>
					<h3>JSON & GSON</h3>
					<div class="horizontal-spaced-container">
						<div>
							<h5>Vorteile</h5>
							<ul>
								<li>Leichtgewichtiges Datenformat</li>
								<li>Für Menschen lesbar und einfach zu bearbeiten</li>
								<li>Ideal für Konfigurationsdaten, e.g. Fahrzeugprofile</li>
								<li>Weit verbreitet und unterstützt</li>
								<li>GSON bietet einfache Java-Integration</li>
								<li>TypeAdapter für komplexe Datentypen</li>
							</ul>
						</div>
						<div>
							<h5>Implementierung</h5>
							<pre style="width: 500px"><code class="java">public class JsonCarProfileRepository 

implements CarProfilePersistencePortInterface { // Implementierung des Persistenz-Ports für Fahrzeugprofile
	private final Gson gson; // Gson-Instanz für JSON-Serialisierung/Deserialisierung
	private final Path filePath; // Pfad zur JSON-Datei

	public JsonCarProfileRepository() {
		this.gson = new GsonBuilder() 
			.setPrettyPrinting() // Formatiert die JSON-Ausgabe lesbar
			.registerTypeAdapterFactory( // Ermöglicht die Serialisierung von Optional-Werten
				new OptionalTypeAdapterFactory())  // Registriert eine Factory zur Unterstützung von "Optional<T>"-Typen
			.create(); // Factory: Entwurfsmuster (Design Pattern) für die Erstellung von bestimmten Objekten
		this.filePath = Paths.get(
			STORAGE_DIR, FILE_NAME); // Definiert den Speicherort der JSON-Datei
	}
	// ...
}</code></pre>
						</div>
					</div>
				</section>

				<section>
					<h3>Test-Framework: JUnit</h3>
					<div class="horizontal-spaced-container">
						<div>
							<h5>Vorteile</h5>
							<ul>
								<li>De-facto Standard für Java-Tests</li>
								<li>Umfangreiche Assertions-Bibliothek</li>
								<li>Integration mit Build-Tools und JaCoCo</li>
								<li>Test-getriebene Entwicklung (TDD) wird unterstützt</li>
							</ul>
						</div>
						<div>
						</div>
					</div>
				</section>

				<section>
					<h3>Code-Coverage: JaCoCo</h3>
					<p class="subchapter">Fokus auf qualitative Tests u. kritische Komponenten, statt bloßer Maximierung
					</p>
					<div class="horizontal-spaced-container">
						<div>
							<h5>Vorteile</h5>
							<ul>
								<li>Detaillierte Abdeckungsmetriken</li>
								<li>Integration mit Maven und CI/CD</li>
								<li>Identifikation von ungetesteten Codebereichen</li>
								<li>Visualisierung der Testabdeckung</li>
								<li>Qualitätssicherung während der Entwicklung</li>
								<li>Motivation zur Erhöhung der Testabdeckung</li>
							</ul>
						</div>
						<div>
							<h5>Ergebnisse</h5>
							<ul>
								<li>Gesamtabdeckung: 47%</li>
								<li>Domain Layer: 68%</li>
								<li>Application Layer: 53%</li>
								<li>Presentation Layer: 42%</li>
								<li>Infrastructure Layer: 36%</li>
								<li>Core-Komponenten: 75%</li>
							</ul>

						</div>
					</div>
				</section>

				<section>
					<h3>Github Workflow</h3>
					<p class="subchapter">Kontinuierliche Integration und automatische Qualitätssicherung</p>
					<div class="horizontal-spaced-container">
						<div>
							<h5>Vorteile</h5>
							<ul>
								<li>Automatisierte Builds bei jedem Commit</li>
								<li>Kontinuierliche Ausführung der Tests</li>
								<li>Automatische Code-Coverage-Analyse</li>
								<li>Codequalitätsmessung mit CLOC</li>
								<li>E-Mail-Benachrichtigungen über Build-Status</li>
								<li>Früherkennung von Fehlern und Qualitätsproblemen</li>
							</ul>
						</div>
						<div>
							<h5>Implementierung</h5>
							<pre style="width: 400px"><code class="yaml">name: Java CI with Maven

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3
    
    - name: Set up JDK 17
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'temurin'
    
    - name: Build, test and check coverage
      run: mvn -B verify
    
    - name: Install CLOC
      run: sudo apt-get install -y cloc

    - name: Count Java lines of code
      run: cloc --include-lang=Java ./src/main/java/org/ulrica

    # E-Mail-Benachrichtigung über Ergebnisse
    - name: Send Email with Results
      uses: dawidd6/action-send-mail@v3
      # ...</code></pre>
						</div>
					</div>
				</section>

				<section>
					<h3>Kleines Add-On: Mails</h3>
					<div style="display: flex; flex-direction: row; justify-content: space-evenly;">
						<img src="./assets/imgs/Screenshot 2025-04-27 at 12.41.23.jpeg"
							style="height: 580px; margin: 0; border-radius: 20px;" />
						<div style="display: flex; flex-direction: column; justify-content: space-between;">
							<img src="./assets/imgs/IMG_1931.PNG"
								style="height: 280px; margin: 0; border-radius: 20px;" />
							<img src="./assets/imgs/IMG_1932.PNG"
								style="height: 280px; margin: 0; border-radius: 20px;" />
						</div>
					</div>
				</section>

				<!-- <section>
					<h3>Clean Architecture</h3>
					<div class="horizontal-spaced-container">
						<div>
							<h5>Vorteile für ULRICA</h5>
							<ul>
								<li>Separation of Concerns</li>
								<li>Unabhängige Domänenlogik</li>
								<li>Dependency Inversion Principle</li>
								<li>Testbarkeit durch lose Kopplung</li>
								<li>Austauschbarkeit von Infrastruktur</li>
								<li>Strukturierte Codebasis</li>
							</ul>
						</div>
						<div>
							<h5>Schichten in ULRICA</h5>
							<ul>
								<li><strong>Domain:</strong> 3 Packages, 23 Klassen</li>
								<li><strong>Application:</strong> 3 Packages, 26 Klassen</li>
								<li><strong>Infrastructure:</strong> 3 Packages, 7 Klassen</li>
								<li><strong>Presentation:</strong> 3 Packages, 16 Klassen</li>
							</ul>
							<p>Details in Kapitel 2: Softwarearchitektur</p>
						</div>
					</div>
				</section>

				<section>
					<h3>Architekturübersicht</h3>
					<img src="./assets/architecture.png" alt="ULRICA Architecture" style="max-height: 500px;">
					<p>Clean Architecture mit klarer Trennung der Schichten</p>
				</section> -->
			</section>
			<section alt="Kapitel 2">
				<section>
					<h2 class="chapter-title">Kapitel 2: <br /> Softwarearchitektur (8P)</h2>
				</section>

				<section>
					<h3 class="subchapter">Inhalt des Kapitels</h3>
					<div class="horizontal-spaced-container"
						style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
						<div>
							<h6>1. Gewählte Architektur (4P)</h6>
							<ul>
								<li>Clean Architecture</li>
								<li>Architekturschichten</li>
								<li>Analyse und Begründung</li>
								<li>UML der wichtigsten Klassen</li>
							</ul>
						</div>
						<div>
							<h6>2. Domain Code (1P)</h6>
							<ul>
								<li>Definition von Domain Code</li>
								<li>Code-Beispiel aus ULRICA</li>
								<li>Analyse der Domain-Schicht</li>
							</ul>
						</div>
						<div>
							<h6>3. Analyse der Dependency Rule (3P)</h6>
							<ul>
								<li>Positives Beispiel</li>
								<li>Negatives Beispiel</li>
								<li>UML der Abhängigkeiten</li>
								<li>Lösungsansätze</li>
							</ul>
						</div>
						<div>
						</div>
					</div>
				</section>


				<section>
					<h3>Gewählte Architektur (4P)</h3>
					<p class="subchapter">In der Vorlesung wurden Softwarearchitekturen vorgestellt. Welche Architektur
						wurde davon umgesetzt? Analyse und Begründung inkl. UML der wichtigsten Klassen, sowie
						Einordnung dieser Klassen in die gewählte Architektur</p>
				</section>

				<section>
					<h3>Clean Architecture</h3>
					<div class="horizontal-spaced-container">
						<ul>
							<li><b>Application Layer:</b> <br /> Implementiert Use Cases (Interfaces) über Interaktoren
								und Ports für Kommunikation</li>
							<li><b>Domain Layer:</b> <br /> Enthält die Entität, Value Objects, Services (z.B.
								Kalkulation) und Application State</li>
							<li><b>Infrastructure Layer:</b> <br /> Konkrete Implementierungen von Repositories und
								Adaptern und Utils
							</li>
							<li><b>Presentation Layer:</b> <br /> Steuert die Benutzerinteraktion über Controller und
								Views und Utils</li>
						</ul>
						<pre
							style="overflow: hidden; height: 580px; width: 700px; position: relative; margin-left: 50px; bottom: 20px; right: 20px;"><code class="">➜  ulrica git:(main) ✗ tree -d
			.
			├── application
			│   ├── port
			│   │   ├── in
			│   │   └── out
			│   ├── service
			│   └── usecase
			├── domain
			│   ├── entity
			│   ├── service
			│   └── valueobject
			├── infrastructure
			│   ├── adapter
			│   ├── persistence
			│   └── util
			└── presentation
				├── controller
				├── util
				└── view

			19 directories
	</code></pre>
					</div>
				</section>

				<section>
					<h3>Clean Architecture: UML</h3>
					<div style="display: flex; flex-direction: column;" class="horizontal-spaced-container">
						<div>
							<ul>
								<li>Domänenlogik ist unabhängig von externen Frameworks/Bibliotheken</li>
								<li>Application Layer enthält anwendungsspezifische Regeln</li>
								<li>Ports definieren Schnittstellen zwischen Schichten</li>
								<li>Adapters verbinden externe Systeme mit inneren Schichten</li>
								<li>Abhängigkeiten zeigen immer nach innen</li>
							</ul>
						</div>
						<img style="overflow: scroll; scale: 1.1; justify-self: center; align-self: center;"
							src="./assets/UMLs-imgs/clean_arch.svg" alt="ULRICA Clean Architecture" class="uml-image">
					</div>
				</section>

				<section>
					<div style="display: flex; flex-direction: column; justify-content: space-around; gap: 0;">
						<img style="margin: 0; padding: 0;" src="assets/UMLs-imgs/2-1-1.png">
						<img style="margin: 0; padding: 0;" src="assets/UMLs-imgs/2-1-2.png">
						<img style="margin: 0; padding: 0;" src="assets/UMLs-imgs/2-1-3.png">
					</div>
				</section>

				<section>
					<h3>
						Clean Architecture: <br /> Analyse u. Begründung
					</h3>
				</section>

				<section>
					<h3>Domain Layer</h3>
					<p class="subchapter">Der Domain Layer ist das <strong>Herzstück der Clean Architecture</strong> und
						enthält die gesamte Geschäftslogik ohne externe Abhängigkeiten</p>
					<ul>
						<li><strong>CarProfile</strong> (Entity): Kernentität, die ein Car mit seinen Eigenschaften
							repräsentiert</li>
						<li><strong>BatteryProfile</strong> (Value Object): Immutable Objekt, das die
							Batterieeigenschaften eines Fahrzeugs beschreibt</li>
						<li><strong>ConsumptionProfile</strong> (Value Object): Kapselt Verbrauchsdaten und
							Verbrauchfaktoren des Fahrzeugs ab</li>
						<li><strong>RangeCalculatorService</strong> (Service): Berechnet die Reichweite basierend auf
							verschiedenen Strategien</li>
						<li><strong>RangeCalculationStrategyInterface</strong>: Definiert die Schnittstelle für
							verschiedene Berechnungsalgorithmen</li>
					</ul>
				</section>

				<section>
					<h3>Application Layer</h3>
					<p class="subchapter">Der Application Layer implementiert <strong>Use Cases</strong> und definiert
						<strong>Ports</strong>. Die Klassen orchestrieren Domänenobjekte, ohne direkten Zugriff auf die
						Infrastruktur, was dadurch die <strong>Dependency Rule</strong> einhäl
					</p>
					<ul>
						<li><strong>CalculateRangeUseCaseInterface</strong> (Port): Definiert die Schnittstelle für den
							Anwendungsfall der Reichweitenberechnung</li>
						<li><strong>CalculateRangeInteractor</strong> (Use Case): Implementiert die Geschäftslogik für
							die Reichweitenberechnung</li>
						<li><strong>CarProfilePersistencePortInterface</strong> (Port): Abstrahiert die Datenpersistenz
							für Fahrzeugprofile</li>
						<li><strong>NavigationUseCase</strong> (Use Case): Steuert die Navigationslogik und
							Routenplanung</li>
					</ul>
				</section>

				<section>
					<h3>Infrastructure Layer</h3>
					<p class="subchapter">Der Infrastructure Layer implementiert <strong>konkrete Adapter</strong> für
						externe Systeme. Diese Klassen sind austauschbar ohne Änderungen an inneren Schichten, was
						wichtig für e.g. <strong>OCP</strong> wichtig ist.</p>
					<ul>
						<li><strong>JsonCarProfileRepository</strong>: Implementiert die Persistenz von Fahrzeugprofilen
							als JSON-Dateien</li>
						<li><strong>ConsoleUserInputAdapter</strong>: Verarbeitet Benutzereingaben über die Konsole</li>
						<li><strong>ConsoleUserOutputAdapter</strong>: Zeigt Ausgaben und Ergebnisse in der Konsole an
						</li>
						<li><strong>ValidationUtils</strong>: Hilfsmethoden zur Validierung von Eingabedaten</li>
					</ul>
				</section>

				<section>
					<h3>Presentation Layer</h3>
					<p class="subchapter">Der Presentation Layer kapselt die Benutzerinteraktion. Diese Klassen
						kommunizieren nur über definierte Schnittstellen mit inneren Schichten, was eine <strong>klare
							Trennung von UI und Geschäftslogik</strong> gewährleistet</p>
					<ul>
						<li><strong>ApplicationControllerWithActionMenu</strong>: Hauptcontroller, der die verschiedenen
							Aktionen der Anwendung steuert</li>
						<li><strong>RangeCalculationController</strong>: Spezialisierter Controller für die
							Reichweitenberechnung</li>
						<li><strong>ActionMenuView</strong>: Stellt das Hauptmenü der Anwendung dar</li>
						<li><strong>CarProfileView</strong>: Visualisiert die Fahrzeugprofile und deren Details</li>
					</ul>
				</section>

				<section>
					<h3>Domain Code (1P)</h3>
					<p class="subchapter">Kurze Erläuterung in eigenen Worten, was Domain Code ist – 1 Beispiel im Code
						zeigen, das bisher noch nicht gezeigt wurde.</p>
					<ul>
						<li>Bildet die Fachlogik der Domäne (Geschäftsregeln) ab</li>
						<li>Modelliert Prozesse, Regeln und Datenstrukturen</li>
						<li>Unabhängig von externen Systemen (Datenbank, UI, Frameworks,...)</li>
						<li>Bleibt Stabil bei Änderung (an Technologien)</li>
						<li>Domäne orientiert (Entity, Valueobject, Aggregate)</li>
						<li>Bleibt fachlich und ist frei von Presentation- und Persistenzlogik (siehe Domainlayer)</li>
					</ul>
				</section>

				<section>
					<h3>Beispiel Domain Code: RangeCalculatorService</h3>
					<pre><code class="java" >public class RangeCalculatorService { // Reichweitenberechnung innerhalb der Domäne
	private final List<RangeCalculationStrategyInterface> strategies; // Hält verschiedene fachliche Berechnungsstrategien
	private RangeCalculationStrategyInterface defaultStrategy; // Definiert, welche Strategie standardmäßig verwendet wird

	public RangeCalculatorService() { // wird direkt mit zwei vordefinierten Strategien gestartet
		this.strategies = new ArrayList<>();
		
		WltpBasedRangeCalculationStrategy wltpStrategy = new WltpBasedRangeCalculationStrategy(); // Strategie basierend auf WLTP-Standard
		ConsumptionBasedRangeCalculationStrategy consumptionStrategy = new ConsumptionBasedRangeCalculationStrategy(); // Strategie basierend auf realem Verbrauch

		this.strategies.add(wltpStrategy); // Beide Strategien werden in die Domain-intern verfügbare Liste aufgenommen
		this.strategies.add(consumptionStrategy);

		this.defaultStrategy = consumptionStrategy; // Standardmäßig wird die Verbrauchsstrategie für Berechnungen genutzt
	}
	
	public void addStrategy(RangeCalculationStrategyInterface strategy) { // neue Strategien werden fachlich verfügbar gemacht
		Objects.requireNonNull(strategy, "Strategy cannot be null"); // Eine Strategie muss immer gültig sein
		strategies.add(strategy); // Neue Strategie wird der Liste hinzugefügt
	}
	
	public void setDefaultStrategy(RangeCalculationStrategyInterface strategy) { // Hier kann eine andere Standardstrategie gesetzt werden
		Objects.requireNonNull(strategy, "Strategy cannot be null"); // Die Strategie darf nicht null sein
		if (!strategies.contains(strategy)) { // Falls sie noch nicht bekannt ist, wird sie aufgenommen
			strategies.add(strategy);
		}
		this.defaultStrategy = strategy; // Danach wird sie als neue Standardstrategie gespeichert
	}
	
	public List<RangeCalculationStrategyInterface> getAvailableStrategies() { // Gibt alle aktuell verfügbaren Strategien der Domäne zurück
		return new ArrayList<>(strategies); // Liefert eine Kopie, damit die interne Liste geschützt bleibt
	}
	
	public RangeCalculationStrategyInterface getDefaultStrategy() { // Gibt die aktuelle Standardstrategie zurück
		return defaultStrategy;
	}
	
	public RangeResult calculateRange(CarProfile carProfile, RangeParameters parameters) { // Berechnet die Reichweite basierend auf dem Fahrzeugprofil und Standardstrategie
		Objects.requireNonNull(carProfile, "Car profile cannot be null"); // Ein Fahrzeugprofil ist zwingend notwendig
		Objects.requireNonNull(parameters, "Range parameters cannot be null"); // Auch die Parameter müssen angegeben sein
		
		return defaultStrategy.calculateRange(carProfile, parameters); // Übergibt die Berechnung an die Standardstrategie
	}
	
	public RangeResult calculateRangeWithStrategy(CarProfile carProfile, RangeParameters parameters, RangeCalculationStrategyInterface strategy) { // Alternativ kann eine konkrete Strategie verwendet werden
		Objects.requireNonNull(carProfile, "Car profile cannot be null"); // Fahrzeugprofil darf nicht fehlen
		Objects.requireNonNull(parameters, "Range parameters cannot be null"); // Parameter dürfen nicht fehlen
		Objects.requireNonNull(strategy, "Strategy cannot be null"); // Auch die Strategie muss vorhanden sein
		
		return strategy.calculateRange(carProfile, parameters); // Übergibt die Berechnung an die angegebene Strategie
	}
}</code></pre>
				</section>

				<section>
					<h3>Analyse des Domain Codes</h3>
					<ul>
						<li>Service kapselt reine Fachlogik zur Reichweitenberechnung</li>
						<li>Strategien sind fachliche Varianten zur Reichweitenermittlung</li>
						<li>Keine technische Infrastruktur wie DB, API oder UI enthalten</li>
						<li>Arbeitet nur mit Domain-spezifischen Typen (CarProfile, RangeParameters)</li>
						<li>Erweiterbarkeit durch neue Strategien innerhalb der Domäne möglich</li>
						<li>Berechnungen (calculateRange) folgen direkt fachlichen Regeln</li>
					</ul>
				</section>

				<section>
					<h3>Analyse der Dependency Rule (3P)</h3>
					<p class="subchapter">In der Vorlesung wurde im Rahmen der 'Clean Architecture' die s.g. Dependency
						Rule vorgestellt. Je 1 Klasse zeigen, die die Dependency Rule einhält und 1 Klasse, die die
						Dependency Rule verletzt; jeweils UML (mind. die betreffende Klasse inkl. der Klassen, die von
						ihr abhängen bzw. von der sie abhängt) und Analyse der Abhängigkeiten in beide Richtungen (d.h.,
						von wem hängt die Klasse ab und wer hängt von der Klasse ab) in Bezug auf die Dependency Rule
					</p>
				</section>



				<section>
					<h3>Analyse der Dependency Rule </h3>
					<ul>
						<li>Die Abhängigkeiten zeigen nur zum Zentrum der Architektur (größtenteils)</li>
						<li>Innere Schichten (Domain) dürfen nichts über äußere Schichten wissen</li>
						<li>Äußere Schichten (Infrastruktur) dürfen von inneren abhängen</li>
						<li>Die Abstraktionen (Interfaces) gehören zur inneren Schicht</li>
						<li>Die Implementierungen gehören zur äußeren Schicht</li>
					</ul>
					<img src="assets/UMLs-imgs/Kapitel_2-Aufgabe_3.png" alt="Dependency Rule UML" class="uml-image">
				</section>

				<section>
					<h3>Positives Beispiel: CalculateRangeInteractor</h3>
					<pre><code class="java">public class CalculateRangeInteractor implements CalculateRangeUseCaseInterface {
					
					private final RangeCalculatorService rangeCalculatorService;
					private final RangeCalculationOutputPortInterface outputPort;
					private final ProfileSelectionService profileSelectionService;
					
					public CalculateRangeInteractor(
							RangeCalculatorService rangeCalculatorService,
							RangeCalculationOutputPortInterface outputPort,
							ProfileSelectionService profileSelectionService) {
						this.rangeCalculatorService = Objects.requireNonNull(rangeCalculatorService);
						this.outputPort = Objects.requireNonNull(outputPort);
						this.profileSelectionService = Objects.requireNonNull(profileSelectionService);
					}
					
					@Override
					public void calculateRange(CalculateRangeCommand command) {
						CarProfile profile = profileSelectionService.getSelectedProfile();
						// Weitere Implementierung...
						
						RangeResult result = rangeCalculatorService.calculateRange(profile, parameters);
						outputPort.displayRangeResult(result);
					}
				}</code></pre>
				</section>

				<section>
					<h3>UML: Positives Beispiel</h3>
					<img src="assets/UMLs-imgs/Kapitel_2-Aufgabe_3-Dependency_Rule_Positiv.png"
						alt="Positive Dependency Rule Example UML" class="uml-image">
				</section>

				<section>
					<h3>Analyse des positiven Beispiels</h3>
					<ul>
						<li>Implementiert ein Interface aus der Application-Schicht</li>
						<li>Abhängigkeiten werden über Konstruktor-Injection bereitgestellt</li>
						<li>Abhängigkeiten sind alle Interfaces oder Domain-Services</li>
						<li>Keine Abhängigkeit zu konkreten Implementierungen der äußeren Schichten</li>
						<li>Ausgabe erfolgt über ein Port-Interface (RangeCalculationOutputPortInterface)</li>
						<li>Strikte Validierung mit Objects.requireNonNull()</li>
					</ul>
				</section>

				<section>
					<h3>Negatives Beispiel: JsonCarProfileRepository</h3>
					<pre><code class="java">public class JsonCarProfileRepository implements CarProfilePersistencePortInterface {
					private static final String STORAGE_DIR = "data";
					private static final String FILE_NAME = "car_profiles.json";
					private final Gson gson;
					private final Path filePath;
				
					public JsonCarProfileRepository() {
						this.gson = new GsonBuilder()
								.setPrettyPrinting()
								.registerTypeAdapterFactory(new OptionalTypeAdapterFactory())
								.create();
						this.filePath = Paths.get(STORAGE_DIR, FILE_NAME);
						ensureStorageDirectoryExists();
					}
					
					@Override
					public List<CarProfile> findAll() {
						try (FileReader reader = new FileReader(filePath.toFile())) {
							Type listType = new TypeToken<List<CarProfile>>() {}.getType();
							List<CarProfile> profiles = gson.fromJson(reader, listType);
							return profiles != null ? profiles : new ArrayList<>();
						} catch (IOException e) {
							throw new RuntimeException("Failed to read car profiles", e);
						}
					}
				}</code></pre>
				</section>

				<section>
					<h3>UML: Negatives Beispiel</h3>
					<img src="assets/UMLs-imgs/Kapitel_2-Aufgabe_3-Dependency_Rule_Negative.png"
						alt="Negative Dependency Rule Example UML" class="uml-image">
				</section>

				<section>
					<h3>Analyse des negativen Beispiels</h3>
					<div class="horizontal-spaced-container">
						<div>
							<p>Verstöße gegen die Dependency Rule:</p>
							<ul>
								<li>Direkte Abhängigkeit zu externen Bibliotheken (Gson)</li>
								<li>Direkter Zugriff auf das Dateisystem (java.io, java.nio)</li>
								<li>Hartcodierte Pfade (STORAGE_DIR, FILE_NAME)</li>
								<li>Ausnahmebehandlung mit generischen Exceptions</li>
								<li>Direkte Implementierung der Dateioperationen</li>
							</ul>
						</div>
						<div>
							<p>Verbesserungsvorschlag:</p>
							<ul>
								<li>Einführung eines FileStoragePortInterface</li>
								<li>Auslagerung der JSON-Serialisierung</li>
								<li>Konfigurierbare Pfade (z.B. über Umgebungsvariablen)</li>
								<li>Fachliche Exceptions wie ProfileNotFoundException</li>
								<li>Strikte Trennung von Persistenz und Domänenmodell</li>
							</ul>
						</div>
					</div>
				</section>
			</section>
			<!-- <section data-include="slides/kapitel-3.html"></section>
			<section data-include="slides/kapitel-4.html"></section>
			<section data-include="slides/kapitel-5.html"></section>
			<section data-include="slides/kapitel-6.html"></section>
			<section data-include="slides/kapitel-7.html"></section> -->
			<section>
				<section>
					<h2 class="chapter-title">Kapitel 8: <br /> Entwurfsmuster (8P)</h2>
					<p class="subchapter">Zwei unterschiedliche Entwurfsmuster aus der Vorlesung (oder nach Absprache
						auch andere) jeweils benennen, sinnvoll einsetzen, begründen und UML-Diagramm</p>
				</section>

				<section>
					<h3>Entwurfsmuster 1: <br /> Strategy Pattern (4P)</h3>
					<div class="horizontal-spaced-container">
						<div style="width: 50%;">
							<h4>Überblick</h4>
							<ul>
								<li><b>Kategorie/Art:</b> Behavioral Pattern</li>
								<li><b>Zweck:</b> Definiert eine Familie von Algorithmen, kapselt sie ab und macht sie
									austauschbar (Laufzeit u. Compilezeit)</li>
								<li><b>Verwendung:</b> Implementierung verschiedener Berechnungsstrategien für die
									Reichweite von Elektrofahrzeugen</li>
							</ul>
						</div>
						<div style="width: 50%;">
							<h4>Vorteile</h4>
							<ul>
								<li>Kapselung von unterschiedlichen Algorithmen in getrennten Klassen</li>
								<li>Laufzeitentscheidung über zu verwendende Strategie</li>
								<li>Leichte Erweiterbarkeit um neue Strategien (Auch gut für OCP)</li>
								<li>Einhaltung des <strong>Open/Closed Principles</strong></li>
								<li>Vermeidung von bedingten Verzweigungen durch Polymorphie</li>
							</ul>
						</div>
					</div>
				</section>


				<section>
					<h3 style="padding: 0; margin-top: 0;">Entwurfsmuster 1: <br /> Strategy Pattern (Forsetzung)</h3>
					<div style="width: 100%;">
						<h4 style="margin-top: 50px; padding: 0; margin-bottom: 0;">Nachteile</h4>
						<ul>
							<li>Erhöhte Komplexität durch viele kleine Klassen</li>
							<li>Client/Klasse muss die verschiedenen Strategien kennen</li>
							<li>Möglicher Overhead durch zusätzliche Erstellung von Objekten</li>
							<li>Strategie-Auswahl kann komplex werden</li>
							<li>Schwieriger zu debuggen durch verteilte Logik</li>
						</ul>
					</div>
				</section>


				<section>
					<h3>Strategy Pattern: Interface</h3>
					<div class="horizontal-spaced-container">
						<div>
							<pre style="width: 1000px; height: 500px; overflow: hidden;"><code class="java">// Das Strategy Interface
public interface RangeCalculationStrategyInterface {
	RangeResult calculateRange(CarProfile carProfile, RangeParameters parameters);
	
	String getName();
	
	String getDescription();
}

</code></pre>
						</div>
					</div>
				</section>

				<section>
					<h3>Strategy Pattern: Erste Implementierung</h3>
					<div class="horizontal-spaced-container">
						<div>
							<pre style="width: 1000px; height: 500px; overflow: hidden;"><code class="java">// Erste Strategie-Implementierung
public class WltpBasedRangeCalculationStrategy implements RangeCalculationStrategyInterface {

	@Override
	public RangeResult calculateRange(CarProfile carProfile, RangeParameters parameters) {
		Objects.requireNonNull(carProfile, "Car profile cannot be null!!!");
		Objects.requireNonNull(parameters, "Range parameters cannot be null");
		
		double baseWltpRange = carProfile.getWltpRangeKm();
		double batteryCapacity = carProfile.getBatteryProfile().getRemainingCapacityKwh();
		double currentSoC = parameters.getStateOfChargePercent();
		
		double baseConsumption = (batteryCapacity * 100.0) / baseWltpRange;
		
		double modeConsumption = baseConsumption * parameters.getEfficiencyMode().getConsumptionFactor();
		
		double terrainFactor = calculateTerrainFactor(parameters.getTerrain());
		double terrainConsumption = modeConsumption * terrainFactor;
		
		double weatherFactor = calculateWeatherFactor(parameters.getWeather(), parameters.getTemperatureCelsius());
		double weatherConsumption = terrainConsumption * weatherFactor;
		
		double environmentFactor = calculateEnvironmentFactor(parameters.getEnvironment());
		double finalConsumption = weatherConsumption * environmentFactor;
		
		double availableEnergy = batteryCapacity * (currentSoC / 100.0);
		double estimatedRange = (availableEnergy * 100.0) / finalConsumption;
		
		String weatherImpact = generateWeatherImpactDescription(parameters.getWeather(), parameters.getTemperatureCelsius());
		String terrainImpact = generateTerrainImpactDescription(parameters.getTerrain());
		String environmentImpact = generateEnvironmentImpactDescription(parameters.getEnvironment());
		String batteryCondition = generateBatteryConditionDescription(parameters.getStateOfChargePercent(), parameters.getTemperatureCelsius());
		
		return new RangeResult(
				estimatedRange,
				finalConsumption,
				weatherImpact,
				terrainImpact,
				environmentImpact,
				batteryCondition
		);
	}
	
	private double calculateTerrainFactor(TerrainType terrain) {
		return switch(terrain) {
			case FLAT -> 1.0;
			case HILLY -> 1.15;
			case MOUNTAINOUS -> 1.35;
		};
	}
	
	private double calculateWeatherFactor(WeatherType weather, double temperature) {
		double weatherMultiplier = switch(weather) {
			case SUNNY -> 0.9;
			case CLOUDY -> 0.95;
			case RAIN -> 1.1;
			case SNOW -> 1.3;
			case STRONG_WIND -> 1.2;
		};
		
		double tempFactor;
		if (temperature < -10) {
			tempFactor = 1.4;
		} else if (temperature < 0) {
			tempFactor = 1.2;
		} else if (temperature < 10) {
			tempFactor = 1.0;
		} else if (temperature <= 25) {
			tempFactor = 0.9;
		} else if (temperature <= 35) {
			tempFactor = 0.95;
		} else {
			tempFactor = 1.1;
		}
		
		return weatherMultiplier * tempFactor;
	}
	
	private double calculateEnvironmentFactor(DrivingEnvironment environment) {
		return switch(environment) {
			case CITY -> 0.8;     
			case RURAL -> 1.0;    
			case HIGHWAY -> 1.1; 
		};
	}
	
	private String generateWeatherImpactDescription(WeatherType weather, double temperature) {
		StringBuilder impact = new StringBuilder();
		
		switch(weather) {
			case SUNNY:
				impact.append("Minimal impact - Ideal weather conditions");
				break;
			case CLOUDY:
				impact.append("Slight impact - Cloud cover has minimal effect on efficiency");
				break;
			case RAIN:
				impact.append("Moderate impact - Rain increases rolling resistance");
				break;
			case SNOW:
				impact.append("Severe impact - Snow conditions significantly reduce range");
				break;
			case STRONG_WIND:
				impact.append("Significant impact - Strong winds increase air resistance");
				break;
		}
		
		if (temperature < 0) {
			impact.append(", Cold temperature reduces battery efficiency");
		} else if (temperature > 30) {
			impact.append(", High temperature requires additional cooling");
		}
		
		return impact.toString();
	}
	
	private String generateTerrainImpactDescription(TerrainType terrain) {
		return switch(terrain) {
			case FLAT -> "Minimal impact - Flat terrain optimal for efficiency";
			case HILLY -> "Moderate impact - Hills affect energy consumption";
			case MOUNTAINOUS -> "Significant impact - Mountainous terrain substantially increases consumption";
		};
	}
	
	private String generateEnvironmentImpactDescription(DrivingEnvironment environment) {
		return switch(environment) {
			case CITY -> "Stop-and-go traffic at " + environment.getAvgSpeedKmh() + " km/h - Benefits from regenerative braking";
			case RURAL -> "Medium speed driving at " + environment.getAvgSpeedKmh() + " km/h - Moderate air resistance";
			case HIGHWAY -> "Constant high speed at " + environment.getAvgSpeedKmh() + " km/h - Increased air resistance";
		};
	}
	
	private String generateBatteryConditionDescription(double soc, double temperature) {
		StringBuilder condition = new StringBuilder();
		
		if (soc > 80) {
			condition.append("High SoC (").append(soc).append("%) - Optimal operating range");
		} else if (soc > 40) {
			condition.append("Medium SoC (").append(soc).append("%) - Good operating range");
		} else if (soc > 20) {
			condition.append("Low SoC (").append(soc).append("%) - Consider charging soon");
		} else {
			condition.append("Very low SoC (").append(soc).append("%) - Critical level, charge immediately");
		}
		
		condition.append(", ");
		
		if (temperature < -10) {
			condition.append("Battery temperature very cold (").append(temperature).append("°C) - Severely reduced efficiency");
		} else if (temperature < 0) {
			condition.append("Battery temperature cold (").append(temperature).append("°C) - Reduced efficiency");
		} else if (temperature < 10) {
			condition.append("Battery temperature cool (").append(temperature).append("°C) - Slightly reduced efficiency");
		} else if (temperature <= 30) {
			condition.append("Battery temperature optimal (").append(temperature).append("°C) - Maximum efficiency");
		} else if (temperature <= 40) {
			condition.append("Battery temperature warm (").append(temperature).append("°C) - Slightly reduced efficiency");
		} else {
			condition.append("Battery temperature hot (").append(temperature).append("°C) - Reduced efficiency, potential for degradation");
		}
		
		return condition.toString();
	}

	@Override
	public String getName() {
		return "WLTP-based Range Calculation";
	}

	@Override
	public String getDescription() {
		return "Calculates range based on the car's WLTP rating adjusted for external conditions";
	}
} 
</code></pre>
						</div>
					</div>
				</section>

				<section>
					<h3>Strategy Pattern: Zweite Implementierung</h3>
					<div class="horizontal-spaced-container">
						<div>
							<pre style="width: 1000px; height: 500px; overflow: hidden;"><code class="java">// Zweite Strategie-Implementierung

public class ConsumptionBasedRangeCalculationStrategy implements RangeCalculationStrategyInterface {

    @Override
    public RangeResult calculateRange(CarProfile carProfile, RangeParameters parameters) {
        Objects.requireNonNull(carProfile, "Car profile cannot be null");
        Objects.requireNonNull(parameters, "Range parameters cannot be null");
        
        ConsumptionProfile consumptionProfile = carProfile.getConsumptionProfile();
        double baseConsumption = getBaseConsumption(consumptionProfile, parameters.getEnvironment());
        
        double modeConsumption = baseConsumption * parameters.getEfficiencyMode().getConsumptionFactor();
        
        double terrainFactor = calculateTerrainFactor(parameters.getTerrain());
        double terrainConsumption = modeConsumption * terrainFactor;
        
        double weatherFactor = calculateWeatherFactor(parameters.getWeather(), parameters.getTemperatureCelsius());
        double finalConsumption = terrainConsumption * weatherFactor;
        
        double availableEnergy = carProfile.getBatteryProfile().getRemainingCapacityKwh() *
                (parameters.getStateOfChargePercent() / 100.0);
        double estimatedRange = (availableEnergy * 100.0) / finalConsumption;
        
        String weatherImpact = generateWeatherImpactDescription(parameters.getWeather(), parameters.getTemperatureCelsius());
        String terrainImpact = generateTerrainImpactDescription(parameters.getTerrain());
        String environmentImpact = generateEnvironmentImpactDescription(parameters.getEnvironment());
        String batteryCondition = generateBatteryConditionDescription(parameters.getStateOfChargePercent(), parameters.getTemperatureCelsius());
        
        return new RangeResult(
                estimatedRange,
                finalConsumption,
                weatherImpact,
                terrainImpact,
                environmentImpact,
                batteryCondition
        );
    }
    
    private double getBaseConsumption(ConsumptionProfile profile, DrivingEnvironment environment) {
        return switch(environment) {
            case CITY -> profile.getConsumptionAt50Kmh();
            case RURAL -> profile.getConsumptionAt100Kmh();
            case HIGHWAY -> profile.getConsumptionAt130Kmh();
        };
    }
    
    private double calculateTerrainFactor(TerrainType terrain) {
        return switch(terrain) {
            case FLAT -> 1.0;
            case HILLY -> 1.05;
            case MOUNTAINOUS -> 1.1;
        };
    }
    
    private double calculateWeatherFactor(WeatherType weather, double temperature) {
        double weatherMultiplier = switch(weather) {
            case SUNNY -> 0.9;
            case CLOUDY -> 1.0;
            case RAIN -> 1.2;
            case SNOW -> 1.3;
            case STRONG_WIND -> 1.1;
        };
        
        double tempFactor;
        if (temperature < -10) {
            tempFactor = 1.4;
        } else if (temperature < 0) {
            tempFactor = 1.15;
        } else if (temperature < 10) {
            tempFactor = 1.0;
        } else if (temperature <= 25) {
            tempFactor = 0.9;
        } else if (temperature <= 35) {
            tempFactor = 1.1;
        } else {
            tempFactor = 1.2;
        }
        
        return weatherMultiplier * tempFactor;
    }
    
    private String generateWeatherImpactDescription(WeatherType weather, double temperature) {
        StringBuilder impact = new StringBuilder();
        
        switch(weather) {
            case SUNNY:
                impact.append("Minimal impact -> Ideal weather conditions");
                break;
            case CLOUDY:
                impact.append("Slight impact -> Cloud cover has minimal effect on efficiency");
                break;
            case RAIN:
                impact.append("Moderate impact -> Rain increases rolling resistance");
                break;
            case SNOW:
                impact.append("Severe impact - Snow conditions significantly reduce range");
                break;
            case STRONG_WIND:
                impact.append("Significant impact - Strong winds increase air resistance");
                break;
        }
        
        if (temperature < 0) {
            impact.append(", Cold temperature reduces battery efficiency!");
        } else if (temperature > 30) {
            impact.append(", High temperature requires additional cooling!");
        }
        
        return impact.toString();
    }
    
    private String generateTerrainImpactDescription(TerrainType terrain) {
        return switch(terrain) {
            case FLAT -> "Minimal impact - Flat terrain optimal for efficiency";
            case HILLY -> "Moderate impact - Hills affect energy consumption";
            case MOUNTAINOUS -> "Significant impact - Mountainous terrain substantially increases consumption";
        };
    }
    
    private String generateEnvironmentImpactDescription(DrivingEnvironment environment) {
        return switch(environment) {
            case CITY -> "Stop-and-go traffic at " + environment.getAvgSpeedKmh() + " kmh - Benefits from regenerative braking";
            case RURAL -> "Medium speed driving at " + environment.getAvgSpeedKmh() + " km/h - Moderate air resistance!";
            case HIGHWAY -> "Constant high speed at " + environment.getAvgSpeedKmh() + " km/h - Increased air resistance!";
        };
    }
    
    private String generateBatteryConditionDescription(double soc, double temperature) {
        StringBuilder condition = new StringBuilder();
        
        if (soc > 80) {
            condition.append("High SoC (").append(soc).append("%) -> Optimal operating range.");
        } else if (soc > 40) {
            condition.append("Medium SoC (").append(soc).append("%) -> Good operating range.");
        } else if (soc > 20) {
            condition.append("Low SoC (").append(soc).append("%) - Consider charging soon.");
        } else {
            condition.append("Very low SoC (").append(soc).append("%) - Critical level!!! charge immediately.");
        }
        
        condition.append(", ");
        
        if (temperature < -10) {
            condition.append("Battery temperature tooo cold!!! (").append(temperature).append("°C) -> Severely reduced efficiency");
        } else if (temperature < 0) {
            condition.append("Battery temperature cold (").append(temperature).append("°C) -> Reduced efficiency");
        } else if (temperature < 10) {
            condition.append("Battery temperature cool (").append(temperature).append("°C) -> Slightly reduced efficiency");
        } else if (temperature <= 30) {
            condition.append("Battery temperature optimal (").append(temperature).append("°C) -> Maximum efficiency");
        } else if (temperature <= 40) {
            condition.append("Battery temperature warm (perfectly fine) (").append(temperature).append("°C) -> Slightly reduced efficiency");
        } else {
            condition.append("Battery temperature too hot!!! (").append(temperature).append("°C) - Reduced efficiency! potential for degradation!!!");
        }
        
        return condition.toString();
    }

    @Override
    public String getName() {
        return "Consumption-based Range Calculation";
    }

    @Override
    public String getDescription() {
        return "Calculates range based on the car's consumption profile adjusted for external conditions";
    }
} 

			</code></pre>
						</div>
					</div>
				</section>

				<section>
					<h3>Strategy Pattern: Verwendung im Client</h3>
					<div class="horizontal-spaced-container">
						<div>
							<pre style="width: 1000px; height: 500px; overflow: hidden;"><code class="java">// Client-Klasse, die die Strategien verwendet
public class RangeCalculatorService {
    private final List<RangeCalculationStrategyInterface> strategies;
    private RangeCalculationStrategyInterface defaultStrategy;

    public RangeCalculatorService() {
        this.strategies = new ArrayList<>();
        
        WltpBasedRangeCalculationStrategy wltpStrategy = new WltpBasedRangeCalculationStrategy();
        ConsumptionBasedRangeCalculationStrategy consumptionStrategy = new ConsumptionBasedRangeCalculationStrategy();
        
        this.strategies.add(wltpStrategy);
        this.strategies.add(consumptionStrategy);
        
        this.defaultStrategy = consumptionStrategy;
    }
    
    public void addStrategy(RangeCalculationStrategyInterface strategy) {
        Objects.requireNonNull(strategy, "Strategy cannot be null");
        strategies.add(strategy);
    }
    
    public void setDefaultStrategy(RangeCalculationStrategyInterface strategy) {
        Objects.requireNonNull(strategy, "Strategy cannot be null");
        if (!strategies.contains(strategy)) {
            strategies.add(strategy);
        }
        this.defaultStrategy = strategy;
    }
    
    public List<RangeCalculationStrategyInterface> getAvailableStrategies() {
        return new ArrayList<>(strategies);
    }
    
    public RangeCalculationStrategyInterface getDefaultStrategy() {
        return defaultStrategy;
    }
    
    public RangeResult calculateRange(CarProfile carProfile, RangeParameters parameters) {
        Objects.requireNonNull(carProfile, "Car profile cannot be null");
        Objects.requireNonNull(parameters, "Range parameters cannot be null");
        
        return defaultStrategy.calculateRange(carProfile, parameters);
    }
    
    public RangeResult calculateRangeWithStrategy(CarProfile carProfile, RangeParameters parameters, RangeCalculationStrategyInterface strategy) {
        Objects.requireNonNull(carProfile, "Car profile cannot be null");
        Objects.requireNonNull(parameters, "Range parameters cannot be null");
        Objects.requireNonNull(strategy, "Strategy cannot be null");
        
        return strategy.calculateRange(carProfile, parameters);
    }
} 
</code></pre>
						</div>
					</div>
				</section>
		
		<section>
			<h4>Strategie Pattern: Vergleich</h4>
			<table style="margin: 0 auto; margin-top: 30px; padding: 0;">
				<thead>
					<tr>
						<th>Aspekt</th>
						<th>ConsumptionBasedRangeCalculationStrategy</th>
						<th>WltpBasedRangeCalculationStrategy</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>Basis für Berechnung</td>
						<td>Verbrauchsprofile des Fahrzeugs bei verschiedenen Geschwindigkeiten (50, 100, 130 km/h)</td>
						<td>WLTP-Reichweite des Fahrzeugs als Fixwert</td>
					</tr>
					<tr>
						<td>Kalkulation Grundverbrauch</td>
						<td>Basierend auf dem aktuellen Fahrumfeld (DrivingEnvironment) wird ein Verbrauchswert (kWh/100km) gewählt</td>
						<td>Es wird ein durchschnittlicher Verbrauch aus der WLTP-Reichweite und Batteriekapazität berechnet</td>
					</tr>
					<tr>
						<td>Berücksichtigte Faktoren</td>
						<td>Effizienzmodus, Geländeart, Wetterbedingungen, Temperatur, Batterieladestand</td>
						<td>Effizienzmodus, Geländeart, Wetterbedingungen, Temperatur, Batterieladestand, zusätzlich ein Fahrumgebungsfaktor (EnvironmentFactor)</td>
					</tr>
				</tbody>
			</table>
		</section>

		<section>
			<h3>Strategy Pattern: UML-Diagramm</h3>
			<img style="scale: 1.25; margin: 0; padding: 0; margin-top: 50px;" src="assets/UMLs-imgs/Kapitel_8-Aufgabe_1.png" alt="Strategy Pattern UML Diagram" class="uml-image">
		</section>







<section>
	<h3>Entwurfsmuster 2: Adapter Pattern (4P)</h3>
	<div class="horizontal-spaced-container">
		<div style="width: 50%;">
			<h4>Überblick</h4>
			<ul>
				<li><b>Art/Kategorie:</b> Strukturmuster (Structural Pattern)</li>
				<li><b>Zweck:</b> Konvertiert die Schnittstelle einer Klasse in eine andere, die vom Client erwartet wird</li>
				<li><b>Verwendung:</b> Integration von I/O-Operationen in die Clean Architecture</li>
			</ul>
		</div>
		<div style="width: 50%;">
			<h4>Vorteile</h4>
			<ul>
				<li>Flexibilität durch lose Kopplung</li>
				<li>Einfach zu erweitern</li>
				<li>Trennt Geschäftslogik von externen Ressourcen u. Komponenten</li>
				<li>Ermöglicht Zusammenarbeit nicht-kompatibler Schnittstellen</li>
			</ul>
		</div>
	</div>
</section>

<section>
	<h3 style="padding: 0; margin-top: 0;">Entwurfsmuster 2: <br /> Adapter Pattern (Fortsetzung)</h3>
	<div style="width: 100%;">
		<h4 style="margin-top: 50px; padding: 0; margin-bottom: 0;">Nachteile</h4>
		<ul>
			<li>Zusätzliche Komplexität durch zusätzliche Abstraktionsebene</li>
			<li>Möglicher Overhead durch zusätzliche Methodenaufrufe</li>
			<li>Erhöhte Anzahl von Klassen und Interfaces</li>
			<li>Externe können abrupt aufrufen</li>
		</ul>
	</div>
</section>

<section>
	<h3>Adapter Pattern: Port-Interfaces</h3>
	<div class="horizontal-spaced-container">
		<div>
			<pre style="width: 1000px; height: 500px; overflow: hidden;"><code class="java">// Port Interface für Benutzereingaben
public interface UserInputPortInterface {
    String readLine();
    int readInt();
    double readDouble();
    boolean readBoolean(String yesOption, String noOption);
    String readStringWithValidation(String prompt, String errorMessage, java.util.function.Predicate<String> validator);
    int readIntInRange(String prompt, int min, int max);
    double readDoubleInRange(String prompt, double min, double max);
}

// Port Interface für Benutzerausgaben
public interface UserOutputPortInterface {
    void display(String message);
    void displayLine(String message);
    void displayPrompt(String prompt);
    void displayError(String errorMessage);
    void displaySuccess(String successMessage);
    void displayWarning(String warningMessage);
    void displayTable(String[] headers, String[][] data);
    void clearScreen();
    void displayProgressBar(int current, int total);
}</code></pre>
		</div>
	</div>
</section>

<section>
	<h3>Adapter Pattern: ConsoleUserInputAdapter</h3>
	<div class="horizontal-spaced-container">
		<div>
			<pre style="width: 1000px; height: 500px; overflow: hidden;"><code class="java">
public class ConsoleUserInputAdapter implements UserInputPortInterface {
    private final Scanner scanner;
    
    public ConsoleUserInputAdapter(Scanner scanner) {
        this.scanner = Objects.requireNonNull(scanner, "Scanner cannot be null");
    }
    
    @Override
    public String readLine() {
        return scanner.nextLine();
    }
    
    @Override
    public int readInt() {
        while (true) {
            try {
                return Integer.parseInt(scanner.nextLine());
            } catch (NumberFormatException e) {
                System.out.println("Invalid input. Please enter a valid integer.");
            }
        }
    }
    
    @Override
    public double readDouble() {
        while (true) {
            try {
                return Double.parseDouble(scanner.nextLine());
            } catch (NumberFormatException e) {
                System.out.println("Invalid input. Please enter a valid number.");
            }
        }
    }
    
    @Override
    public boolean readBoolean(String yesOption, String noOption) {
        while (true) {
            String input = scanner.nextLine().toLowerCase();
            if (input.equals(yesOption.toLowerCase())) {
                return true;
            } else if (input.equals(noOption.toLowerCase())) {
                return false;
            }
            System.out.println("Invalid input. Please enter '" + yesOption + "' or '" + noOption + "'.");
        }
    }
    
    @Override
    public String readStringWithValidation(String prompt, String errorMessage, Predicate<String> validator) {
        while (true) {
            System.out.print(prompt);
            String input = scanner.nextLine();
            if (validator.test(input)) {
                return input;
            }
            System.out.println(errorMessage);
        }
    }
    
    @Override
    public int readIntInRange(String prompt, int min, int max) {
        while (true) {
            System.out.print(prompt);
            try {
                int value = Integer.parseInt(scanner.nextLine());
                if (value >= min && value <= max) {
                    return value;
                }
                System.out.println("Please enter a number between " + min + " and " + max);
            } catch (NumberFormatException e) {
                System.out.println("Invalid input. Please enter a valid integer.");
            }
        }
    }
    
    @Override
    public double readDoubleInRange(String prompt, double min, double max) {
        while (true) {
            System.out.print(prompt);
            try {
                double value = Double.parseDouble(scanner.nextLine());
                if (value >= min && value <= max) {
                    return value;
                }
                System.out.println("Please enter a number between " + min + " and " + max);
            } catch (NumberFormatException e) {
                System.out.println("Invalid input. Please enter a valid number.");
            }
        }
    }
}</code></pre>
		</div>
	</div>
</section>

<section>
	<h3>Adapter Pattern: ConsoleUserOutputAdapter</h3>
	<div class="horizontal-spaced-container">
		<div>
			<pre style="width: 1000px; height: 500px; overflow: hidden;"><code class="java">
public class ConsoleUserOutputAdapter implements UserOutputPortInterface {
    private static final String ANSI_RESET = "\u001B[0m";
    private static final String ANSI_RED = "\u001B[31m";
    private static final String ANSI_GREEN = "\u001B[32m";
    private static final String ANSI_YELLOW = "\u001B[33m";
    private static final String ANSI_CLEAR = "\033[H\033[2J";
    
    @Override
    public void display(String message) {
        System.out.print(message);
    }
    
    @Override
    public void displayLine(String message) {
        System.out.println(message);
    }
    
    @Override
    public void displayPrompt(String prompt) {
        System.out.print(prompt + ": ");
    }
    
    @Override
    public void displayError(String errorMessage) {
        System.out.println(ANSI_RED + "Error: " + errorMessage + ANSI_RESET);
    }
    
    @Override
    public void displaySuccess(String successMessage) {
        System.out.println(ANSI_GREEN + "Success: " + successMessage + ANSI_RESET);
    }
    
    @Override
    public void displayWarning(String warningMessage) {
        System.out.println(ANSI_YELLOW + "Warning: " + warningMessage + ANSI_RESET);
    }
    
    @Override
    public void displayTable(String[] headers, String[][] data) {
        // Calculate column widths
        int[] columnWidths = new int[headers.length];
        for (int i = 0; i < headers.length; i++) {
            columnWidths[i] = headers[i].length();
            for (String[] row : data) {
                if (row[i].length() > columnWidths[i]) {
                    columnWidths[i] = row[i].length();
                }
            }
        }
        
        // Print headers
        StringBuilder format = new StringBuilder("|");
        for (int width : columnWidths) {
            format.append(" %-").append(width).append("s |");
        }
        format.append("\n");
        
        System.out.println(format.toString().formatted((Object[]) headers));
        
        // Print separator
        System.out.println("-".repeat(Arrays.stream(columnWidths).sum() + headers.length * 3 + 1));
        
        // Print data
        for (String[] row : data) {
            System.out.println(format.toString().formatted((Object[]) row));
        }
    }
    
    @Override
    public void clearScreen() {
        System.out.print(ANSI_CLEAR);
        System.out.flush();
    }
    
    @Override
    public void displayProgressBar(int current, int total) {
        int width = 50;
        int progress = (int) ((double) current / total * width);
        
        StringBuilder bar = new StringBuilder("[");
        for (int i = 0; i < width; i++) {
            if (i < progress) {
                bar.append("=");
            } else {
                bar.append(" ");
            }
        }
        bar.append("] ").append(current).append("/").append(total);
        
        System.out.print("\r" + bar.toString());
        if (current == total) {
            System.out.println();
        }
    }
}</code></pre>
		</div>
	</div>
</section>

<section>
	<h3>Adapter Pattern: Verwendung im Controller</h3>
	<div class="horizontal-spaced-container">
		<div>
			<pre style="width: 1000px; height: 500px; overflow: hidden;"><code class="java">
public class RangeCalculationController {
    private final UserInputPortInterface userInputPort;
    private final UserOutputPortInterface userOutputPort;
    private final CalculateRangeUseCaseInterface calculateRangeUseCase;
    
    public RangeCalculationController(
            UserInputPortInterface userInputPort,
            UserOutputPortInterface userOutputPort,
            CalculateRangeUseCaseInterface calculateRangeUseCase) {
        this.userInputPort = Objects.requireNonNull(userInputPort, "UserInputPort cannot be null");
        this.userOutputPort = Objects.requireNonNull(userOutputPort, "UserOutputPort cannot be null");
        this.calculateRangeUseCase = Objects.requireNonNull(calculateRangeUseCase, "CalculateRangeUseCase cannot be null");
    }
    
    public void processRangeCalculation() {
        try {
            // Benutzereingaben über Port sammeln
            userOutputPort.displayPrompt("Enter temperature (°C)");
            double temperature = userInputPort.readDoubleInRange("", -50, 50);
            
            userOutputPort.displayPrompt("Enter state of charge (%)");
            double soc = userInputPort.readDoubleInRange("", 0, 100);
            
            userOutputPort.displayPrompt("Select weather condition (SUNNY, CLOUDY, RAIN, SNOW, STRONG_WIND)");
            WeatherType weather = WeatherType.valueOf(userInputPort.readStringWithValidation(
                "",
                "Invalid weather condition. Please enter one of: SUNNY, CLOUDY, RAIN, SNOW, STRONG_WIND",
                input -> Arrays.stream(WeatherType.values())
                    .map(Enum::name)
                    .anyMatch(name -> name.equalsIgnoreCase(input))
            ).toUpperCase());
            
            userOutputPort.displayPrompt("Select terrain type (FLAT, HILLY, MOUNTAINOUS)");
            TerrainType terrain = TerrainType.valueOf(userInputPort.readStringWithValidation(
                "",
                "Invalid terrain type. Please enter one of: FLAT, HILLY, MOUNTAINOUS",
                input -> Arrays.stream(TerrainType.values())
                    .map(Enum::name)
                    .anyMatch(name -> name.equalsIgnoreCase(input))
            ).toUpperCase());
            
            userOutputPort.displayPrompt("Select driving environment (CITY, RURAL, HIGHWAY)");
            DrivingEnvironment environment = DrivingEnvironment.valueOf(userInputPort.readStringWithValidation(
                "",
                "Invalid driving environment. Please enter one of: CITY, RURAL, HIGHWAY",
                input -> Arrays.stream(DrivingEnvironment.values())
                    .map(Enum::name)
                    .anyMatch(name -> name.equalsIgnoreCase(input))
            ).toUpperCase());
            
            userOutputPort.displayPrompt("Select efficiency mode (NORMAL, ECO, SPORT)");
            EfficiencyMode mode = EfficiencyMode.valueOf(userInputPort.readStringWithValidation(
                "",
                "Invalid efficiency mode. Please enter one of: NORMAL, ECO, SPORT",
                input -> Arrays.stream(EfficiencyMode.values())
                    .map(Enum::name)
                    .anyMatch(name -> name.equalsIgnoreCase(input))
            ).toUpperCase());
            
            // Use Case über Interface ausführen
            RangeParameters parameters = new RangeParameters(
                temperature,
                soc,
                weather,
                terrain,
                environment,
                mode
            );
            
            calculateRangeUseCase.calculateRange(parameters);
            
        } catch (Exception e) {
            userOutputPort.displayError("An error occurred during range calculation: " + e.getMessage());
        }
    }
}</code></pre>
		</div>
	</div>
</section>

<section>
	<h3>Adapter Pattern: UML-Diagramm</h3>
	<img style="scale: 1.3" src="assets/UMLs-imgs/Kapitel_8-Aufgabe_2.png" alt="Adapter Pattern UML Diagram" class="uml-image">
</section>

<section>
	<h3>Zusammenfassung der Entwurfsmuster in ULRICA</h3>
	<div class="horizontal-spaced-container">
		<div>
			<h4>Strategy Pattern</h4>
			<ul>
				<li>Ermöglicht austauschbare Berechnungsstrategien</li>
				<li>Unterstützt OCP durch Erweiterbarkeit</li>
				<li>Vereinfacht das Hinzufügen neuer Berechnungsmethoden</li>
				<li>Beispiel: Reichweitenberechnung mit verschiedenen Algorithmen</li>
			</ul>
		</div>
		<div>
			<h4>Adapter Pattern</h4>
			<ul>
				<li>Überbrückt die Kluft zwischen Domain und externen Systemen</li>
				<li>Fördert saubere Schichtenarchitektur</li>
				<li>Erhöht die Testbarkeit durch Entkopplung</li>
				<li>Beispiel: Konsolen-I/O-Adapter für Benutzerinteraktion</li>
			</ul>
		</div>
	</div>
	<p style="text-align: center; margin-top: 2rem;">Beide Muster fördern die Clean Architecture und verbessern die Wartbarkeit, Testbarkeit und Flexibilität des Gesamtsystems.</p>
</section>
		</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// Debug logging
			console.log('RevealHighlight plugin:', typeof RevealHighlight);
			console.log('hljs global:', typeof window.hljs);

			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,
				slideNumber: true,

				// Explicit highlight config
				highlight: {
					highlightOnLoad: true,
					escapeHTML: false
				},

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
			});

			// Load all slide content, then initialize highlight.js
			const loadSlidesPromises = [];
			document.querySelectorAll('[data-include]').forEach((section) => {
				const url = section.getAttribute('data-include');
				const promise = fetch(url)
					.then(response => response.text())
					.then(html => {
						section.html = ""
						section.innerHTML = html;
					});
				loadSlidesPromises.push(promise);
			});

			// After all slides are loaded, re-initialize highlight.js
			Promise.all(loadSlidesPromises).then(() => {
				// Force Reveal to update
				Reveal.sync();

				// Try multiple ways to initialize highlighting

				// 1. Through Reveal plugin
				const highlight = Reveal.getPlugin('highlight');
				if (highlight) {
					document.querySelectorAll('code').forEach(block => {
						highlight.highlightBlock(block);
					});
				}

				// 2. Direct hljs initialization if available
				if (window.hljs) {
					window.hljs.configure({
						languages: ['bash', 'javascript', 'html', 'xml', 'css']
					});
					document.querySelectorAll('code.bash, code.hljs.bash').forEach(block => {
						window.hljs.highlightElement(block);
					});
				}
			});
		</script>
	</body>

</html>