<section>
    <h2 class="chapter-title">Kapitel 6: Domain Driven Design (8P)</h2>
</section>

<section>
    <h3>Ubiquitous Language (2P)</h3>
    <div class="horizontal-spaced-container">
        <div>
            <h5>SoC (State of Charge)</h5>
            <ul>
                <li><b>Bedeutung:</b> Prozentualer Ladezustand der Batterie (0-100%)</li>
                <li><b>Verwendung:</b> Parameter für Reichweitenberechnung und Ladezeit</li>
                <li><b>Ubiquitous Language:</b> Fachbegriff aus dem E-Mobility-Bereich, der die gemeinsame Sprache zwischen Technikern und Anwendern bildet</li>
            </ul>
        </div>
        <div>
            <h5>WLTP-Range</h5>
            <ul>
                <li><b>Bedeutung:</b> Standardisierte Reichweite nach Worldwide Harmonized Light Vehicles Test Procedure</li>
                <li><b>Verwendung:</b> Basis für realistische Reichweitenberechnung</li>
                <li><b>Ubiquitous Language:</b> Regulatorischer Begriff, der eine einheitliche Verständnisgrundlage für Fahrzeugleistung bietet</li>
            </ul>
        </div>
    </div>
</section>

<section>
    <h3>Ubiquitous Language (Fortsetzung)</h3>
    <div class="horizontal-spaced-container">
        <div>
            <h5>Charging Curve</h5>
            <ul>
                <li><b>Bedeutung:</b> Verlauf der Ladeleistung abhängig vom SoC</li>
                <li><b>Verwendung:</b> Berechnung von Ladezeiten an DC-Ladestationen</li>
                <li><b>Ubiquitous Language:</b> Technisches Konzept, das sowohl für Entwickler als auch Benutzer die Ladeeigenschaften beschreibt</li>
            </ul>
        </div>
        <div>
            <h5>Battery Type (LFP, NMC, NCA)</h5>
            <ul>
                <li><b>Bedeutung:</b> Chemische Zusammensetzung der Batterie (Lithium-Eisenphosphat, Nickel-Mangan-Cobalt, Nickel-Cobalt-Aluminium)</li>
                <li><b>Verwendung:</b> Berechnung von Degradation und Ladegeschwindigkeit</li>
                <li><b>Ubiquitous Language:</b> Chemische Klassifikation, die technische Eigenschaften für das gesamte Team eindeutig kommunizierbar macht</li>
            </ul>
        </div>
    </div>
</section>

<section>
    <h3>Repositories (1.5P)</h3>
    <div class="horizontal-spaced-container">
        <div>
            <h5>CarProfileRepository</h5>
            <ul>
                <li>Persistenz von Fahrzeugprofilen ohne Offenlegung der Speichermechanismen</li>
                <li>Domain Entities können unabhängig von der Persistenz modelliert werden</li>
                <li>Unterstützt die Illusion einer In-Memory-Sammlung</li>
                <li>Ermöglicht einfachen Austausch der Persistenztechnologie</li>
            </ul>
        </div>
        <div>
            <pre><code class="java">public interface CarProfilePersistencePortInterface {
    Optional<CarProfile> findById(String id);
    List<CarProfile> findAll();
    CarProfile save(CarProfile carProfile);
    void delete(String id);
}

public class JsonCarProfileRepository 
        implements CarProfilePersistencePortInterface {
    // Repository-Implementierung mit JSON-Persistenz
}</code></pre>
        </div>
    </div>
</section>

<section>
    <h3>Repository: UML und Begründung</h3>
    <div class="horizontal-spaced-container">
        <div>
            <img src="assets/UMLs-imgs/Kapitel_6-Aufgabe_2.png" alt="Repository Pattern UML Diagram" class="uml-image">
        </div>
        <div>
            <h5>Vorteile des Repository Patterns:</h5>
            <ul>
                <li>Klare Trennung zwischen Domänenlogik und Persistenzmechanismus</li>
                <li>Vereinfachung des Domain Model durch Abstraktion der Persistenz</li>
                <li>Ermöglicht die Anwendung von Clean Architecture Prinzipien</li>
                <li>Erleichtert das Testen durch Mocking der Repository-Implementierung</li>
                <li>Entscheidung für Datenspeicherung in JSON-Dateien bleibt flexibel änderbar</li>
            </ul>
        </div>
    </div>
</section>

<section>
    <h3>Aggregates (1.5P)</h3>
    <div class="horizontal-spaced-container">
        <div>
            <h5>CarProfile als Aggregate Root</h5>
            <ul>
                <li>Koordiniert mehrere Value Objects (BatteryProfile, ConsumptionProfile, ChargingCurve)</li>
                <li>Stellt die Konsistenz zwischen den Value Objects sicher</li>
                <li>Bildet eine transaktionale Einheit für Änderungen</li>
                <li>Einziger Zugriffspunkt für enthaltene Value Objects</li>
                <li>Hat eine eigene Identität (ID)</li>
            </ul>
        </div>
        <div>
            <pre><code class="java">public class CarProfile {
    private final String id;
    private final String name;
    private final String manufacturer;
    private final String model;
    // ... weitere Attribute
    private final BatteryProfile batteryProfile;
    private final ConsumptionProfile consumptionProfile;
    private final Optional<ChargingCurve> chargingCurve;
    
    // Immutable Aggregate mit Validierung
    private CarProfile(Builder builder) {
        this.id = builder.id;
        this.name = Objects.requireNonNull(builder.name);
        this.batteryProfile = Objects.requireNonNull(
            builder.batteryProfile);
        this.consumptionProfile = Objects.requireNonNull(
            builder.consumptionProfile);
        // ... weitere Initialisierung
    }
    // ...
}</code></pre>
        </div>
    </div>
</section>

<section>
    <h3>Aggregate: UML und Begründung</h3>
    <div class="horizontal-spaced-container">
        <div>
            <img src="assets/UMLs-imgs/Kapitel_6-Aufgabe_3.png" alt="Aggregate Pattern UML Diagram" class="uml-image">
        </div>
        <div>
            <h5>Vorteile des Aggregate-Musters:</h5>
            <ul>
                <li>Klare Abgrenzung domänenspezifischer Objektgruppen</li>
                <li>Komplexitätsreduktion durch zusammenhängende Transaktionseinheiten</li>
                <li>Verbesserte Performance durch Vermeidung von Dateninkonsistenzen</li>
                <li>Natürliche Modellierung der Geschäftsrealität (ein Fahrzeug mit seinen Komponenten)</li>
                <li>Vereinfachte Persistenz, da nur der Aggregate Root direkt persistiert wird</li>
            </ul>
        </div>
    </div>
</section>

<section>
    <h3>Entities (1.5P)</h3>
    <div class="horizontal-spaced-container">
        <div>
            <h5>CarProfile als Entity</h5>
            <ul>
                <li>Besitzt eine eindeutige Identität (UUID)</li>
                <li>Identität bleibt über den gesamten Lebenszyklus erhalten</li>
                <li>Kann verändert und weiterentwickelt werden (auch wenn in ULRICA immutable)</li>
                <li>Wird über die Identität verglichen, nicht über Attributwerte</li>
                <li>Repräsentiert ein reales Objekt (Elektrofahrzeug) mit eigenem Lebenszyklus</li>
            </ul>
        </div>
        <div>
            <pre><code class="java">public class CarProfile {
    private final String id; // Eindeutige Identität
    // ... weitere Attribute
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) 
            return false;
        CarProfile that = (CarProfile) o;
        return Objects.equals(id, that.id); // Vergleich nur über ID
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
    
    // ... weitere Methoden
}</code></pre>
        </div>
    </div>
</section>

<section>
    <h3>Entity: UML und Begründung</h3>
    <div class="horizontal-spaced-container">
        <div>
            <img src="assets/UMLs-imgs/Kapitel_6-Aufgabe_4.png" alt="Entity Pattern UML Diagram" class="uml-image">
        </div>
        <div>
            <h5>Vorteile des Entity-Musters:</h5>
            <ul>
                <li>Eindeutige Identifikation von Objekten unabhängig von ihren Attributen</li>
                <li>Möglichkeit, Entitäten über ihren Lebenszyklus hinweg zu verfolgen</li>
                <li>Konsistente Identifikation in verschiedenen Kontexten des Systems</li>
                <li>Klare Unterscheidung zwischen Identität und Attributen</li>
                <li>Natürliche Abbildung von realen Objekten mit eigener Identität</li>
            </ul>
        </div>
    </div>
</section>

<section>
    <h3>Value Objects (1.5P)</h3>
    <div class="horizontal-spaced-container">
        <div>
            <h5>BatteryProfile als Value Object</h5>
            <ul>
                <li>Keine eigene Identität</li>
                <li>Immutable (unveränderlich) nach Erstellung</li>
                <li>Vergleich basiert auf allen Attributwerten</li>
                <li>Beschreibt eine Messung oder ein Konzept</li>
                <li>Kann problemlos ersetzt werden</li>
                <li>Validiert sich selbst bei der Erstellung</li>
            </ul>
        </div>
        <div>
            <pre><code class="java">public class BatteryProfile {
    private final BatteryType type;
    private final double capacityKwh;
    private final double degradationPercent;
    private final double maxDcPowerKw;
    private final double maxAcPowerKw;
    
    public BatteryProfile(BatteryType type, double capacityKwh, 
                          double degradationPercent, 
                          double maxDcPowerKw, double maxAcPowerKw) {
        // Validierung bei Konstruktion
        if (capacityKwh <= 0) {
            throw new IllegalArgumentException("Capacity must be positive");
        }
        if (degradationPercent < 0 || degradationPercent > 100) {
            throw new IllegalArgumentException(
                "Degradation must be between 0 and 100%");
        }
        // ... weitere Validierungen
        
        // Immutable Initialisierung
        this.type = Objects.requireNonNull(type);
        this.capacityKwh = capacityKwh;
        this.degradationPercent = degradationPercent;
        this.maxDcPowerKw = maxDcPowerKw;
        this.maxAcPowerKw = maxAcPowerKw;
    }
    
    // Getter, keine Setter (immutable)
    // ...
}</code></pre>
        </div>
    </div>
</section>

<section>
    <h3>Value Objects: UML und Begründung</h3>
    <div class="horizontal-spaced-container">
        <div>
            <img src="assets/UMLs-imgs/Kapitel_6-Aufgabe_5.png" alt="Value Objects UML Diagram" class="uml-image">
        </div>
        <div>
            <h5>Vorteile von Value Objects:</h5>
            <ul>
                <li>Unveränderlichkeit verhindert unerwartet veränderte Zustände</li>
                <li>Bessere Vorhersagbarkeit des Programmverhaltens</li>
                <li>Einfachere Parallelisierung durch Thread-Safety</li>
                <li>Natürliche Modellierung von Konzepten ohne eigene Identität</li>
                <li>Performancevorteile durch Vermeidung von Änderungsverfolgung</li>
                <li>Erleichterte Vergleichs- und Hash-Operationen</li>
            </ul>
        </div>
    </div>
</section>

<section>
    <h3>Domain Services (1P)</h3>
    <div class="horizontal-spaced-container">
        <div>
            <h5>RangeCalculatorService</h5>
            <ul>
                <li>Enthält domänenspezifische Operationen, die keiner einzelnen Entity oder Value Object zugeordnet werden können</li>
                <li>Zustandslos und auf Operationen fokussiert</li>
                <li>Koordiniert mehrere Domain Objects</li>
                <li>Implementiert komplexe Algorithmen der Fachdomäne</li>
                <li>Berechnet Reichweiten basierend auf verschiedenen Faktoren</li>
            </ul>
        </div>
        <div>
            <pre><code class="java">public class RangeCalculatorService {
    private final List<RangeCalculationStrategyInterface> strategies;
    private RangeCalculationStrategyInterface defaultStrategy;

    public RangeCalculatorService() {
        // Initialisierung mit Standardstrategien
    }
    
    public RangeResult calculateRange(
            CarProfile carProfile, 
            RangeParameters parameters) {
        Objects.requireNonNull(carProfile);
        Objects.requireNonNull(parameters);
        
        // Berechnung durch aktive Strategie
        return defaultStrategy.calculateRange(
            carProfile, parameters);
    }
    
    public void addStrategy(
            RangeCalculationStrategyInterface strategy) {
        // Strategie hinzufügen
    }
    
    // Weitere domänenspezifische Operationen
}</code></pre>
        </div>
    </div>
</section>

<section>
    <h3>Zusammenfassung: DDD in ULRICA</h3>
    <ul>
        <li><b>Ubiquitous Language:</b> Gemeinsames Vokabular zwischen Entwicklern und Fachexperten (SoC, WLTP, Charging Curve)</li>
        <li><b>Entities:</b> Objekte mit eigener Identität und Lebenszyklus (CarProfile)</li>
        <li><b>Value Objects:</b> Immutable Objekte ohne eigene Identität (BatteryProfile, ConsumptionProfile)</li>
        <li><b>Aggregates:</b> Konsistente Objektgruppen mit klaren Grenzen (CarProfile als Root)</li>
        <li><b>Repositories:</b> Persistenz-Abstraktion für Domain Objects (CarProfileRepository)</li>
        <li><b>Domain Services:</b> Operationen, die keiner einzelnen Entity zugeordnet werden können (RangeCalculatorService)</li>
        <li><b>Bounded Contexts:</b> Trennung in klare Domänenbereiche (Reichweitenberechnung, Ladeberechnung)</li>
    </ul>
    <p>DDD hilft bei der sauberen Modellierung der Problemdomäne und fördert die Kommunikation zwischen allen Beteiligten.</p>
</section>