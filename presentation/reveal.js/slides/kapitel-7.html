<section>
    <h2 class="chapter-title">Kapitel 7: <br /> Refactoring (8P)</h2>
</section>

<section>
    <h3 class="subchapter">Inhalt des Kapitels</h3>
    <div class="horizontal-spaced-container" style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
        <div>
            <h6>1. Code Smells (2P)</h6>
            <ul>
                <li>Long Method in RangeCalculationController</li>
                <li>Duplicate Code in Charging Calculators</li>
            </ul>
        </div>
        <div>
            <h6>2. Refactorings (6P)</h6>
            <ul>
                <li>Extract Method</li>
                <li>Replace Conditional with Polymorphism</li>
            </ul>
        </div>
    </div>
</section>

<section>
    <h3>Code Smells (2p}</h3>
    <p class="subchapter">Jeweils 1 Code-Beispiel zu 2 unterschiedlichen Code Smells (die benannt werden müssen) aus der
        Vorlesung; jeweils Code-Beispiel und einen möglichen Lösungsweg bzw. den genommen Lösungsweg beschreiben (inkl.
        (Pseudo-)Code)</p>
</section>

<section>
    <h3>Code Smell 1: Long Method</h3>
    <p class="subchapter">RangeCalculationController.processRangeCalculation() ist zu lang und hat zu viele
        Verantwortlichkeiten</p>
    <pre><code class="java">/* public class RangeCalculationController {
    private final CalculateRangeUseCaseInterface calculateRangeUseCase;
    private final UserInputPortInterface userInputPort;
    private final RangeCalculationOutputPortInterface outputPort;
    
    public RangeCalculationController(
            CalculateRangeUseCaseInterface calculateRangeUseCase,
            UserInputPortInterface userInputPort,
            RangeCalculationOutputPortInterface outputPort) {
        this.calculateRangeUseCase = Objects.requireNonNull(calculateRangeUseCase, "Calculate range use case cannot be null");
        this.userInputPort = Objects.requireNonNull(userInputPort, "User input port cannot be null");
        this.outputPort = Objects.requireNonNull(outputPort, "Output port cannot be null");
    }
    
    public boolean processRangeCalculation() {
try {
    outputPort.showRangeCalculationHeader();
    
    TerrainType terrain = getTerrainType();
    WeatherType weather = getWeatherType();
    double temperature = getTemperature();
    DrivingEnvironment environment = getDrivingEnvironment();
    double stateOfCharge = getStateOfCharge();
    EfficiencyMode efficiencyMode = getEfficiencyMode();
    
    return calculateRangeUseCase.calculateRange(
            terrain,
            weather,
            temperature,
            environment,
            efficiencyMode,
            stateOfCharge
    );
} catch (Exception e) {
    outputPort.showError("An error occurred: " + e.getMessage());
    return false;
}
}</code></pre>
</section>

<section>
    <h3>Code Smell 1: Analyse</h3>
    <ul>
        <li>Die Methode ist zu lang und komplex</li>
        <li>Viele verschiedene Verantwortlichkeiten in einer Methode</li>
        <li>Schlechte Lesbarkeit und Wartbarkeit</li>
        <li>Schwer zu testen</li>
        <li>Verletzt das Single Responsibility Principle</li>
    </ul>
</section>

<section>
    <h3>Code Smell 1: Lösungsvorschlag</h3>
    <pre><code class="java">public boolean processRangeCalculation() {
    try {
        outputPort.showRangeCalculationHeader();
        
        RangeParameters parameters = collectRangeParameters();
        return calculateRangeUseCase.calculateRange(parameters);
    } catch (Exception e) {
        outputPort.showError("An error occurred: " + e.getMessage());
        return false;
    }
}

private RangeParameters collectRangeParameters() {
    TerrainType terrain = getTerrainType();
    WeatherType weather = getWeatherType();
    double temperature = getTemperature();
    DrivingEnvironment environment = getDrivingEnvironment();
    double stateOfCharge = getStateOfCharge();
    EfficiencyMode efficiencyMode = getEfficiencyMode();
    
    return new RangeParameters(
        terrain,
        weather,
        temperature,
        environment,
        efficiencyMode,
        stateOfCharge
    );
}</code></pre>
</section>

<section>
    <h3>Code Smell 2: Duplicate Code</h3>
    <p class="subchapter">Ähnliche Temperaturberechnungen in DcChargingCalculator und AcChargingCalculator</p>
    <div class="horizontal-spaced-container">
        <div>
            <pre><code class="java">// DcChargingCalculator
private double calculateTemperatureEfficiencyFactor(double batteryTemperatureCelsius) {
    if (batteryTemperatureCelsius < MIN_BATTERY_TEMPERATURE || 
        batteryTemperatureCelsius > MAX_BATTERY_TEMPERATURE) {
        return 0.0;
    }
    
    if (batteryTemperatureCelsius >= OPTIMAL_TEMPERATURE_MIN && 
        batteryTemperatureCelsius <= OPTIMAL_TEMPERATURE_MAX) {
        return 1.0;
    }
    
    if (batteryTemperatureCelsius < OPTIMAL_TEMPERATURE_MIN) {
        return 0.5 + 0.5 * (batteryTemperatureCelsius - MIN_BATTERY_TEMPERATURE) / 
            (OPTIMAL_TEMPERATURE_MIN - MIN_BATTERY_TEMPERATURE);
    } else {
        return 0.5 + 0.5 * (MAX_BATTERY_TEMPERATURE - batteryTemperatureCelsius) / 
            (MAX_BATTERY_TEMPERATURE - OPTIMAL_TEMPERATURE_MAX);
    }
}</code></pre>
        </div>
        <div>
            <pre><code class="java">// AcChargingCalculator
private double calculateTemperatureEfficiency(double ambientTemperatureCelsius) {
    if (ambientTemperatureCelsius < MIN_BATTERY_TEMPERATURE || 
        ambientTemperatureCelsius > MAX_BATTERY_TEMPERATURE) {
        return 0.0;
    }
    
    if (ambientTemperatureCelsius >= OPTIMAL_TEMPERATURE_MIN && 
        ambientTemperatureCelsius <= OPTIMAL_TEMPERATURE_MAX) {
        return 1.0;
    }
    
    if (ambientTemperatureCelsius < OPTIMAL_TEMPERATURE_MIN) {
        return 0.7 + 0.3 * (ambientTemperatureCelsius - MIN_BATTERY_TEMPERATURE) / 
            (OPTIMAL_TEMPERATURE_MIN - MIN_BATTERY_TEMPERATURE);
    } else {
        return 0.7 + 0.3 * (MAX_BATTERY_TEMPERATURE - ambientTemperatureCelsius) / 
            (MAX_BATTERY_TEMPERATURE - OPTIMAL_TEMPERATURE_MAX);
    }
}</code></pre>
        </div>
    </div>
</section>

<section>
    <h3>Code Smell 2: Analyse</h3>
    <ul>
        <li>Fast identischer Code in beiden Klassen</li>
        <li>Nur minimale Unterschiede in den Konstanten (0.5 vs 0.7)</li>
        <li>Verletzt das DRY-Prinzip (Don't Repeat Yourself)</li>
        <li>Schwer zu warten bei Änderungen</li>
        <li>Fehleranfällig bei Updates</li>
    </ul>
</section>

<section>
    <h3>Code Smell 2: Lösungsvorschlag</h3>
    <pre><code class="java">public class TemperatureEfficiencyCalculator {
    private final double minEfficiency;
    private final double maxEfficiency;
    
    public TemperatureEfficiencyCalculator(double minEfficiency, double maxEfficiency) {
        this.minEfficiency = minEfficiency;
        this.maxEfficiency = maxEfficiency;
    }
    
    public double calculateEfficiency(double temperature) {
        if (temperature < MIN_BATTERY_TEMPERATURE || 
            temperature > MAX_BATTERY_TEMPERATURE) {
            return 0.0;
        }
        
        if (temperature >= OPTIMAL_TEMPERATURE_MIN && 
            temperature <= OPTIMAL_TEMPERATURE_MAX) {
            return 1.0;
        }
        
        if (temperature < OPTIMAL_TEMPERATURE_MIN) {
            return minEfficiency + (maxEfficiency - minEfficiency) * 
                (temperature - MIN_BATTERY_TEMPERATURE) / 
                (OPTIMAL_TEMPERATURE_MIN - MIN_BATTERY_TEMPERATURE);
        } else {
            return minEfficiency + (maxEfficiency - minEfficiency) * 
                (MAX_BATTERY_TEMPERATURE - temperature) / 
                (MAX_BATTERY_TEMPERATURE - OPTIMAL_TEMPERATURE_MAX);
        }
    }
}</code></pre>
</section>

<section>
    <h3>Refactoring 1: Extract Method</h3>
    <p class="subchapter">Extrahieren der Parameter-Erfassung in eine separate Methode</p>
    <div class="horizontal-spaced-container">
        <div>
            <h5>Vorher</h5>
            <pre><code class="java">public boolean processRangeCalculation() {
    try {
        outputPort.showRangeCalculationHeader();
        
        TerrainType terrain = getTerrainType();
        WeatherType weather = getWeatherType();
        double temperature = getTemperature();
        DrivingEnvironment environment = getDrivingEnvironment();
        double stateOfCharge = getStateOfCharge();
        EfficiencyMode efficiencyMode = getEfficiencyMode();
        
        return calculateRangeUseCase.calculateRange(
                terrain,
                weather,
                temperature,
                environment,
                efficiencyMode,
                stateOfCharge
        );
    } catch (Exception e) {
        outputPort.showError("An error occurred: " + e.getMessage());
        return false;
    }
}</code></pre>
        </div>
        <div>
            <h5>Nachher</h5>
            <pre><code class="java">public boolean processRangeCalculation() {
    try {
        outputPort.showRangeCalculationHeader();
        RangeParameters parameters = collectRangeParameters();
        return calculateRangeUseCase.calculateRange(parameters);
    } catch (Exception e) {
        outputPort.showError("An error occurred: " + e.getMessage());
        return false;
    }
}

private RangeParameters collectRangeParameters() {
    TerrainType terrain = getTerrainType();
    WeatherType weather = getWeatherType();
    double temperature = getTemperature();
    DrivingEnvironment environment = getDrivingEnvironment();
    double stateOfCharge = getStateOfCharge();
    EfficiencyMode efficiencyMode = getEfficiencyMode();
    
    return new RangeParameters(
        terrain,
        weather,
        temperature,
        environment,
        efficiencyMode,
        stateOfCharge
    );
}</code></pre>
        </div>
    </div>
</section>

<section>
    <h3>Refactoring 1: UML-Diagramm</h3>
    <img src="assets/UMLs-imgs/Kapitel_7-Refactoring_1.png" alt="Extract Method UML" class="uml-image">
</section>

<section>
    <h3>Refactoring 2: Replace Conditional with Polymorphism</h3>
    <p class="subchapter">Ersetzen der bedingten Logik in den Charging Calculators durch Polymorphie</p>
    <div class="horizontal-spaced-container">
        <div>
            <h5>Vorher</h5>
            <pre><code class="java">public class DcChargingCalculator {
    private double calculatePowerReductionPercent(double startingSocPercent, double targetSocPercent) {
        if (targetSocPercent > 80) {
            return 60.0;
        } else if (targetSocPercent > 60) {
            return 30.0;
        } else {
            return 5.0;
        }
    }
}

public class AcChargingCalculator {
    private double calculateEfficiencyLoss(int connectorType) {
        switch (connectorType) {
            case HOUSEHOLD_SOCKET:
                return 0.1;
            case CAMPING_SOCKET:
                return 0.07;
            case WALLBOX:
                return 0.05;
            default:
                throw new IllegalArgumentException("Invalid connector type: " + connectorType);
        }
    }
}</code></pre>
        </div>
        <div>
            <h5>Nachher</h5>
            <pre><code class="java">public interface ChargingStrategy {
    double calculateEfficiency();
}

public class HouseholdSocketStrategy implements ChargingStrategy {
    @Override
    public double calculateEfficiency() {
        return 0.1;
    }
}

public class CampingSocketStrategy implements ChargingStrategy {
    @Override
    public double calculateEfficiency() {
        return 0.07;
    }
}

public class WallboxStrategy implements ChargingStrategy {
    @Override
    public double calculateEfficiency() {
        return 0.05;
    }
}

public class DcChargingStrategy implements ChargingStrategy {
    private final double targetSocPercent;
    
    public DcChargingStrategy(double targetSocPercent) {
        this.targetSocPercent = targetSocPercent;
    }
    
    @Override
    public double calculateEfficiency() {
        if (targetSocPercent > 80) {
            return 0.4; // 60% reduction
        } else if (targetSocPercent > 60) {
            return 0.7; // 30% reduction
        } else {
            return 0.95; // 5% reduction
        }
    }
}</code></pre>
        </div>
    </div>
</section>

<section>
    <h3>Refactoring 2: UML-Diagramm</h3>
    <img src="assets/UMLs-imgs/Kapitel_7-Refactoring_2.png" alt="Replace Conditional with Polymorphism UML"
        class="uml-image">
</section>

<section>
    <h3>Refactoring 2: Vorteile</h3>
    <ul>
        <li>Bessere Wartbarkeit durch klare Trennung der Verantwortlichkeiten</li>
        <li>Einfache Erweiterbarkeit durch neue Strategien</li>
        <li>Bessere Testbarkeit durch isolierte Komponenten</li>
        <li>Einhaltung des Open/Closed Principle</li>
        <li>Reduzierte Komplexität in den Charging Calculators</li>
    </ul>
</section>