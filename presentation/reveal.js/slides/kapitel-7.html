<section>
    <h2 class="chapter-title">Kapitel 7: Architektur (8P)</h2>
</section>

<section>
    <h3>Schichtenarchitektur (2P)</h3>
    <div class="horizontal-spaced-container">
        <div>
            <h5>Klassische Schichten in ULRICA</h5>
            <ul>
                <li><b>Presentation Layer:</b> UI-Komponenten, Controller</li>
                <li><b>Application Layer:</b> Services, Use Cases, DTOs</li>
                <li><b>Domain Layer:</b> Entities, Value Objects, Domain Services</li>
                <li><b>Infrastructure Layer:</b> Repositories, externe Dienste</li>
            </ul>
            <p>Die Abhängigkeiten verlaufen stets von oben nach unten, jede Schicht darf nur auf Schichten zugreifen, die sich unter ihr befinden.</p>
        </div>
        <div>
            <img src="assets/img/layered-arch.png" alt="Layered Architecture Diagram" class="uml-image">
        </div>
    </div>
</section>

<section>
    <h3>Hexagonale Architektur (2P)</h3>
    <div class="horizontal-spaced-container">
        <div>
            <h5>Ports und Adapter in ULRICA</h5>
            <ul>
                <li>Kern-Domain ist unabhängig von externen Abhängigkeiten</li>
                <li>Alle externen Interaktionen über definierte Ports</li>
                <li>Ports definieren Schnittstellen, Adapter implementieren sie</li>
                <li>Beispiel: CarProfilePersistencePortInterface & JsonCarProfileRepository</li>
            </ul>
        </div>
        <div>
            <img src="assets/img/hexagonal-arch.png" alt="Hexagonal Architecture Diagram" class="uml-image">
        </div>
    </div>
</section>

<section>
    <h3>Domain-Driven Design (2P)</h3>
    <div class="horizontal-spaced-container">
        <div>
            <h5>DDD-Patterns in ULRICA</h5>
            <ul>
                <li>Entities mit klarer Identität (CarProfile)</li>
                <li>Value Objects für unveränderliche Werteobjekte (BatteryProfile)</li>
                <li>Aggregates für Transaktionsgrenzen (CarProfile als Root)</li>
                <li>Repositories für Objektpersistenz (CarProfileRepository)</li>
                <li>Domain Services für komplexe Operationen (RangeCalculatorService)</li>
                <li>Ubiquitous Language als gemeinsames Vokabular</li>
            </ul>
        </div>
        <div>
            <pre><code class="java">// Domain-Driven Design Beispiel
// Entity mit Value Objects
public class CarProfile {
    private final String id;
    private final String name;
    private final BatteryProfile batteryProfile;
    private final ConsumptionProfile consumptionProfile;
    private final Optional<ChargingCurve> chargingCurve;
    
    // Builder-Pattern für komplexe Objekte
    public static class Builder {
        // Builder-Implementierung
    }
    
    // Domain-Logik innerhalb der Entity
    public double getEffectiveCapacityKwh() {
        return batteryProfile.getEffectiveCapacityKwh();
    }
}</code></pre>
        </div>
    </div>
</section>

<section>
    <h3>Clean Architecture (2P)</h3>
    <div class="horizontal-spaced-container">
        <div>
            <h5>Dependency Rule in ULRICA</h5>
            <ul>
                <li>Abhängigkeiten zeigen immer nach innen zur Domain</li>
                <li>Domain ist unabhängig von externen Frameworks</li>
                <li>Interfaces definieren die Abhängigkeiten (Dependency Inversion)</li>
                <li>Use Cases koordinieren die Anwendungslogik</li>
                <li>DTOs für die Datentransformation zwischen Schichten</li>
            </ul>
        </div>
        <div>
            <img src="assets/img/clean-arch.png" alt="Clean Architecture Diagram" class="uml-image">
        </div>
    </div>
</section>

<section>
    <h3>Konkretes Beispiel: Reichweitenberechnung</h3>
    <div class="horizontal-spaced-container">
        <div>
            <h5>Architektur in der Praxis</h5>
            <ul>
                <li><b>Presentation:</b> RangeCalculationFragment.kt</li>
                <li><b>Application:</b> RangeCalculationUseCase.java</li>
                <li><b>Domain:</b> RangeCalculatorService.java</li>
                <li><b>Infrastructure:</b> SpeedConsumptionRepository.java</li>
            </ul>
        </div>
        <div>
            <pre><code class="java">// Presentation Layer (UI)
public void onCalculateButtonClicked() {
    // Sammelt Benutzereingaben
    RangeParameters params = collectUserInputs();
    
    // Delegiert an Application Layer
    viewModel.calculateRange(params);
}

// Application Layer (Use Case)
public RangeResultDto calculateRange(RangeParameters params) {
    // Wendet Geschäftsregeln an
    RangeResult result = rangeCalculatorService.calculateRange(
        currentCarProfile, params);
    
    // Transformiert Domain-Objekt in DTO
    return mapToDto(result);
}

// Domain Layer (Domain Service)
public RangeResult calculateRange(CarProfile car, 
                                 RangeParameters params) {
    // Enthält die Kernlogik der Berechnung
    double range = calculateBaseRange(car, params);
    range = applyTemperatureEffect(range, params.getTemperature());
    
    return new RangeResult(range, params);
}</code></pre>
        </div>
    </div>
</section>

<section>
    <h3>Vor- und Nachteile der Architektur</h3>
    <div class="horizontal-spaced-container">
        <div>
            <h5>Vorteile</h5>
            <ul>
                <li>Hohe Testbarkeit durch klare Trennung der Verantwortlichkeiten</li>
                <li>Unabhängigkeit der Domain von externen Frameworks</li>
                <li>Bessere Wartbarkeit durch klare Struktur</li>
                <li>Erweiterbarkeit durch Plugins-Architektur</li>
                <li>Langfristige Flexibilität bei Technologiewechseln</li>
            </ul>
        </div>
        <div>
            <h5>Herausforderungen</h5>
            <ul>
                <li>Höherer initialer Entwicklungsaufwand</li>
                <li>Mehr Quellcode durch zusätzliche Abstraktionsebenen</li>
                <li>Komplexere Projektstruktur</li>
                <li>Einarbeitungszeit für neue Entwickler</li>
                <li>Bewusstes "Overengineering" für zukünftige Flexibilität</li>
            </ul>
        </div>
    </div>
</section>

<section>
    <h3>Schematische Darstellung der Architektur in ULRICA</h3>
    <img src="assets/UMLs-imgs/Kapitel_7-Übersicht.png" alt="Architecture Overview" class="fullwidth-image">
</section>

<section>
    <h3>Integration mit Android</h3>
    <div class="horizontal-spaced-container">
        <div>
            <h5>Anpassungen für Android</h5>
            <ul>
                <li>Presentation Layer verwendet Android-UI-Framework</li>
                <li>ViewModels als Brücke zwischen UI und Application Layer</li>
                <li>Dependency Injection mit Dagger/Hilt</li>
                <li>Room Database als persistenz-Adapter</li>
                <li>Coroutines für asynchrone Operationen</li>
            </ul>
        </div>
        <div>
            <pre><code class="kotlin">// ViewModel als Teil des Presentation Layers
class RangeViewModel @Inject constructor(
    private val rangeCalculationUseCase: RangeCalculationUseCase
) : ViewModel() {
    
    private val _rangeResult = MutableLiveData<RangeResultDto>()
    val rangeResult: LiveData<RangeResultDto> = _rangeResult
    
    fun calculateRange(params: RangeParameters) {
        viewModelScope.launch {
            // Asynchroner Aufruf des Use Cases
            val result = withContext(Dispatchers.Default) {
                rangeCalculationUseCase.calculateRange(params)
            }
            _rangeResult.value = result
        }
    }
}</code></pre>
        </div>
    </div>
</section>

<section>
    <h3>Zusammenfassung: Architektur in ULRICA</h3>
    <ul>
        <li><b>Schichtenarchitektur:</b> Klare Trennung der Verantwortlichkeiten in vier Schichten</li>
        <li><b>Hexagonale Architektur:</b> Ports und Adapter für externe Abhängigkeiten</li>
        <li><b>Domain-Driven Design:</b> Fokus auf die Domäne mit Entities, Value Objects, Services</li>
        <li><b>Clean Architecture:</b> Abhängigkeitsregel mit nach innen gerichteten Abhängigkeiten</li>
        <li><b>Android-Integration:</b> Anpassung der Architektur an die Android-Plattform</li>
    </ul>
    <p>Die Kombination dieser Architekturansätze ermöglicht eine flexible, wartbare und testbare Anwendung mit klar getrennten Verantwortlichkeiten.</p>
</section>