<section>
    <h3>Kapitel 5: Unit Tests (8P)</h3>
</section>

<section>
    <h3>10 Unit Tests (2P)</h3>
    <ul>
        <li>Umfangreiche Test-Suite mit verschiedenen Testtypen</li>
        <li>Fokus auf Domain-Logic und Clean Architecture</li>
    </ul>
</section>

<section>
    <h3>Test #1: DC Charging Calculator</h3>
    <pre><code class="java">@Test
public void testCalculateChargingTime_WithChargingCurve() {
    // Testwerte definieren
    double startingSoc = 20.0;
    double targetSoc = 80.0;
    double maxStationPower = 250.0;
    double ambientTemperature = 25.0;
    
    // Ladekurve erstellen
    Map<Double, Double> curvePoints = new HashMap<>();
    curvePoints.put(0.0, 150.0);   // 0% SOC -> 150 kW
    curvePoints.put(20.0, 180.0);  // 20% SOC -> 180 kW
    curvePoints.put(50.0, 100.0);  // 50% SOC -> 100 kW
    curvePoints.put(80.0, 50.0);   // 80% SOC -> 50 kW
    curvePoints.put(100.0, 10.0);  // 100% SOC -> 10 kW
    ChargingCurve chargingCurve = new ChargingCurve(curvePoints);
    
    // Car mit Ladekurve erstellen
    CarProfile carWithCurve = new CarProfile.Builder()
        .id("test-id-curve")
        .name("Test EV with Curve")
        .manufacturer("Test Manufacturer")
        .model("Test Model")
        .year(2023)
        .hasHeatPump(true)
        .wltpRangeKm(500)
        .maxDcPowerKw(250.0)
        .maxAcPowerKw(11.0)
        .batteryProfile(batteryProfile)
        .consumptionProfile(consumptionProfile)
        .chargingCurve(chargingCurve)
        .build();
    
    // Service-Methode aufrufen
    DcChargingResult result = calculator.calculateChargingTime(
        carWithCurve, 
        startingSoc, 
        targetSoc, 
        maxStationPower, 
        ambientTemperature
    );
    
    // Validierung der berechneten Werte
    double expectedEnergyToAdd = batteryProfile.getRemainingCapacityKwh() * 0.6;
    assertEquals(expectedEnergyToAdd, result.getEnergyToAddKwh(), 0.01);
    assertTrue(result.getChargingTimeHours() > 0);
    assertTrue(result.getEffectivePowerKw() > 0);
}</code></pre>
    <p>Testet komplexe Ladeberechnungen mit dynamischer Ladekurve und verschiedenen SOC-Bereichen</p>
</section>

<section>
    <h3>Test #2: Range Calculator Service - Strategy Pattern</h3>
    <pre><code class="java">@Test
public void testAddStrategy() {
    // Ausgangssituation dokumentieren
    int initialCount = rangeCalculatorService.getAvailableStrategies().size();
    
    // Mock-Strategie erstellen 
    RangeCalculationStrategyInterface mockStrategy = new RangeCalculationStrategyInterface() {
        @Override
        public RangeResult calculateRange(CarProfile carProfile, RangeParameters params) {
            return new RangeResult(
                300.0, 
                20.0,  
                "No weather impact",
                "No terrain impact",
                "No environment impact",
                "Battery in good condition"
            );
        }
        
        @Override
        public String getName() {
            return "MockStrategy";
        }
        
        @Override
        public String getDescription() {
            return "A mock strategy for testing";
        }
    };
    
    // Strategie hinzufügen
    rangeCalculatorService.addStrategy(mockStrategy);
    
    // Validierung: Strategien-Anzahl ist um 1 erhöht
    assertEquals(initialCount + 1, rangeCalculatorService.getAvailableStrategies().size());
}</code></pre>
    <p>Testet die dynamische Erweiterbarkeit durch das Strategy-Pattern im RangeCalculatorService</p>
</section>

<section>
    <h3>Test #3: ChargingCurve Interpolation</h3>
    <pre><code class="java">@Test
public void testGetChargingPowerAt_Interpolation() {
    // Testdaten mit drei Kurven-Punkten erstellen
    Map<Double, Double> curvePoints = new HashMap<>();
    curvePoints.put(0.0, 150.0);    // 0% -> 150 kW
    curvePoints.put(50.0, 100.0);   // 50% -> 100 kW
    curvePoints.put(100.0, 10.0);   // 100% -> 10 kW
    ChargingCurve chargingCurve = new ChargingCurve(curvePoints);
    
    // Test der linearen Interpolation zwischen Punkten
    
    // Test Punkt zwischen 0% und 50%
    assertEquals(125.0, chargingCurve.getChargingPowerAt(25.0), 0.001);
    
    // Test Punkt zwischen 50% und 100%
    assertEquals(55.0, chargingCurve.getChargingPowerAt(75.0), 0.001);
}</code></pre>
    <p>Testet die korrekte lineare Interpolation bei der Ladekurve zwischen definierten Punkten</p>
</section>

<section>
    <h3>Test #4: ExecuteAction - Komplexe UI-Interaktion</h3>
    <pre><code class="java">@Test
public void testExecuteAction_NoProfileSelected() {
    // Profil-Auswahl leeren
    profileSelectionService.clearSelection();
    
    // Action ausführen (DC-Ladung starten)
    boolean result = executeActionInteractor.executeAction(1);
    
    // Validieren des erwarteten Verhaltens
    assertFalse(result);
    assertEquals(1, actionResultView.getErrorCount());
    assertEquals(0, actionResultView.getSuccessCount());
    assertEquals(0, dcChargingController.getProcessCallCount());
    assertEquals(0, acChargingController.getProcessCallCount());
    assertEquals(0, rangeCalculationController.getProcessCallCount());
    assertTrue(actionResultView.lastErrorContains("No car profile selected"));
}</code></pre>
    <p>Testet das komplexe Zusammenspiel zwischen UI-Controller, Views und Geschäftslogik mit Mock-Objekten</p>
</section>

<section>
    <h3>Test #5: DC Charging - Temperatureinfluss</h3>
    <pre><code class="java">@Test
public void testCalculateChargingTime_LowTemperature() {
    // Kalte Umgebungstemperatur als Testbedingung
    double startingSoc = 20.0;
    double targetSoc = 60.0;
    double maxStationPower = 250.0;
    double ambientTemperature = -10.0; // Sehr kalter Tag
    
    // Service-Methode mit Testwerten aufrufen
    DcChargingResult result = calculator.calculateChargingTime(
        mockCarProfile, 
        startingSoc, 
        targetSoc, 
        maxStationPower, 
        ambientTemperature
    );
    
    // Temperatureinfluss auf Batterie validieren
    double expectedBatteryTemp = ambientTemperature + 5.9;
    assertEquals(expectedBatteryTemp, result.getEndTemperatureCelsius(), 0.01);
    
    // Leistungsreduktion aufgrund der Temperatur validieren
    assertTrue("Bei kalter Temperatur sollte Ladeleistung reduziert sein", 
        result.getEffectivePowerKw() < maxStationPower);
    assertTrue("Bei kalten Temperaturen sollte Ladezeit länger sein", 
        result.getChargingTimeHours() > 0.5);
}</code></pre>
    <p>Testet die realistische Simulation von Temperatureinflüssen auf das Ladeverhalten</p>
</section>

<section>
    <h3>Test #6: Validierung der Eingabeparameter</h3>
    <pre><code class="java">@Test
public void testValidateInputParameters_InvalidTargetSoc() {
    // Ungültiger SOC-Wert (über 100%)
    double startingSoc = 20.0;
    double invalidTargetSoc = 110.0;
    
    // Service-Methode aufrufen mit Erwartung auf Exception
    assertThrows(IllegalArgumentException.class, () -> {
        calculator.calculateChargingTime(
            mockCarProfile, 
            startingSoc, 
            invalidTargetSoc, 
            250.0, 
            25.0
        );
    });
}

@Test
public void testValidateInputParameters_TargetLessThanStarting() {
    // Fehlerhafter Case: Ziel-SOC niedriger als Start-SOC
    double startingSoc = 80.0;
    double targetSoc = 70.0; 
    
    // Validierung dass die API korrekterweise eine Exception wirft
    assertThrows(IllegalArgumentException.class, () -> {
        calculator.calculateChargingTime(
            mockCarProfile, 
            startingSoc, 
            targetSoc, 
            250.0, 
            25.0
        );
    });
}</code></pre>
    <p>Testet die robuste Validierung von Eingabeparametern in der Domain-Logik</p>
</section>

<section>
    <h3>Test #7: DI mit Mock-Objekten</h3>
    <pre><code class="java">@Test
public void testExecuteAction_DcCharging() {
    // Setup mit Mock-Objekten und Dependency Injection
    profileSelectionService.selectProfile(testProfile);
    dcChargingController.setProcessDcChargingResult(true);
    
    // Aktion ausführen
    boolean result = executeActionInteractor.executeAction(1);
    
    // Validieren des Verhaltens und der Interaktionen
    assertTrue(result);
    assertEquals(0, actionResultView.getErrorCount());
    assertEquals(1, dcChargingController.getProcessCallCount());
    assertEquals(0, acChargingController.getProcessCallCount());
    assertEquals(0, rangeCalculationController.getProcessCallCount());
}</code></pre>
    <p>Testet die korrekte Implementierung von Dependency Injection und das Zusammenspiel von Komponenten</p>
</section>

<section>
    <h3>Test #8: ChargingCurve - Robustheit</h3>
    <pre><code class="java">@Test
public void testInvalidConstructorArguments() {
    // Test mit null-Wert
    assertThrows(IllegalArgumentException.class, () -> {
        new ChargingCurve(null);
    });
    
    // Test mit leerer Map
    assertThrows(IllegalArgumentException.class, () -> {
        new ChargingCurve(new HashMap<>());
    });
    
    // Test mit ungültigem Batterie-Prozent (negativ)
    Map<Double, Double> invalidBatteryPercent1 = new HashMap<>();
    invalidBatteryPercent1.put(-10.0, 150.0);
    invalidBatteryPercent1.put(50.0, 100.0);
    assertThrows(IllegalArgumentException.class, () -> {
        new ChargingCurve(invalidBatteryPercent1);
    });
    
    // Test mit ungültigem Batterie-Prozent (über 100%)
    Map<Double, Double> invalidBatteryPercent2 = new HashMap<>();
    invalidBatteryPercent2.put(0.0, 150.0);
    invalidBatteryPercent2.put(110.0, 100.0);
    assertThrows(IllegalArgumentException.class, () -> {
        new ChargingCurve(invalidBatteryPercent2);
    });
}</code></pre>
    <p>Testet die umfassende Robustheit und Fehlerbehandlung in Value Objects</p>
</section>

<section>
    <h3>Test #9: Strategie-Vergleich im Range Calculator</h3>
    <pre><code class="java">@Test
public void testCompareStrategies() {
    // Strategien finden
    RangeCalculationStrategyInterface wltpStrategy = null;
    RangeCalculationStrategyInterface consumptionStrategy = null;
    
    for (RangeCalculationStrategyInterface strategy : rangeCalculatorService.getAvailableStrategies()) {
        if (strategy instanceof WltpBasedRangeCalculationStrategy) {
            wltpStrategy = strategy;
        }
        if (strategy instanceof ConsumptionBasedRangeCalculationStrategy) {
            consumptionStrategy = strategy;
        }
    }
    
    // Strategien sollten gefunden worden sein
    assertNotNull("WLTP strategy should be available", wltpStrategy);
    assertNotNull("Consumption strategy should be available", consumptionStrategy);
    
    // Mit beiden Strategien berechnen
    RangeResult wltpResult = rangeCalculatorService.calculateRangeWithStrategy(
        mockCarProfile, parameters, wltpStrategy);
    RangeResult consumptionResult = rangeCalculatorService.calculateRangeWithStrategy(
        mockCarProfile, parameters, consumptionStrategy);
    
    // Beide Ergebnisse validieren
    assertNotNull(wltpResult);
    assertNotNull(consumptionResult);
    assertTrue(wltpResult.getEstimatedRangeKm() > 0);
    assertTrue(consumptionResult.getEstimatedRangeKm() > 0);
}</code></pre>
    <p>Testet den Vergleich unterschiedlicher Berechnungs-Strategien für die gleichen Eingabeparameter</p>
</section>

<section>
    <h3>Test #10: ExecuteAction - Rollenbasierte Tests</h3>
    <pre><code class="java">@Test
public void testExecuteAction_InvalidChoice() {
    // Setup: Profil ausgewählt, aber ungültige Aktion
    profileSelectionService.selectProfile(testProfile);
    
    // Test mit ungültiger Aktionsauswahl (99)
    boolean result = executeActionInteractor.executeAction(99); 
    
    // Validierung: Aktion sollte fehlschlagen, keine Controller aufgerufen
    assertFalse(result);
    assertEquals(0, dcChargingController.getProcessCallCount());
    assertEquals(0, acChargingController.getProcessCallCount());
    assertEquals(0, rangeCalculationController.getProcessCallCount());
    
    // Fehlerausgang sollte korrekt angezeigt werden
    assertTrue(actionResultView.getErrorCount() > 0);
}</code></pre>
    <p>Testet die korrekte Rollenverteilung zwischen Interactor, Service und UI-Komponenten</p>
</section>

<section>
    <h3>ATRIP – Automatic, Thorough, Professional (2P)</h3>
</section>

<section>
    <h4>Automatic</h4>
    <pre><code class="java">// Testcase in DcChargingCalculatorTest.java
@Before
public void setUp() {
    calculator = new DcChargingCalculator();
    batteryProfile = new BatteryProfile(
        BatteryType.NMC,
        80.0,  
        5.0,   
        250.0, 
        11.0   
    );
    
    // Komplexes Testobjekt mit Builder-Pattern erstellen
    mockCarProfile = new CarProfile.Builder()
        .id("test-id")
        .name("Test EV")
        .manufacturer("Test Manufacturer")
        .model("Test Model")
        .year(2023)
        .hasHeatPump(true)
        .wltpRangeKm(500)
        .maxDcPowerKw(250.0)
        .maxAcPowerKw(11.0)
        .batteryProfile(batteryProfile)
        .consumptionProfile(new ConsumptionProfile(15, 20, 25))
        .build();
}</code></pre>
    <p>Tests sind vollständig automatisiert durch:</p>
    <ul>
        <li>JUnit Test-Framework mit standardisiertem Lebenszyklus (@Before, @Test, @After)</li>
        <li>Automatische Testdaten-Generierung über Builder-Pattern und Factory-Methoden</li>
        <li>Einsatz von Helper-Klassen wie MockCarProfile und MockChargingCurve</li>
        <li>Konsistente Test-Fixture über @Before für vergleichbare Testbedingungen</li>
        <li>Keine manuelle Interaktion erforderlich, volle CI/CD-Integration möglich</li>
    </ul>
</section>

<section>
    <h4>Thorough</h4>
    <pre><code class="java">// Testabdeckung im ChargingCurveTest.java
@Test public void testConstructorAndGetters() { ... }
@Test public void testGetChargingPowerAt_ExactPoints() { ... }
@Test public void testGetChargingPowerAt_Interpolation() { ... }
@Test public void testGetChargingPowerAt_OutOfRangeLow() { ... }
@Test public void testGetChargingPowerAt_OutOfRangeHigh() { ... }
@Test public void testEqualsAndHashCode() { ... }
@Test public void testInvalidConstructorArguments() { ... }
@Test public void testInvalidGetChargingPowerAt() { ... }

// Temperatur-Tests in DcChargingCalculatorTest
@Test public void testCalculateChargingTime_BasicScenario() { ... }
@Test public void testCalculateChargingTime_LowTemperature() { ... }
@Test public void testCalculateChargingTime_WithChargingCurve() { ... }
@Test public void testCalculateChargingTime_HigherSoC() { ... }</code></pre>
    <p>Hohe Testabdeckung durch:</p>
    <ul>
        <li>Umfassende Testgruppen zu allen Aspekten einer Komponente</li>
        <li>Systematisches Testen aller Pfade (normaler Ablauf, Grenzfälle, Fehlerszenarien)</li>
        <li>Explizite Tests für Interpolation, Extrapolation und Randwerte</li>
        <li>Vollständige Abdeckung von Validierungslogik (Beispiel: alle Invalid-Fälle)</li>
        <li>Kombinatorik relevanter Parameter (Temperaturen, SOC-Werte, Ladekurven)</li>
        <li>Testen von Value-Object-Invarianten (Equals/HashCode, Immutability)</li>
    </ul>
</section>

<section>
    <h4>Professional</h4>
    <pre><code class="java">@Test
public void testCompareStrategies() {
    // Given: Identifiziere beide Strategien aus dem Service
    RangeCalculationStrategyInterface wltpStrategy = null;
    RangeCalculationStrategyInterface consumptionStrategy = null;
    
    for (RangeCalculationStrategyInterface strategy : 
            rangeCalculatorService.getAvailableStrategies()) {
        if (strategy instanceof WltpBasedRangeCalculationStrategy) {
            wltpStrategy = strategy;
        }
        if (strategy instanceof ConsumptionBasedRangeCalculationStrategy) {
            consumptionStrategy = strategy;
        }
    }
    
    // Assert: Strategien sollten verfügbar sein
    assertNotNull("WLTP strategy should be available", wltpStrategy);
    assertNotNull("Consumption strategy should be available", consumptionStrategy);
    
    // When: Berechne Range mit beiden Strategien
    RangeResult wltpResult = rangeCalculatorService.calculateRangeWithStrategy(
        mockCarProfile, parameters, wltpStrategy);
    RangeResult consumptionResult = rangeCalculatorService.calculateRangeWithStrategy(
        mockCarProfile, parameters, consumptionStrategy);
    
    // Then: Validiere die Ergebnisse beider Strategien
    assertNotNull(wltpResult);
    assertNotNull(consumptionResult);
    assertTrue("WLTP range should be positive", wltpResult.getEstimatedRangeKm() > 0);
    assertTrue("Consumption range should be positive", 
        consumptionResult.getEstimatedRangeKm() > 0);
}</code></pre>
    <p>Professionelle Teststruktur durch:</p>
    <ul>
        <li>Strenge Einhaltung des Given-When-Then / Arrange-Act-Assert Patterns</li>
        <li>Aussagekräftige Assertion-Nachrichten für bessere Fehlererkennung</li>
        <li>Konsequente, semantische Benennung nach testing_whatBehavior_underWhatConditions</li>
        <li>Tests als lebende Dokumentation der Komponentenfunktionalität</li>
        <li>Systematische Organisation von verwandten Tests in strukturierten Testklassen</li>
        <li>Unit Tests spiegeln die Clean Architecture wider (Domain, Application, Infrastructure)</li>
    </ul>
</section>

<section>
    <h3>Fakes und Mocks (4P)</h3>
</section>

<section>
    <h3>Mock #1: MockProfileSelectionService</h3>
    <pre><code class="java">public class MockProfileSelectionService implements ProfileSelectionService {
    
    private CarProfile selectedProfile;
    private int selectionCount = 0;
    private int clearCount = 0;
    
    public MockProfileSelectionService() {
        this.selectedProfile = null;
    }
    
    public MockProfileSelectionService(CarProfile initialProfile) {
        this.selectedProfile = initialProfile;
    }

    @Override
    public CarProfile getSelectedProfile() {
        return selectedProfile;
    }

    @Override
    public void selectProfile(CarProfile profile) {
        this.selectedProfile = profile;
        this.selectionCount++;
    }

    @Override
    public void clearSelection() {
        this.selectedProfile = null;
        this.clearCount++;
    }
    
    // Test-spezifische Methoden für Validierung
    public int getSelectionCount() {
        return selectionCount;
    }
    
    public int getClearCount() {
        return clearCount;
    }
    
    public boolean hasSelectedProfile() {
        return selectedProfile != null;
    }
}</code></pre>
    <p>Implementiert das ProfileSelectionService Interface mit zusätzlichen Testfunktionen</p>
</section>

<section>
    <h3>Mock #1: Analyse</h3>
    <div class="horizontal-container">
        <div>
            <h4>Einsatzzweck</h4>
            <ul>
                <li>Simuliert den ProfileSelectionService für Tests von abhängigen Komponenten</li>
                <li>Ermöglicht die Isolierung der ExecuteActionInteractor-Klasse vom echten Service</li>
                <li>Bietet Counters für Methodenaufrufe zur Verifizierung der Interaktionen</li>
                <li>Erleichtert sowohl Setup als auch Validierung in komplexen Testszenarien</li>
            </ul>
        </div>
        <div>
            <h4>Vorteile</h4>
            <ul>
                <li>Eliminiert externe Abhängigkeiten (Datenbank, Filesystem)</li>
                <li>Erlaubt präzise Kontrolle des Testzustands und -verhaltens</li>
                <li>Verbessert Testgeschwindigkeit durch Vermeidung realer Datenbankoperationen</li>
                <li>Ermöglicht Test-spezifische Validierungsmethoden (getSelectionCount, hasSelectedProfile)</li>
                <li>Unterstützt vollständige Überprüfung des Interact-Verhaltens mit und ohne Profil</li>
            </ul>
        </div>
    </div>
</section>

<section>
    <h3>Mock #1: UML Beziehungsdiagramm</h3>
    <pre><code class="text">┌───────────────────────┐         ┌───────────────────────┐
│ProfileSelectionService │         │ExecuteActionInteractor │
├───────────────────────┤         ├───────────────────────┤
│+getSelectedProfile()  │◄────────┤-profileSelectionService│
│+selectProfile()       │         │+executeAction()        │
│+clearSelection()      │         └───────────────────────┘
└───────────┬───────────┘                    ▲
            ▲                                │
            │implements                      │uses
            │                                │
┌───────────┴───────────┐         ┌───────────────────────┐
│MockProfileSelection   │◄────────┤ExecuteActionInteractor│
│Service                │         │Test                    │
├───────────────────────┤         ├───────────────────────┤
│-selectedProfile       │         │+testExecuteAction_     │
│-selectionCount        │         │  NoProfileSelected()   │
│-clearCount            │         │+testExecuteAction_     │
│+getSelectionCount()   │         │  DcCharging()          │
│+getClearCount()       │         └───────────────────────┘
│+hasSelectedProfile()  │
└───────────────────────┘</code></pre>
    <p>Das Mock-Objekt implementiert das Interface, fügt zusätzliche Funktionalität für Tests hinzu und wird in Tests verwendet, um die abhängige Klasse isoliert zu testen.</p>
</section>

<section>
    <h3>Mock #2: RangeCalculationStrategyInterface Mock</h3>
    <pre><code class="java">@Test
public void testAddStrategy() {
    // Ausgangszustand dokumentieren
    int initialCount = rangeCalculatorService.getAvailableStrategies().size();
    
    // Mock-Strategie als anonyme Implementierung erstellen
    RangeCalculationStrategyInterface mockStrategy = new RangeCalculationStrategyInterface() {
        @Override
        public RangeResult calculateRange(CarProfile carProfile, RangeParameters params) {
            // Vordefiniertes Ergebnis zurückgeben
            return new RangeResult(
                300.0,  // Fest definierte Reichweite
                20.0,   // Fest definierter Verbrauch
                "No weather impact",
                "No terrain impact",
                "No environment impact",
                "Battery in good condition"
            );
        }
        
        @Override
        public String getName() {
            return "MockStrategy";
        }
        
        @Override
        public String getDescription() {
            return "A mock strategy for testing";
        }
    };
    
    // Strategie zum Service hinzufügen
    rangeCalculatorService.addStrategy(mockStrategy);
    
    // Überprüfen: Strategie wurde erfolgreich hinzugefügt
    assertEquals(initialCount + 1, rangeCalculatorService.getAvailableStrategies().size());
    
    // Mit Mock-Strategie berechnen
    RangeResult result = rangeCalculatorService.calculateRangeWithStrategy(
        mockCarProfile, parameters, mockStrategy);
    
    // Ergebnis validieren
    assertEquals(300.0, result.getEstimatedRangeKm(), 0.1);
    assertEquals(20.0, result.getAverageConsumptionKwhPer100Km(), 0.1);
}</code></pre>
    <p>Ein fortgeschrittenes Inline-Mock einer Strategie mittels anonymer Implementierung</p>
</section>

<section>
    <h3>Mock #2: Analyse</h3>
    <div class="horizontal-container">
        <div>
            <h4>Einsatzzweck</h4>
            <ul>
                <li>Simulation einer Berechnungsstrategie für Tests im RangeCalculatorService</li>
                <li>Implementiert das RangeCalculationStrategyInterface mit vollständig kontrolliertem Verhalten</li>
                <li>Ermöglicht das Testen der Service-Methoden mit vorhersagbaren Ergebnissen</li>
                <li>Demonstriert die Erweiterbarkeit durch das Strategy-Pattern</li>
            </ul>
        </div>
        <div>
            <h4>Vorteile</h4>
            <ul>
                <li>Inline-Definition für spezifische Testfälle ohne separate Klasse</li>
                <li>Vorhersagbare Ergebnisse durch fest definierte Rückgabewerte</li>
                <li>Verifikation der Strategy-Integration in den Service</li>
                <li>Unterstützt Test der dynamischen Strategieerweiterung</li>
                <li>Validierung der Adapterfunktionalität des Service gegenüber Strategien</li>
                <li>Kontrolle des Verhaltens ohne komplexe Domain-Logik</li>
            </ul>
        </div>
    </div>
</section>

<section>
    <h3>Mock #2: UML Beziehungsdiagramm</h3>
    <pre><code class="text">┌──────────────────────────┐         ┌────────────────────────┐
│RangeCalculationStrategy  │         │RangeCalculatorService   │
│Interface                 │◄────────┤-availableStrategies     │
├──────────────────────────┤         │-defaultStrategy         │
│+calculateRange()         │         ├────────────────────────┤
│+getName()                │         │+calculateRange()        │
│+getDescription()         │         │+addStrategy()           │
└────────────┬─────────────┘         │+setDefaultStrategy()    │
             ▲                       └────────────┬────────────┘
             │implements                          ▲
             │                                    │tested by
┌────────────┴─────────────┐         ┌────────────┴────────────┐
│Anonymous Implementation  │         │RangeCalculatorServiceTest│
│(MockStrategy)            │         ├────────────────────────┤
├──────────────────────────┤         │+testAddStrategy()       │
│+calculateRange() {       │         │+testSetDefaultStrategy()│
│  return new RangeResult()│         │+testCompareStrategies() │
│}                         │         └────────────────────────┘
└──────────────────────────┘</code></pre>
    <p>Die anonyme Implementierung von RangeCalculationStrategyInterface wird verwendet, um den RangeCalculatorService isoliert zu testen.</p>
</section>