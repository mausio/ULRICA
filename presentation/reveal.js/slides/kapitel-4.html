<section>
    <h2 class="chapter-title">Kapitel 4: Weitere Prinzipien (8P)</h2>
</section>

<section>
    <h3>Analyse GRASP: Geringe Kopplung (3P)</h3>
    <p>AcChargingController - Beispiel für geringe Kopplung</p>
    <img src="assets/UMLs-imgs/Kapitel_4-Aufgabe_1.png" alt="Geringe Kopplung UML Diagram" class="uml-image">
</section>

<section>
    <h3>Geringe Kopplung: Beziehung zu anderen Klassen</h3>
    <div class="horizontal-spaced-container">
        <div>
            <pre><code class="text">┌───────────────────────┐
│  AcChargingController │
└───────────┬───────────┘
            │
            ▼ abhängig von
┌────────────────────────────┐
│ UserInputPortInterface     │◄─────┐
│ UserOutputPortInterface    │◄─────┼───┐
│ CalculateAcChargingUseCase │◄─────┘   │
│ AcChargingOutputPortInterface◄────────┘
└────────────────────────────┘
            ▲
            │ implementiert
            │
┌───────────┴───────────┐
│ ConcreteImplementations│
└───────────────────────┘</code></pre>
        </div>
        <div>
            <h5>Geringe Kopplung durch:</h5>
            <ul>
                <li>Ausschließliche Abhängigkeit von Interfaces statt konkreten Implementierungen</li>
                <li>Dependency Injection über Konstruktor</li>
                <li>Klare Trennung von Ein-/Ausgabe und Business-Logik</li>
                <li>Keine hardcodierten Abhängigkeiten</li>
                <li>Keine Stateful-Objekte oder Singletons</li>
            </ul>
        </div>
    </div>
</section>

<section>
    <h3>Vorteile der geringen Kopplung</h3>
    <ul>
        <li><b>Testbarkeit:</b> Einfaches Mocking der Abhängigkeiten für Unit-Tests</li>
        <li><b>Wartbarkeit:</b> Änderungen an Implementierungen der Ports haben keinen Einfluss auf den Controller</li>
        <li><b>Flexibilität:</b> Verschiedene Implementierungen können ohne Änderung am Controller ausgetauscht werden</li>
        <li><b>Wiederverwendbarkeit:</b> Der Controller kann mit unterschiedlichen Implementierungen genutzt werden</li>
        <li><b>Parallel Development:</b> Teams können gleichzeitig an Controller und Implementierungen arbeiten</li>
        <li><b>Verständlichkeit:</b> Klare Verantwortlichkeiten und Abhängigkeiten</li>
    </ul>
</section>

<section>
    <h3>Analyse GRASP: Polymorphismus (3P)</h3>
    <p>RangeCalculationStrategyInterface - Anwendung des Polymorphismus</p>
    <img src="assets/UMLs-imgs/Kapitel_4-Aufgabe_2.png" alt="Polymorphismus UML Diagram" class="uml-image">
</section>

<section>
    <h3>Polymorphismus: UML und Anwendung</h3>
    <div class="horizontal-spaced-container">
        <div>
            <pre><code class="text">┌───────────────────────────┐
│RangeCalculationStrategy    │
│Interface                   │
├───────────────────────────┤
│+ calculateRange()          │
│+ getName()                 │
│+ getDescription()          │
└─────────────┬─────────────┘
              ▲
              │ implementiert
        ┌─────┴───────┐
        │             │
┌───────┴──────┐ ┌────┴───────────┐
│WltpBased     │ │ConsumptionBased│
│Strategy      │ │Strategy         │
├──────────────┤ ├────────────────┤
│+ calculateRange│ │+ calculateRange│
│+ getName()    │ │+ getName()     │
└──────────────┘ └────────────────┘</code></pre>
        </div>
        <div>
            <h5>Anwendung im RangeCalculatorService:</h5>
            <pre><code class="java">public class RangeCalculatorService {
    private final List<RangeCalculationStrategyInterface> strategies;
    private RangeCalculationStrategyInterface defaultStrategy;
    
    // Constructor with initialization...
    
    public RangeResult calculateRange(
            CarProfile carProfile, 
            RangeParameters parameters) {
        return defaultStrategy.calculateRange(
            carProfile, parameters);
    }
}</code></pre>
        </div>
    </div>
</section>

<section>
    <h3>Vorteile des Polymorphismus</h3>
    <ul>
        <li><b>Erweiterbarkeit:</b> Neue Berechnungsstrategien können ohne Änderung des bestehenden Codes hinzugefügt werden</li>
        <li><b>Wiederverwendbarkeit:</b> Strategien können in verschiedenen Kontexten genutzt werden</li>
        <li><b>Kapselung:</b> Implementierungsdetails der Strategien sind hinter dem Interface verborgen</li>
        <li><b>Wartbarkeit:</b> Änderungen an einer Strategie beeinflussen andere Teile des Systems nicht</li>
        <li><b>Testbarkeit:</b> Strategien können isoliert getestet werden</li>
        <li><b>Komposition:</b> Verschiedene Strategien können zur Laufzeit ausgewählt und kombiniert werden</li>
    </ul>
</section>

<section>
    <h3>DRY – Don't Repeat Yourself (2P)</h3>
    <p>Commit <code>89f9ea2</code>: Refactoring von <code>CarProfileController</code> zur Reduktion duplizierter Logik</p>
    <div class="horizontal-spaced-container">
        <div>
            <h5>Problem:</h5>
            <ul>
                <li>Business-Logik war mit UI-Logik vermischt</li>
                <li>Duplizierter Code für ähnliche Operationen</li>
                <li>Schwer zu erkennendes Muster im Code</li>
                <li>Hohe Fehleranfälligkeit bei Änderungen</li>
            </ul>
        </div>
        <div>
            <h5>Lösung:</h5>
            <ul>
                <li>Auslagerung der Business-Logik in einen Service</li>
                <li>Zusammenfassung ähnlicher Methoden</li>
                <li>Einführung von Hilfsmethoden für gemeinsame Funktionalität</li>
                <li>Trennung von UI und Geschäftslogik</li>
            </ul>
        </div>
    </div>
</section>

<section>
    <h3>DRY – Vorher: Überfüllter Controller</h3>
    <pre><code class="java">public class CarProfileController {
  private static Scanner scanner;
  private final LoadingScreenAnimation loadingScreenAnimation;
  private Thread loadingAnimationThread;
  private Thread loadingJsonThread;
  private CarProfileModel carProfile;
  private ConsumptionProfileModel consumptionProfile;
  
  public CarProfileController() throws LoadingException {
    JsonCarProfilesLoader carProfileJsonLoader = SetupService.getCarProfileJsonLoader();
    carProfile = SetupService.getCarProfile();
    consumptionProfile = SetupService.getConsumptionProfile();
    loadingScreenAnimation = SetupService.getLoadingScreenAnimation();
    loadingAnimationThread = new Thread(loadingScreenAnimation);
    loadingJsonThread = new Thread(carProfileJsonLoader);
    scanner = SetupService.getScanner();
    
    System.out.println("Hey! To begin with, let's see if you have any car profiles saved.");
    SleepUtil.waitForFSeconds(1.0);
    
    startLoadingThreads();
    
    SleepUtil.waitForFSeconds(3.0);
    
    stopLoadingThreads();
    
    CarProfileModel[] carProfiles = carProfileJsonLoader.getCarProfiles();
    
    if (carProfiles == null || carProfiles.length <= 1) {
      System.out.println("→ No car profiles could be found;\n  Continuing with creating a new car profile.");
      SleepUtil.waitForFSeconds(2.0);
      createCarProfileDialog();
    } else {
      // Weitere Logik...
    }
  }
  
  // Weitere Methoden...
}</code></pre>
</section>

<section>
    <h3>DRY – Nachher: Getrennter Controller und Service</h3>
    <div class="horizontal-spaced-container">
        <div>
            <h5>Controller: UI-Logik</h5>
            <pre><code class="java">public class CarProfileController {
  
  public static void startDialog() {
    System.out.println(
        "Hey! To begin with, let's see if you have any car profiles saved.");
  }
  
  public static Double getConsumptionDialog(Scanner scanner) {
    System.out.print("consumption: (in kWh) ");
    String input = scanner.nextLine();
    if (!input.isEmpty()) {
      return Double.valueOf(input);
    }
    return null;
  }
  
  // Weitere UI-Methoden...
}</code></pre>
        </div>
        <div>
            <h5>Service: Business-Logik</h5>
            <pre><code class="java">public class CarProfileService {
  
  private JsonCarProfilesLoader carProfileJsonLoader;
  private CarProfileModel carProfile;
  
  public CarProfileService() throws LoadingException {
    this.carProfileJsonLoader = 
      SetupService.getCarProfileJsonLoader();
    
    // UI-Interaktion über Controller
    CarProfileController.startDialog();
    
    // Laden der Profile
    loadProfiles();
    
    // Weitere Business-Logik...
  }
  
  private void loadProfiles() {
    // Gemeinsame Ladelogik, nicht mehr dupliziert
    CarProfileModel[] profiles = 
        carProfileJsonLoader.getCarProfiles();
    
    if (profiles == null || profiles.length <= 1) {
      createNewProfile();
    } else {
      selectExistingProfile(profiles);
    }
  }
  
  // Weitere Business-Methoden...
}</code></pre>
        </div>
    </div>
</section>

<section>
    <h3>DRY – Vorteile der Refaktorierung</h3>
    <ul>
        <li><b>Bessere Wartbarkeit:</b> Änderungen an UI oder Business-Logik können unabhängig durchgeführt werden</li>
        <li><b>Geringere Redundanz:</b> Gemeinsam genutzter Code ist an einer zentralen Stelle definiert</li>
        <li><b>Bessere Testbarkeit:</b> Service kann unabhängig von UI getestet werden</li>
        <li><b>Single Responsibility Principle:</b> Klassen haben nur eine Verantwortlichkeit</li>
        <li><b>Clean Architecture:</b> Klare Trennung der Schichten zwischen Presentation und Application</li>
        <li><b>Übersichtlichkeit:</b> Kürzere Klassen mit klaren Zuständigkeiten</li>
    </ul>
</section>