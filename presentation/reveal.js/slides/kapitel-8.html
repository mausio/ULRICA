<section>
    <h2 class="chapter-title">Kapitel 8: Entwurfsmuster (8P)</h2>
</section>

<section>
    <h3>Entwurfsmuster 1: Strategy Pattern (4P)</h3>
    <div class="horizontal-spaced-container">
        <div>
            <h4>Überblick</h4>
            <ul>
                <li><b>Kategorie:</b> Verhaltensmuster (Behavioral Pattern)</li>
                <li><b>Zweck:</b> Definiert eine Familie von Algorithmen, kapselt sie und macht sie austauschbar</li>
                <li><b>Verwendung:</b> Implementierung verschiedener Berechnungsstrategien für die Reichweite von Elektrofahrzeugen</li>
            </ul>
        </div>
        <div>
            <h4>Key Features</h4>
            <ul>
                <li>Kapselung von unterschiedlichen Algorithmen in getrennten Klassen</li>
                <li>Laufzeitentscheidung über zu verwendende Strategie</li>
                <li>Leichte Erweiterbarkeit um neue Strategien</li>
                <li>Einhaltung des Open/Closed Principles</li>
                <li>Vermeidung von bedingten Verzweigungen durch Polymorphie</li>
            </ul>
        </div>
    </div>
</section>

<section>
    <h3>Strategy Pattern: Interface und Implementierungen</h3>
    <div class="horizontal-spaced-container">
        <div>
            <pre><code class="java">// Das Strategy Interface
public interface RangeCalculationStrategyInterface {
    
    RangeResult calculateRange(CarProfile carProfile, 
                              RangeParameters parameters);
    
    String getName();
    
    String getDescription();
}

// Erste Strategie-Implementierung
public class WltpBasedRangeCalculationStrategy 
        implements RangeCalculationStrategyInterface {
    
    @Override
    public RangeResult calculateRange(CarProfile carProfile, 
                                     RangeParameters parameters) {
        // Berechnung basierend auf WLTP-Werten
        double baseWltpRange = carProfile.getWltpRangeKm();
        double batteryCapacity = carProfile.getBatteryProfile()
                                .getRemainingCapacityKwh();
        // ... weitere Berechnungen
        return new RangeResult(/* ... */);
    }
    // ... weitere Methoden
}</code></pre>
        </div>
        <div>
            <pre><code class="java">// Zweite Strategie-Implementierung
public class ConsumptionBasedRangeCalculationStrategy 
        implements RangeCalculationStrategyInterface {
    
    @Override
    public RangeResult calculateRange(CarProfile carProfile, 
                                     RangeParameters parameters) {
        // Berechnung basierend auf Verbrauchsprofil
        ConsumptionProfile profile = carProfile
                                    .getConsumptionProfile();
        double baseConsumption = getBaseConsumption(
            profile, parameters.getEnvironment());
        // ... weitere Berechnungen
        return new RangeResult(/* ... */);
    }

    private double getBaseConsumption(
            ConsumptionProfile profile, 
            DrivingEnvironment environment) {
        // Unterschiedliche Verbrauchswerte je nach Umgebung
        return switch(environment) {
            case CITY -> profile.getConsumptionAt50Kmh();
            case RURAL -> profile.getConsumptionAt100Kmh();
            case HIGHWAY -> profile.getConsumptionAt130Kmh();
        };
    }
    // ... weitere Methoden
}</code></pre>
        </div>
    </div>
</section>

<section>
    <h3>Strategy Pattern: Verwendung im Client</h3>
    <div class="horizontal-spaced-container">
        <div>
            <pre><code class="java">// Client-Klasse, die die Strategien verwendet
public class RangeCalculatorService {
    private final List<RangeCalculationStrategyInterface> 
                                                strategies;
    private RangeCalculationStrategyInterface defaultStrategy;

    public RangeCalculatorService() {
        this.strategies = new ArrayList<>();
        
        // Initialisierung mit Standardstrategien
        WltpBasedRangeCalculationStrategy wltpStrategy = 
                new WltpBasedRangeCalculationStrategy();
        ConsumptionBasedRangeCalculationStrategy 
                consumptionStrategy = 
                new ConsumptionBasedRangeCalculationStrategy();
        
        this.strategies.add(wltpStrategy);
        this.strategies.add(consumptionStrategy);
        
        // Standard-Strategie setzen
        this.defaultStrategy = consumptionStrategy;
    }
    
    // Strategie zur Laufzeit ändern
    public void setDefaultStrategy(
            RangeCalculationStrategyInterface strategy) {
        // ... Validierung
        this.defaultStrategy = strategy;
    }
    
    // Berechnung mit der ausgewählten Strategie
    public RangeResult calculateRange(
            CarProfile carProfile, 
            RangeParameters parameters) {
        return defaultStrategy.calculateRange(
                carProfile, parameters);
    }
}</code></pre>
        </div>
        <div>
            <h4>Vorteile des Strategy Patterns im Projekt:</h4>
            <ul>
                <li>Unterschiedliche Berechnungsmethoden für Reichweite (WLTP-basiert vs. verbrauchsbasiert)</li>
                <li>Einfaches Hinzufügen neuer Strategien ohne Änderungen im Client-Code</li>
                <li>Klare Trennung von Algorithmus und Kontext</li>
                <li>Erhöhte Testbarkeit durch isolierte Strategien</li>
                <li>Auswahl der passenden Strategie je nach Anwendungsfall</li>
                <li>Reduzierte Komplexität im RangeCalculatorService</li>
            </ul>
        </div>
    </div>
</section>

<section>
    <h3>Strategy Pattern: UML-Diagramm</h3>
    <img src="assets/UMLs-imgs/Kapitel_8-Aufgabe_1.png" alt="Strategy Pattern UML Diagram" class="uml-image">
</section>

<section>
    <h3>Entwurfsmuster 2: Adapter Pattern (4P)</h3>
    <div class="horizontal-spaced-container">
        <div>
            <h4>Überblick</h4>
            <ul>
                <li><b>Kategorie:</b> Strukturmuster (Structural Pattern)</li>
                <li><b>Zweck:</b> Konvertiert die Schnittstelle einer Klasse in eine andere, die vom Client erwartet wird</li>
                <li><b>Verwendung:</b> Integration von I/O-Operationen in die Clean Architecture</li>
            </ul>
        </div>
        <div>
            <h4>Key Features</h4>
            <ul>
                <li>Ermöglicht Zusammenarbeit nicht-kompatibler Schnittstellen</li>
                <li>Trennt Geschäftslogik von externen Ressourcen</li>
                <li>Unterstützt das Dependency Inversion Principle</li>
                <li>Erhöht Flexibilität durch lose Kopplung</li>
                <li>Vereinfacht das Testen durch einfache Mock-Implementierungen</li>
            </ul>
        </div>
    </div>
</section>

<section>
    <h3>Adapter Pattern: UML-Diagramm</h3>
    <img src="assets/UMLs-imgs/Kapitel_8-Aufgabe_2.png" alt="Adapter Pattern UML Diagram" class="uml-image">
</section>

<section>
    <h3>Adapter Pattern: Port-Interfaces und Adapter</h3>
    <div class="horizontal-spaced-container">
        <div>
            <pre><code class="java">// Port Interface in der Anwendungsschicht
package org.ulrica.application.port.out;

public interface UserInputPortInterface {
    String readLine();
    int readInt();
    double readDouble();
    boolean readBoolean(String yesOption, String noOption);
}

// Port Interface in der Anwendungsschicht
package org.ulrica.application.port.out;

public interface UserOutputPortInterface {
    void display(String message);
    void displayLine(String message);
    void displayPrompt(String prompt);
}</code></pre>
        </div>
        <div>
            <pre><code class="java">// Adapter-Implementierung in der Infrastrukturschicht
package org.ulrica.infrastructure.adapter;

import java.util.Scanner;
import org.ulrica.application.port.out.UserInputPortInterface;

public class ConsoleUserInputAdapter implements UserInputPortInterface {
    private final Scanner scanner;
    
    public ConsoleUserInputAdapter(Scanner scanner) {
        this.scanner = scanner;
    }
    
    @Override
    public String readLine() {
        return scanner.nextLine();
    }
    
    @Override
    public int readInt() {
        return Integer.parseInt(scanner.nextLine());
    }
    
    // Weitere Methoden...
}</code></pre>
        </div>
    </div>
</section>

<section>
    <h3>Adapter Pattern: Verwendung im Client</h3>
    <div class="horizontal-spaced-container">
        <div>
            <pre><code class="java">// Controller aus der Presentation-Schicht
public class RangeCalculationController {
    private final UserInputPortInterface userInputPort;
    private final UserOutputPortInterface userOutputPort;
    private final CalculateRangeUseCaseInterface calculateRangeUseCase;
    
    public RangeCalculationController(
            UserInputPortInterface userInputPort,
            UserOutputPortInterface userOutputPort,
            CalculateRangeUseCaseInterface calculateRangeUseCase) {
        this.userInputPort = userInputPort;
        this.userOutputPort = userOutputPort;
        this.calculateRangeUseCase = calculateRangeUseCase;
    }
    
    public void processRangeCalculation() {
        // Benutzereingaben über Port sammeln
        userOutputPort.displayPrompt("Enter temperature (°C)");
        double temperature = userInputPort.readDouble();
        
        // Use Case über Interface ausführen
        CalculateRangeCommand command = 
                new CalculateRangeCommand(/* ... */);
        calculateRangeUseCase.calculateRange(command);
        
        // Controller kennt keine konkreten Implementierungen
    }
}</code></pre>
        </div>
        <div>
            <h4>Hauptvorteile des Adapter Patterns:</h4>
            <ul>
                <li>Clean Architecture durch Trennung von Domain und externen Systemen</li>
                <li>Erleichterte Tests durch einfaches Mocken der Ports</li>
                <li>Hohe Austauschbarkeit der Ein-/Ausgabemechanismen</li>
                <li>Zentralisierte Fehlerbehandlung in den Adaptern</li>
                <li>Domänenlogik bleibt frei von Ein-/Ausgabedetails</li>
                <li>Konversion zwischen technischen und Domänen-Datenformaten</li>
            </ul>
        </div>
    </div>
</section>

<section>
    <h3>Zusammenfassung der Entwurfsmuster in ULRICA</h3>
    <div class="horizontal-spaced-container">
        <div>
            <h4>Strategy Pattern</h4>
            <ul>
                <li>Ermöglicht austauschbare Berechnungsstrategien</li>
                <li>Unterstützt OCP durch Erweiterbarkeit</li>
                <li>Vereinfacht das Hinzufügen neuer Berechnungsmethoden</li>
                <li>Beispiel: Reichweitenberechnung mit verschiedenen Algorithmen</li>
            </ul>
        </div>
        <div>
            <h4>Adapter Pattern</h4>
            <ul>
                <li>Überbrückt die Kluft zwischen Domain und externen Systemen</li>
                <li>Fördert saubere Schichtenarchitektur</li>
                <li>Erhöht die Testbarkeit durch Entkopplung</li>
                <li>Beispiel: Konsolen-I/O-Adapter für Benutzerinteraktion</li>
            </ul>
        </div>
    </div>
    <p style="text-align: center; margin-top: 2rem;">Beide Muster fördern die Clean Architecture und verbessern die Wartbarkeit, Testbarkeit und Flexibilität des Gesamtsystems.</p>
</section>