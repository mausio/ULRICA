<section>Kapitel 8: Entwurfsmuster (8P)</section>

<section>
    <h3>Entwurfsmuster 1: Strategy Pattern (4P)</h3>
    <div class="horizontal-spaced-container">
        <div>
            <h4>Überblick</h4>
            <ul>
                <li><b>Kategorie:</b> Verhaltensmuster (Behavioral Pattern)</li>
                <li><b>Zweck:</b> Definiert eine Familie von Algorithmen, kapselt sie und macht sie austauschbar</li>
                <li><b>Verwendung:</b> Implementierung verschiedener Berechnungsstrategien für die Reichweite von Elektrofahrzeugen</li>
            </ul>
        </div>
        <div>
            <h4>Key Features</h4>
            <ul>
                <li>Kapselung von unterschiedlichen Algorithmen in getrennten Klassen</li>
                <li>Laufzeitentscheidung über zu verwendende Strategie</li>
                <li>Leichte Erweiterbarkeit um neue Strategien</li>
                <li>Einhaltung des Open/Closed Principles</li>
                <li>Vermeidung von bedingten Verzweigungen durch Polymorphie</li>
            </ul>
        </div>
    </div>
</section>

<section>
    <h3>Strategy Pattern: Interface und Implementierungen</h3>
    <div class="horizontal-spaced-container">
        <div>
            <pre><code class="java">// Das Strategy Interface
public interface RangeCalculationStrategyInterface {
    
    RangeResult calculateRange(CarProfile carProfile, 
                              RangeParameters parameters);
    
    String getName();
    
    String getDescription();
}

// Erste Strategie-Implementierung
public class WltpBasedRangeCalculationStrategy 
        implements RangeCalculationStrategyInterface {
    
    @Override
    public RangeResult calculateRange(CarProfile carProfile, 
                                     RangeParameters parameters) {
        // Berechnung basierend auf WLTP-Werten
        double baseWltpRange = carProfile.getWltpRangeKm();
        double batteryCapacity = carProfile.getBatteryProfile()
                                .getRemainingCapacityKwh();
        // ... weitere Berechnungen
        return new RangeResult(/* ... */);
    }
    // ... weitere Methoden
}</code></pre>
        </div>
        <div>
            <pre><code class="java">// Zweite Strategie-Implementierung
public class ConsumptionBasedRangeCalculationStrategy 
        implements RangeCalculationStrategyInterface {
    
    @Override
    public RangeResult calculateRange(CarProfile carProfile, 
                                     RangeParameters parameters) {
        // Berechnung basierend auf Verbrauchsprofil
        ConsumptionProfile profile = carProfile
                                    .getConsumptionProfile();
        double baseConsumption = getBaseConsumption(
            profile, parameters.getEnvironment());
        // ... weitere Berechnungen
        return new RangeResult(/* ... */);
    }

    private double getBaseConsumption(
            ConsumptionProfile profile, 
            DrivingEnvironment environment) {
        // Unterschiedliche Verbrauchswerte je nach Umgebung
        return switch(environment) {
            case CITY -> profile.getConsumptionAt50Kmh();
            case RURAL -> profile.getConsumptionAt100Kmh();
            case HIGHWAY -> profile.getConsumptionAt130Kmh();
        };
    }
    // ... weitere Methoden
}</code></pre>
        </div>
    </div>
</section>

<section>
    <h3>Strategy Pattern: Verwendung im Client</h3>
    <div class="horizontal-spaced-container">
        <div>
            <pre><code class="java">// Client-Klasse, die die Strategien verwendet
public class RangeCalculatorService {
    private final List<RangeCalculationStrategyInterface> 
                                                strategies;
    private RangeCalculationStrategyInterface defaultStrategy;

    public RangeCalculatorService() {
        this.strategies = new ArrayList<>();
        
        // Initialisierung mit Standardstrategien
        WltpBasedRangeCalculationStrategy wltpStrategy = 
                new WltpBasedRangeCalculationStrategy();
        ConsumptionBasedRangeCalculationStrategy 
                consumptionStrategy = 
                new ConsumptionBasedRangeCalculationStrategy();
        
        this.strategies.add(wltpStrategy);
        this.strategies.add(consumptionStrategy);
        
        // Standard-Strategie setzen
        this.defaultStrategy = consumptionStrategy;
    }
    
    // Strategie zur Laufzeit ändern
    public void setDefaultStrategy(
            RangeCalculationStrategyInterface strategy) {
        // ... Validierung
        this.defaultStrategy = strategy;
    }
    
    // Berechnung mit der ausgewählten Strategie
    public RangeResult calculateRange(
            CarProfile carProfile, 
            RangeParameters parameters) {
        return defaultStrategy.calculateRange(
                carProfile, parameters);
    }
}</code></pre>
        </div>
        <div>
            <h4>Vorteile des Strategy Patterns im Projekt:</h4>
            <ul>
                <li>Unterschiedliche Berechnungsmethoden für Reichweite (WLTP-basiert vs. verbrauchsbasiert)</li>
                <li>Einfaches Hinzufügen neuer Strategien ohne Änderungen im Client-Code</li>
                <li>Klare Trennung von Algorithmus und Kontext</li>
                <li>Erhöhte Testbarkeit durch isolierte Strategien</li>
                <li>Auswahl der passenden Strategie je nach Anwendungsfall</li>
                <li>Reduzierte Komplexität im RangeCalculatorService</li>
            </ul>
        </div>
    </div>
</section>

<section>
    <h3>Strategy Pattern: UML-Diagramm</h3>
    <div class="centered-container">
        <pre><code class="text">
┌───────────────────────────────────┐
│ <<interface>>                     │
│ RangeCalculationStrategyInterface │
├───────────────────────────────────┤
│ + calculateRange(CarProfile,      │
│   RangeParameters): RangeResult   │
│ + getName(): String               │
│ + getDescription(): String        │
└─────────────────┬─────────────────┘
          ▲        ▲
          │        │
          │        │
┌─────────┴──────┐ │ ┌─────────────────────────┐
│ WltpBasedRange │ │ │ ConsumptionBasedRange   │
│ CalculationStra│ │ │ CalculationStrategy     │
│ tegy           │ │ │                         │
├────────────────┤ │ ├─────────────────────────┤
│ + calculateRang│ │ │ + calculateRange(...)   │
│ e(...): RangeRe│ │ │   : RangeResult         │
│ sult           │ │ │ - getBaseConsumption(...│
│ + getName():   │ │ │   ): double             │
│   String       │ │ │ - calculateTerrainFactor│
│ + getDescriptio│ │ │   (...): double         │
│   n(): String  │ │ │ - calculateWeatherFactor│
└────────────────┘ │ │   (...): double         │
                   │ └─────────────────────────┘
                   │
                   │
           ┌───────┴─────────────┐
           │ Client:             │
           │ RangeCalculatorServi│
           │ ce                  │
           ├─────────────────────┤
           │ - strategies: List  │
           │ - defaultStrategy   │
           ├─────────────────────┤
           │ + setDefaultStrategy│
           │   (...)             │
           │ + calculateRange(...)│
           └─────────────────────┘
</code></pre>
    </div>
</section>

<section>
    <h3>Entwurfsmuster 2: Adapter Pattern (4P)</h3>
    <div class="horizontal-spaced-container">
        <div>
            <h4>Überblick</h4>
            <ul>
                <li><b>Kategorie:</b> Strukturmuster (Structural Pattern)</li>
                <li><b>Zweck:</b> Konvertiert die Schnittstelle einer Klasse in eine andere, die vom Client erwartet wird</li>
                <li><b>Verwendung:</b> Integration von I/O-Operationen in die Clean Architecture</li>
            </ul>
        </div>
        <div>
            <h4>Key Features</h4>
            <ul>
                <li>Ermöglicht Zusammenarbeit nicht-kompatibler Schnittstellen</li>
                <li>Trennt Geschäftslogik von externen Ressourcen</li>
                <li>Unterstützt das Dependency Inversion Principle</li>
                <li>Erhöht Flexibilität durch lose Kopplung</li>
                <li>Vereinfacht das Testen durch einfache Mock-Implementierungen</li>
            </ul>
        </div>
    </div>
</section>

<section>
    <h3>Adapter Pattern: Port-Interfaces und Adapter</h3>
    <div class="horizontal-spaced-container">
        <div>
            <pre><code class="java">// Port Interface in der Anwendungsschicht
package org.ulrica.application.port.out;

public interface UserInputPortInterface {
    String readLine();
    int readInt();
    double readDouble();
    boolean readBoolean(String yesOption, String noOption);
}

// Port Interface in der Anwendungsschicht
package org.ulrica.application.port.out;

public interface UserOutputPortInterface {
    void display(String message);
    void displayLine(String message);
    void displayPrompt(String prompt);
}</code></pre>
        </div>
        <div>
            <pre><code class="java">// Adapter-Implementierung in der Infrastrukturschicht
package org.ulrica.infrastructure.adapter;

import java.util.Scanner;
import org.ulrica.application.port.out.UserInputPortInterface;

public class ConsoleUserInputAdapter 
        implements UserInputPortInterface {
    private final Scanner scanner;
    
    public ConsoleUserInputAdapter(Scanner scanner) {
        this.scanner = scanner;
    }
    
    @Override
    public String readLine() {
        return scanner.nextLine().trim();
    }
    
    @Override
    public int readInt() {
        try {
            int result = scanner.nextInt();
            scanner.nextLine(); // Consume newline
            return result;
        } catch (Exception e) {
            scanner.nextLine();
            return 0; // Default value
        }
    }
    
    // ... weitere Methoden
}</code></pre>
        </div>
    </div>
</section>

<section>
    <h3>Adapter Pattern: Weitere Implementierung</h3>
    <div class="horizontal-spaced-container">
        <div>
            <pre><code class="java">// Output-Adapter-Implementierung
package org.ulrica.infrastructure.adapter;

import org.ulrica.application.port.out.UserOutputPortInterface;

public class ConsoleUserOutputAdapter 
        implements UserOutputPortInterface {
    
    @Override
    public void display(String message) {
        System.out.print(message);
    }
    
    @Override
    public void displayLine(String message) {
        System.out.println(message);
    }
    
    @Override
    public void displayPrompt(String prompt) {
        System.out.print(prompt);
    }
}</code></pre>
        </div>
        <div>
            <h4>Client-Code in der Anwendungsschicht</h4>
            <pre><code class="java">// Beispiel: Verwendung in einem Service
public class RangeCalculationController {
    private final UserInputPortInterface inputPort;
    private final UserOutputPortInterface outputPort;
    
    public RangeCalculationController(
            UserInputPortInterface inputPort,
            UserOutputPortInterface outputPort) {
        this.inputPort = inputPort;
        this.outputPort = outputPort;
    }
    
    public void askForParameters() {
        outputPort.displayPrompt("Enter temperature: ");
        double temperature = inputPort.readDouble();
        
        outputPort.displayPrompt("Use WLTP calculation? (y/n): ");
        boolean useWltp = inputPort.readBoolean("y", "n");
        
        // ... weitere Logik
    }
}</code></pre>
        </div>
    </div>
</section>

<section>
    <h3>Adapter Pattern: UML-Diagramm</h3>
    <div class="centered-container">
        <pre><code class="text">
┌───────────────────────────┐     ┌────────────────────────┐
│ <<interface>>             │     │ <<interface>>          │
│ UserInputPortInterface    │     │ UserOutputPortInterface│
├───────────────────────────┤     ├────────────────────────┤
│ + readLine(): String      │     │ + display(String): void│
│ + readInt(): int          │     │ + displayLine(String): │
│ + readDouble(): double    │     │   void                 │
│ + readBoolean(String,     │     │ + displayPrompt(String)│
│   String): boolean        │     │   : void               │
└─────────────┬─────────────┘     └──────────┬─────────────┘
              ▲                               ▲
              │                               │
              │ implements                    │ implements
              │                               │
┌─────────────┴─────────────┐     ┌──────────┴─────────────┐
│ ConsoleUserInputAdapter   │     │ ConsoleUserOutputAdapter│
├───────────────────────────┤     ├────────────────────────┤
│ - scanner: Scanner        │     │                        │
├───────────────────────────┤     ├────────────────────────┤
│ + ConsoleUserInputAdapter │     │ + display(String): void│
│   (Scanner)               │     │ + displayLine(String): │
│ + readLine(): String      │     │   void                 │
│ + readInt(): int          │     │ + displayPrompt(String)│
│ + readDouble(): double    │     │   : void               │
│ + readBoolean(String,     │     └────────────────────────┘
│   String): boolean        │
└───────────────────────────┘          ┌────────────────────────┐
              ▲                         │ Client:                │
              │                         │ RangeCalculationControl│
              │ adapts                  │ ler                    │
              │                         ├────────────────────────┤
┌─────────────┴─────────────┐          │ - inputPort: UserInputP│
│ java.util.Scanner         │◄─────────┤   ortInterface         │
│ (java.util)               │          │ - outputPort: UserOutpu│
└───────────────────────────┘          │   tPortInterface       │
                                       └────────────────────────┘
</code></pre>
    </div>
</section>

<section>
    <h3>Adapter Pattern: Vorteile im Kontext des Projekts</h3>
    <div class="horizontal-spaced-container">
        <div>
            <h4>Architektonische Vorteile</h4>
            <ul>
                <li>Einhaltung des Dependency Inversion Principle</li>
                <li>Domänen- und Anwendungsschicht kennen keine konkreten I/O-Mechanismen</li>
                <li>Infrastrukturschicht passt sich an die Ports der Anwendungsschicht an</li>
                <li>Clean Architecture mit nach innen gerichteten Abhängigkeiten</li>
            </ul>
        </div>
        <div>
            <h4>Praktische Vorteile</h4>
            <ul>
                <li>Leichte Austauschbarkeit der I/O-Mechanismen (z.B. Console → GUI)</li>
                <li>Höhere Testbarkeit durch Mocking der Ports</li>
                <li>Isolation der Geschäftslogik von technischen Details</li>
                <li>Vereinfachte Wartung und Erweiterbarkeit</li>
                <li>Wiederverwendbarkeit der Anwendungslogik in anderen Kontexten</li>
            </ul>
        </div>
    </div>
</section>